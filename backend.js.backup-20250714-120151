// backend.js - æ¥µé€Ÿè³½è»ŠéŠæˆ²å¾Œç«¯
import express from 'express';
import cors from 'cors';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import fetch from 'node-fetch';
import dotenv from 'dotenv';
import fs from 'fs';

// å°å…¥æ•¸æ“šåº«æ¨¡å‹
import db from './db/config.js';
import initDatabase from './db/init.js';
import ensureDatabaseConstraints from './ensure-database-constraints.js';
import UserModel from './db/models/user.js';
import BetModel from './db/models/bet.js';
import GameModel from './db/models/game.js';
import SessionManager from './security/session-manager.js';
import { improvedSettleBets, createSettlementTables } from './improved-settlement-system.js';

// åˆå§‹åŒ–ç’°å¢ƒè®Šé‡
dotenv.config();

// å¼·åˆ¶è¨­å®šç‚º production ç’°å¢ƒä»¥ä½¿ç”¨ Render è³‡æ–™åº«
process.env.NODE_ENV = 'production';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();
const port = process.env.PORT || 3000;

// ä»£ç†å¾Œç«¯URL - å¼·åˆ¶ä½¿ç”¨ Render ä»£ç†ç³»çµ±
const AGENT_API_URL = 'https://bet-agent.onrender.com';

console.log(`ğŸŒ ç•¶å‰ç’°å¢ƒ: ${process.env.NODE_ENV || 'development'}`);
console.log(`ğŸ”— ä»£ç†ç³»çµ±API URL: ${AGENT_API_URL} (å¼·åˆ¶ä½¿ç”¨ Render)`);

// ç«‹å³åŒæ­¥é–‹ççµæœåˆ°ä»£ç†ç³»çµ±
async function syncToAgentSystem(period, result) {
  try {
    console.log(`ğŸš€ ç«‹å³åŒæ­¥é–‹ççµæœåˆ°ä»£ç†ç³»çµ±: æœŸæ•¸=${period}`);
    
    // èª¿ç”¨ä»£ç†ç³»çµ±çš„å…§éƒ¨åŒæ­¥API
    const response = await fetch(`${AGENT_API_URL}/api/agent/sync-draw-record`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({
        period: period.toString(),
        result: result,
        draw_time: new Date().toISOString()
      })
    });
    
    if (response.ok) {
      const data = await response.json();
      console.log(`âœ… é–‹ççµæœåŒæ­¥æˆåŠŸ: æœŸæ•¸=${period}`, data);
    } else {
      console.error(`âŒ é–‹ççµæœåŒæ­¥å¤±æ•—: æœŸæ•¸=${period}, ç‹€æ…‹=${response.status}`);
    }
  } catch (error) {
    console.error(`âŒ åŒæ­¥é–‹ççµæœåˆ°ä»£ç†ç³»çµ±å‡ºéŒ¯: æœŸæ•¸=${period}`, error.message);
    // ä¸è¦æ‹‹å‡ºéŒ¯èª¤ï¼Œé¿å…å½±éŸ¿éŠæˆ²æµç¨‹
  }
}

// è·¨åŸŸè¨­ç½® - å…è¨±å‰ç«¯è¨ªå•
app.use(cors({
  origin: function(origin, callback) {
    // å…è¨±æ‰€æœ‰ä¾†æºçš„è«‹æ±‚
    const allowedOrigins = [
      'https://bet-game.onrender.com', 
      'https://bet-game-vcje.onrender.com',  // æ·»åŠ å¯¦éš›çš„Render URL
      'https://bet-agent.onrender.com',
      'http://localhost:3002', 
      'http://localhost:3000', 
      'http://localhost:8082', 
      'http://127.0.0.1:8082',
      'http://localhost:3001',
      'http://127.0.0.1:3001'
    ];
    
    // åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­ï¼Œä¹Ÿå…è¨±åŒæºè«‹æ±‚ï¼ˆæ²’æœ‰originé ­çš„è«‹æ±‚ï¼‰
    if (!origin || allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      console.log(`âŒ CORSéŒ¯èª¤: ä¸å…è¨±çš„ä¾†æº ${origin}`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept']
}));

// è™•ç†é æª¢è«‹æ±‚
app.options('*', cors());

app.use(express.json());

// æä¾›éœæ…‹æ–‡ä»¶ - é€™ä½¿å¾—å‰ç«¯æ–‡ä»¶å¯ä»¥è¢«è¨ªå•
app.use(express.static(path.join(__dirname, 'frontend')));

// æ‰€æœ‰è·¯ç”±éƒ½å°å‘ index.html (SPA è¨­ç½®)
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'frontend', 'index.html'));
});

// Favicon è·¯ç”±è™•ç†
app.get('/favicon.ico', (req, res) => {
  res.sendFile(path.join(__dirname, 'frontend', 'favicon.svg'));
});

// å¥åº·æª¢æŸ¥ç«¯é» - ç”¨æ–¼ Render ç›£æ§
app.get('/api/health', (req, res) => {
  res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() });
});

// æœƒè©±æª¢æŸ¥API - ä½¿ç”¨æ–°çš„æœƒè©±ç®¡ç†ç³»çµ±
app.get('/api/member/check-session', async (req, res) => {
  try {
    const sessionToken = req.headers['x-session-token'] || req.query.sessionToken;
    const legacyToken = req.headers.authorization?.split(' ')[1];
    
    if (sessionToken) {
      // ä½¿ç”¨æ–°çš„æœƒè©±ç®¡ç†ç³»çµ±é©—è­‰
      const session = await SessionManager.validateSession(sessionToken);
      
      if (session && session.userType === 'member') {
        return res.json({ 
          success: true, 
          message: 'Session valid',
          isAuthenticated: true,
          sessionInfo: {
            userId: session.userId,
            lastActivity: session.lastActivity
          }
        });
      } else {
        return res.json({ 
          success: false, 
          message: 'Session expired or invalid',
          needLogin: true,
          isAuthenticated: false,
          reason: 'session_invalid'
        });
      }
    } else if (legacyToken) {
      // å‘å¾Œå…¼å®¹èˆŠçš„tokenç³»çµ±
      console.log('ä½¿ç”¨èˆŠç‰ˆtokenæª¢æŸ¥æœƒè©±');
      return res.json({ 
        success: true, 
        message: 'Legacy session valid',
        isAuthenticated: true 
      });
    } else {
      // æ²’æœ‰æœƒè©±æ†‘è­‰
      return res.json({ 
        success: false, 
        message: 'No session found',
        needLogin: true,
        isAuthenticated: false,
        reason: 'no_token'
      });
    }
  } catch (error) {
    console.error('Session check error:', error);
    return res.json({ 
      success: false, 
      message: 'Session check failed',
      needLogin: true,
      isAuthenticated: false,
      reason: 'system_error'
    });
  }
});

// æœƒå“¡ç™»å‡ºAPI
app.post('/api/member/logout', async (req, res) => {
  try {
    const sessionToken = req.headers['x-session-token'] || req.body.sessionToken;
    
    if (sessionToken) {
      await SessionManager.logout(sessionToken);
      console.log('âœ… æœƒå“¡ç™»å‡ºæˆåŠŸ');
    }
    
    res.json({
      success: true,
      message: 'ç™»å‡ºæˆåŠŸ'
    });
    
  } catch (error) {
    console.error('æœƒå“¡ç™»å‡ºéŒ¯èª¤:', error);
    res.json({
      success: true, // å³ä½¿å‡ºéŒ¯ä¹Ÿè¿”å›æˆåŠŸï¼Œå› ç‚ºç™»å‡ºæ‡‰è©²ç¸½æ˜¯æˆåŠŸ
      message: 'ç™»å‡ºæˆåŠŸ'
    });
  }
});

// æœƒå“¡ç™»å…¥API
app.post('/api/member/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    console.log(`æœƒå“¡ç™»å…¥è«‹æ±‚: ${username}`);
    
    if (!username || !password) {
      return res.status(400).json({
        success: false,
        message: 'è«‹æä¾›å¸³è™Ÿå’Œå¯†ç¢¼'
      });
    }
    
    // å˜—è©¦å‘ä»£ç†ç³»çµ±æŸ¥è©¢æœƒå“¡è³‡è¨Š
    let useLocalAuth = false;
    try {
      console.log(`ğŸ”„ å˜—è©¦é€£æ¥ä»£ç†ç³»çµ±: ${AGENT_API_URL}/api/agent/member/verify-login`);
      
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 8000); // 8ç§’è¶…æ™‚
      
      const response = await fetch(`${AGENT_API_URL}/api/agent/member/verify-login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          username: username,
          password: password
        }),
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (response.ok) {
        const memberData = await response.json();
        console.log(`ğŸ“¥ ä»£ç†ç³»çµ±å›æ‡‰:`, memberData);
        
        if (memberData.success) {
          // æª¢æŸ¥æœƒå“¡ç‹€æ…‹
          if (memberData.member.status !== 1) {
            return res.status(400).json({
              success: false,
              message: 'å¸³è™Ÿå·²è¢«åœç”¨ï¼Œè«‹è¯ç¹«å®¢æœ'
            });
          }
          
          console.log(`âœ… ä»£ç†ç³»çµ±ç™»å…¥æˆåŠŸ: ${username}, ID: ${memberData.member.id}`);
          
          // ç²å–è«‹æ±‚ä¿¡æ¯
          const ipAddress = req.ip || req.connection.remoteAddress || req.headers['x-forwarded-for'];
          const userAgent = req.headers['user-agent'] || '';
          
          // å‰µå»ºæœƒè©±ï¼ˆé€™æœƒè‡ªå‹•ç™»å‡ºå…¶ä»–è£ç½®çš„æœƒè©±ï¼‰
          const sessionToken = await SessionManager.createSession('member', memberData.member.id, ipAddress, userAgent);
          
          console.log(`âœ… æœƒå“¡ç™»å…¥æˆåŠŸ: ${username} (ID: ${memberData.member.id}), IP: ${ipAddress}`);
          
          return res.json({
            success: true,
            message: 'ç™»å…¥æˆåŠŸ',
            member: {
              id: memberData.member.id,
              username: memberData.member.username,
              balance: memberData.member.balance,
              agent_id: memberData.member.agent_id,
              status: memberData.member.status,
              market_type: memberData.member.market_type || 'D'
            },
            sessionToken: sessionToken // æ–°çš„æœƒè©±token
          });
        } else {
          console.log(`âŒ ä»£ç†ç³»çµ±ç™»å…¥å¤±æ•—: ${memberData.message}`);
          useLocalAuth = true;
        }
      } else {
        console.log(`âŒ ä»£ç†ç³»çµ±HTTPéŒ¯èª¤: ${response.status} ${response.statusText}`);
        useLocalAuth = true;
      }
    } catch (agentError) {
      console.log(`âŒ ä»£ç†ç³»çµ±é€£æ¥å¤±æ•—: ${agentError.message}`);
      useLocalAuth = true;
    }
    
    // ä½¿ç”¨æœ¬åœ°é©—è­‰æ¨¡å¼
    if (useLocalAuth) {
      console.log('ğŸ”„ åˆ‡æ›åˆ°æœ¬åœ°é©—è­‰æ¨¡å¼');
      
      try {
        // å…ˆå¾è³‡æ–™åº«æŸ¥è©¢æœƒå“¡
        console.log(`ğŸ” å¾è³‡æ–™åº«æŸ¥è©¢æœƒå“¡: ${username}`);
        const member = await db.oneOrNone('SELECT id, username, password, balance, agent_id, status, market_type FROM members WHERE username = $1 AND status = 1', [username]);
        
        let user = null;
        
        if (member) {
          console.log(`ğŸ” æ‰¾åˆ°æœƒå“¡è¨˜éŒ„: ${member.username}, å¯†ç¢¼åŒ¹é…: ${member.password === password}`);
          if (member.password === password) {
            user = {
              id: member.id,
              balance: member.balance,
              agent_id: member.agent_id,
              market_type: member.market_type || 'D'
            };
            console.log(`âœ… è³‡æ–™åº«é©—è­‰æˆåŠŸ: ${username}, ID: ${member.id}, é¤˜é¡: ${member.balance}`);
          }
        } else {
          console.log(`âŒ è³‡æ–™åº«ä¸­æœªæ‰¾åˆ°æœƒå“¡: ${username}`);
        }
        
        if (!user) {
          // å¦‚æœè³‡æ–™åº«ä¸­æ²’æœ‰ï¼Œå‰‡ä½¿ç”¨ç¡¬ç·¨ç¢¼çš„æ¸¬è©¦å¸³è™Ÿ
          console.log(`ğŸ”„ å˜—è©¦ä½¿ç”¨æ¸¬è©¦å¸³è™Ÿé©—è­‰: ${username}`);
          const validUsers = {
            'test': { password: 'test', id: 1, balance: 10000 },
            'demo': { password: 'demo', id: 2, balance: 5000 },
            'user1': { password: '123456', id: 3, balance: 8000 },
            'admin': { password: 'admin123', id: 999, balance: 50000 }
          };
          
          const testUser = validUsers[username];
          if (testUser && testUser.password === password) {
            user = {
              id: testUser.id,
              balance: testUser.balance,
              agent_id: 1,
              market_type: 'D'
            };
            console.log(`âœ… æ¸¬è©¦å¸³è™Ÿé©—è­‰æˆåŠŸ: ${username}, ID: ${testUser.id}`);
          }
        }
        
        if (!user) {
          return res.status(400).json({
            success: false,
            message: 'å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤'
          });
        }
        // å‰µå»ºæˆ–æ›´æ–°æœ¬åœ°ç”¨æˆ¶
        await UserModel.createOrUpdate({
          username: username,
          balance: user.balance,
          status: 1
        });
        
        console.log(`âœ… æœ¬åœ°é©—è­‰ç™»å…¥æˆåŠŸ: ${username}, ID: ${user.id}`);
        
        const message = process.env.NODE_ENV === 'production' 
          ? 'ç™»å…¥æˆåŠŸ' 
          : 'ç™»å…¥æˆåŠŸï¼ˆæœ¬åœ°æ¨¡å¼ï¼‰';
        
        // ç²å–è«‹æ±‚ä¿¡æ¯
        const ipAddress = req.ip || req.connection.remoteAddress || req.headers['x-forwarded-for'];
        const userAgent = req.headers['user-agent'] || '';
        
        // å‰µå»ºæœƒè©±ï¼ˆé€™æœƒè‡ªå‹•ç™»å‡ºå…¶ä»–è£ç½®çš„æœƒè©±ï¼‰
        const sessionToken = await SessionManager.createSession('member', user.id, ipAddress, userAgent);
        
        console.log(`âœ… æœ¬åœ°æ¨¡å¼æœƒå“¡ç™»å…¥æˆåŠŸ: ${username} (ID: ${user.id}), IP: ${ipAddress}`);
        
        return res.json({
          success: true,
          message: message,
          member: {
            id: user.id,
            username: username,
            balance: user.balance,
            agent_id: 1,
            status: 1
          },
          sessionToken: sessionToken // æ–°çš„æœƒè©±token
        });
      } catch (dbError) {
        console.error('âŒ å‰µå»ºæœ¬åœ°ç”¨æˆ¶å¤±æ•—:', dbError);
        return res.status(500).json({
          success: false,
          message: 'ç™»å…¥è™•ç†å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦'
        });
      }
    } else {
      return res.status(400).json({
        success: false,
        message: 'å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤'
      });
    }
    
  } catch (error) {
    console.error('æœƒå“¡ç™»å…¥éŒ¯èª¤:', error);
    res.status(500).json({
      success: false,
      message: 'ç™»å…¥æœå‹™æš«æ™‚ä¸å¯ç”¨ï¼Œè«‹ç¨å¾Œå†è©¦'
    });
  }
});

// ç²å–æœƒå“¡é¤˜é¡API
app.get('/api/member/balance/:username', async (req, res) => {
  try {
    const { username } = req.params;
    
    // å‘ä»£ç†ç³»çµ±æŸ¥è©¢æœƒå“¡é¤˜é¡
    const response = await fetch(`${AGENT_API_URL}/api/agent/member-balance?username=${username}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      return res.status(400).json({
        success: false,
        message: 'ç”¨æˆ¶ä¸å­˜åœ¨'
      });
    }
    
    const balanceData = await response.json();
    
    res.json(balanceData);
    
  } catch (error) {
    console.error('ç²å–æœƒå“¡é¤˜é¡éŒ¯èª¤:', error);
    res.status(500).json({
      success: false,
      message: 'ç²å–é¤˜é¡å¤±æ•—'
    });
  }
});

// æœƒå“¡æŠ•æ³¨è¨˜éŒ„API
app.get('/api/member/bet-records/:username', async (req, res) => {
  try {
    const { username } = req.params;
    const { page = 1, limit = 20 } = req.query;
    
    // å‘ä»£ç†ç³»çµ±æŸ¥è©¢æœƒå“¡æŠ•æ³¨è¨˜éŒ„
    const response = await fetch(`${AGENT_API_URL}/api/agent/member/bet-records/${username}?page=${page}&limit=${limit}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      return res.status(400).json({
        success: false,
        message: 'ç²å–æŠ•æ³¨è¨˜éŒ„å¤±æ•—'
      });
    }
    
    const recordsData = await response.json();
    
    res.json(recordsData);
    
  } catch (error) {
    console.error('ç²å–æœƒå“¡æŠ•æ³¨è¨˜éŒ„éŒ¯èª¤:', error);
    res.status(500).json({
      success: false,
      message: 'ç²å–æŠ•æ³¨è¨˜éŒ„å¤±æ•—'
    });
  }
});

// æœƒå“¡ç›ˆè™§çµ±è¨ˆAPI
app.get('/api/member/profit-loss/:username', async (req, res) => {
  try {
    const { username } = req.params;
    const { period = 'today' } = req.query;
    
    // å‘ä»£ç†ç³»çµ±æŸ¥è©¢æœƒå“¡ç›ˆè™§
    const response = await fetch(`${AGENT_API_URL}/api/agent/member/profit-loss/${username}?period=${period}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      return res.status(400).json({
        success: false,
        message: 'ç²å–ç›ˆè™§çµ±è¨ˆå¤±æ•—'
      });
    }
    
    const profitData = await response.json();
    
    res.json(profitData);
    
  } catch (error) {
    console.error('ç²å–æœƒå“¡ç›ˆè™§çµ±è¨ˆéŒ¯èª¤:', error);
    res.status(500).json({
      success: false,
      message: 'ç²å–ç›ˆè™§çµ±è¨ˆå¤±æ•—'
    });
  }
});

// æœƒå“¡å¯†ç¢¼ä¿®æ”¹API
app.post('/api/member/change-password', async (req, res) => {
  try {
    const { username, currentPassword, newPassword } = req.body;
    
    console.log(`æ”¶åˆ°æœƒå“¡å¯†ç¢¼ä¿®æ”¹è«‹æ±‚: ${username}`);
    
    if (!username || !currentPassword || !newPassword) {
      return res.status(400).json({
        success: false,
        message: 'è«‹æä¾›å®Œæ•´ä¿¡æ¯'
      });
    }
    
    // å¯†ç¢¼é©—è­‰
    if (newPassword.length < 6) {
      return res.status(400).json({
        success: false,
        message: 'æ–°å¯†ç¢¼é•·åº¦ä¸èƒ½å°‘æ–¼6å€‹å­—ç¬¦'
      });
    }
    
    if (currentPassword === newPassword) {
      return res.status(400).json({
        success: false,
        message: 'æ–°å¯†ç¢¼ä¸èƒ½èˆ‡ç•¶å‰å¯†ç¢¼ç›¸åŒ'
      });
    }
    
    // å˜—è©¦é€£æ¥ä»£ç†ç³»çµ±ä¿®æ”¹å¯†ç¢¼
    try {
      console.log(`ğŸ”„ å‘ä»£ç†ç³»çµ±ç™¼é€å¯†ç¢¼ä¿®æ”¹è«‹æ±‚: ${AGENT_API_URL}/api/agent/member/change-password`);
      
      const response = await fetch(`${AGENT_API_URL}/api/agent/member/change-password`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          username: username,
          currentPassword: currentPassword,
          newPassword: newPassword
        })
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log(`ğŸ“¥ ä»£ç†ç³»çµ±å¯†ç¢¼ä¿®æ”¹å›æ‡‰:`, result);
        
        if (result.success) {
          console.log(`âœ… ä»£ç†ç³»çµ±å¯†ç¢¼ä¿®æ”¹æˆåŠŸ: ${username}`);
          return res.json({
            success: true,
            message: 'å¯†ç¢¼ä¿®æ”¹æˆåŠŸ'
          });
        } else {
          return res.status(400).json({
            success: false,
            message: result.message || 'å¯†ç¢¼ä¿®æ”¹å¤±æ•—'
          });
        }
      } else {
        console.log(`âŒ ä»£ç†ç³»çµ±HTTPéŒ¯èª¤: ${response.status} ${response.statusText}`);
      }
    } catch (agentError) {
      console.log(`âŒ ä»£ç†ç³»çµ±é€£æ¥å¤±æ•—: ${agentError.message}`);
    }
    
    // å¦‚æœä»£ç†ç³»çµ±å¤±æ•—ï¼Œä½¿ç”¨æœ¬åœ°é©—è­‰å’Œä¿®æ”¹
    try {
      console.log('ğŸ”„ ä½¿ç”¨æœ¬åœ°å¯†ç¢¼ä¿®æ”¹æ¨¡å¼');
      
      // é©—è­‰ç•¶å‰å¯†ç¢¼
      const member = await db.oneOrNone('SELECT id, username, password FROM members WHERE username = $1', [username]);
      
      if (!member || member.password !== currentPassword) {
        return res.status(400).json({
          success: false,
          message: 'ç•¶å‰å¯†ç¢¼éŒ¯èª¤'
        });
      }
      
      // æ›´æ–°å¯†ç¢¼
      await db.none('UPDATE members SET password = $1, updated_at = NOW() WHERE username = $2', [newPassword, username]);
      
      console.log(`âœ… æœ¬åœ°å¯†ç¢¼ä¿®æ”¹æˆåŠŸ: ${username}`);
      
      return res.json({
        success: true,
        message: 'å¯†ç¢¼ä¿®æ”¹æˆåŠŸ'
      });
    } catch (dbError) {
      console.error('âŒ æœ¬åœ°å¯†ç¢¼ä¿®æ”¹å¤±æ•—:', dbError);
      return res.status(500).json({
        success: false,
        message: 'å¯†ç¢¼ä¿®æ”¹å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦'
      });
    }
    
  } catch (error) {
    console.error('æœƒå“¡å¯†ç¢¼ä¿®æ”¹éŒ¯èª¤:', error);
    res.status(500).json({
      success: false,
      message: 'å¯†ç¢¼ä¿®æ”¹æœå‹™æš«æ™‚ä¸å¯ç”¨ï¼Œè«‹ç¨å¾Œå†è©¦'
    });
  }
});

// æœƒè©±ç‹€æ…‹æª¢æŸ¥API
app.post('/api/check-session', async (req, res) => {
  try {
    const { username } = req.body;
    
    if (!username) {
      return res.json({
        success: false,
        isValid: false,
        reason: 'no_username'
      });
    }
    
    // å‘ä»£ç†ç³»çµ±æŸ¥è©¢æœƒå“¡ç‹€æ…‹
    try {
      const response = await fetch(`${AGENT_API_URL}/api/agent/member/check-session`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          username: username
        })
      });
      
      if (!response.ok) {
        console.error(`ä»£ç†ç³»çµ±æœƒè©±æª¢æŸ¥APIå›æ‡‰éŒ¯èª¤: ${response.status}`);
        throw new Error(`ä»£ç†ç³»çµ±APIéŒ¯èª¤: ${response.status}`);
      }
      
      const agentResponse = await response.json();
      
      if (agentResponse.success) {
        res.json({
          success: true,
          isValid: agentResponse.isValid,
          reason: agentResponse.reason,
          sessionId: agentResponse.sessionId
        });
      } else {
        res.json({
          success: false,
          isValid: false,
          reason: agentResponse.reason || 'unknown_error'
        });
      }
      
    } catch (agentError) {
      console.error('ä»£ç†ç³»çµ±é€£æ¥éŒ¯èª¤:', agentError);
      
      // å¦‚æœä»£ç†ç³»çµ±ä¸å¯ç”¨ï¼Œå‡è¨­æœƒè©±æœ‰æ•ˆï¼ˆé¿å…èª¤åˆ¤ï¼‰
      res.json({
        success: true,
        isValid: true,
        reason: 'agent_system_unavailable'
      });
    }
    
  } catch (error) {
    console.error('æœƒè©±æª¢æŸ¥éŒ¯èª¤:', error);
    res.status(500).json({
      success: false,
      isValid: false,
      reason: 'system_error'
    });
  }
});

// æ–°å¢é‡å•ŸéŠæˆ²å¾ªç’°ç«¯é» - ç”¨æ–¼æ‰‹å‹•é‡å•ŸéŠæˆ²å¾ªç’°
app.get('/api/restart-game-cycle', async (req, res) => {
  try {
    console.log('æ‰‹å‹•é‡å•ŸéŠæˆ²å¾ªç’°...');
    
    // é‡å•ŸéŠæˆ²å¾ªç’°
    await startGameCycle();
    
    res.json({ 
      success: true, 
      message: 'éŠæˆ²å¾ªç’°å·²é‡å•Ÿ',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('é‡å•ŸéŠæˆ²å¾ªç’°å¤±æ•—:', error);
    res.status(500).json({ 
      success: false, 
      message: 'é‡å•ŸéŠæˆ²å¾ªç’°å¤±æ•—', 
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// æ–°å¢æ•¸æ“šåº«åˆå§‹åŒ–ç«¯é» - ç”¨æ–¼æ‰‹å‹•è§¸ç™¼æ•¸æ“šåº«åˆå§‹åŒ–
app.get('/api/init-db', async (req, res) => {
  try {
    console.log('æ‰‹å‹•è§¸ç™¼æ•¸æ“šåº«åˆå§‹åŒ–...');
    await initDatabase();
    
    // åˆå§‹åŒ–éŠæˆ²ç‹€æ…‹
    const gameState = await GameModel.getCurrentState();
    if (!gameState) {
      // å¦‚æœä¸å­˜åœ¨ï¼Œå‰µå»ºåˆå§‹éŠæˆ²ç‹€æ…‹
      await GameModel.updateState({
        current_period: 202505051077,
        countdown_seconds: 60,
        last_result: [4, 2, 7, 9, 8, 10, 6, 3, 5, 1],
        status: 'betting'
      });
      console.log('å‰µå»ºåˆå§‹éŠæˆ²ç‹€æ…‹æˆåŠŸ');
    }
    
    res.json({ 
      success: true, 
      message: 'æ•¸æ“šåº«åˆå§‹åŒ–æˆåŠŸ',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('æ•¸æ“šåº«æ‰‹å‹•åˆå§‹åŒ–å¤±æ•—:', error);
    res.status(500).json({ 
      success: false, 
      message: 'æ•¸æ“šåº«åˆå§‹åŒ–å¤±æ•—', 
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// ç›¤å£é…ç½®ç³»çµ± - ä½¿ç”¨ç²¾ç¢ºæ•¸å­¸å…¬å¼è¨ˆç®—
const MARKET_CONFIG = {
  A: {
    name: 'Aç›¤',
    rebatePercentage: 0.011, // 1.1%é€€æ°´
    description: 'é«˜è³ ç‡ç›¤å£',
    // å–®è™Ÿè³ ç‡ï¼š10 Ã— (1 - 0.011) = 9.89
    numberOdds: parseFloat((10 * (1 - 0.011)).toFixed(3)),
    // å…©é¢è³ ç‡ï¼š2 Ã— (1 - 0.011) = 1.978
    twoSideOdds: parseFloat((2 * (1 - 0.011)).toFixed(3)),
    // é¾è™è³ ç‡ï¼š2 Ã— (1 - 0.011) = 1.978
    dragonTigerOdds: parseFloat((2 * (1 - 0.011)).toFixed(3))
  },
  D: {
    name: 'Dç›¤', 
    rebatePercentage: 0.041, // 4.1%é€€æ°´
    description: 'æ¨™æº–ç›¤å£',
    // å–®è™Ÿè³ ç‡ï¼š10 Ã— (1 - 0.041) = 9.59
    numberOdds: parseFloat((10 * (1 - 0.041)).toFixed(3)),
    // å…©é¢è³ ç‡ï¼š2 Ã— (1 - 0.041) = 1.918
    twoSideOdds: parseFloat((2 * (1 - 0.041)).toFixed(3)),
    // é¾è™è³ ç‡ï¼š2 Ã— (1 - 0.041) = 1.918
    dragonTigerOdds: parseFloat((2 * (1 - 0.041)).toFixed(3))
  }
};

// å‹•æ…‹ç”Ÿæˆè³ ç‡æ•¸æ“šå‡½æ•¸
function generateOdds(marketType = 'D') {
  const config = MARKET_CONFIG[marketType] || MARKET_CONFIG.D;
  const rebatePercentage = config.rebatePercentage;
  
  // å† äºå’Œå€¼åŸºç¤è³ ç‡è¡¨ - ä½¿ç”¨ç”¨æˆ¶æä¾›çš„æ–°è³ ç‡è¡¨
  const sumValueBaseOdds = {
    '3': 45.0, '4': 23.0, '5': 15.0, '6': 11.5, '7': 9.0,
    '8': 7.5, '9': 6.5, '10': 5.7, '11': 5.7, '12': 6.5,
    '13': 7.5, '14': 9.0, '15': 11.5, '16': 15.0, '17': 23.0,
    '18': 45.0, '19': 90.0
  };
  
  // è¨ˆç®—å† äºå’Œå€¼è³ ç‡ï¼ˆæ‰£é™¤é€€æ°´ï¼‰
  const sumValueOdds = {};
  Object.keys(sumValueBaseOdds).forEach(key => {
    sumValueOdds[key] = parseFloat((sumValueBaseOdds[key] * (1 - rebatePercentage)).toFixed(3));
  });
  
  return {
    // å† äºå’Œå€¼è³ ç‡
    sumValue: {
      ...sumValueOdds,
      big: config.twoSideOdds,
      small: config.twoSideOdds,
      odd: config.twoSideOdds,
      even: config.twoSideOdds
    },
    // å–®è™Ÿè³ ç‡
    number: {
      first: config.numberOdds,
      second: config.numberOdds,
      third: config.numberOdds,
      fourth: config.numberOdds,
      fifth: config.numberOdds,
      sixth: config.numberOdds,
      seventh: config.numberOdds,
      eighth: config.numberOdds,
      ninth: config.numberOdds,
      tenth: config.numberOdds
    },
    // å„ä½ç½®å…©é¢è³ ç‡
    champion: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
    runnerup: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
    third: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
    fourth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
    fifth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
    sixth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
    seventh: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
    eighth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
    ninth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
    tenth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
    // é¾è™è³ ç‡
    dragonTiger: {
      dragon: config.dragonTigerOdds,
      tiger: config.dragonTigerOdds
    }
  };
}

// é è¨­ä½¿ç”¨Dç›¤è³ ç‡
let odds = generateOdds('D');

// é™ç´…é…ç½®
const BET_LIMITS = {
  // 1-10è»Šè™Ÿ
  number: {
    minBet: 1,      // å–®æ³¨æœ€ä½
    maxBet: 2500,   // å–®æ³¨æœ€é«˜
    periodLimit: 5000 // å–®æœŸé™é¡
  },
  // å…©é¢ (å¤§å°å–®é›™)
  twoSide: {
    minBet: 1,
    maxBet: 5000,
    periodLimit: 5000
  },
  // å† äºè»å’Œå¤§å°
  sumValueSize: {
    minBet: 1,
    maxBet: 5000,
    periodLimit: 5000
  },
  // å† äºè»å’Œå–®é›™
  sumValueOddEven: {
    minBet: 1,
    maxBet: 5000,
    periodLimit: 5000
  },
  // å† äºè»å’Œ
  sumValue: {
    minBet: 1,
    maxBet: 1000,
    periodLimit: 2000
  },
  // é¾è™
  dragonTiger: {
    minBet: 1,
    maxBet: 5000,
    periodLimit: 5000
  }
};

// åˆå§‹åŒ–ä¸€å€‹ç‰¹å®šç”¨æˆ¶çš„æœ¬åœ°è³‡æ–™
async function initializeUserData(username) {
  console.log('åˆå§‹åŒ–ç”¨æˆ¶è³‡æ–™:', username);
  
  try {
    // æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦å·²åœ¨æ•¸æ“šåº«ä¸­å­˜åœ¨
    const existingUser = await UserModel.findByUsername(username);
    if (existingUser) {
      console.log('ç”¨æˆ¶å·²å­˜åœ¨æ–¼æ•¸æ“šåº«:', username);
      return existingUser;
    }
    
    // å¾ä»£ç†ç³»çµ±ç²å–æœƒå“¡è³‡æ–™
    const response = await fetch(`${AGENT_API_URL}/api/agent/member-balance?username=${username}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      console.error('å¾ä»£ç†ç³»çµ±ç²å–æœƒå“¡è³‡æ–™å¤±æ•—:', response.status);
      // åˆå§‹åŒ–ä¸€å€‹æ–°ç”¨æˆ¶
      const newUser = await UserModel.createOrUpdate({
        username,
        balance: 0,
        status: 1
      });
      return newUser;
    }
    
    const data = await response.json();
    
    if (data.success) {
      // è¨­å®šåˆå§‹ç”¨æˆ¶è³‡æ–™
      const newUser = await UserModel.createOrUpdate({
        username,
        balance: data.balance,
        status: 1
      });
      console.log('æˆåŠŸå¾ä»£ç†ç³»çµ±åˆå§‹åŒ–ç”¨æˆ¶è³‡æ–™:', newUser);
      return newUser;
    } else {
      // åˆå§‹åŒ–ä¸€å€‹æ–°ç”¨æˆ¶
      const newUser = await UserModel.createOrUpdate({
        username,
        balance: 0,
        status: 1
      });
      console.log('å¾ä»£ç†ç³»çµ±ç²å–è³‡æ–™å¤±æ•—ï¼Œåˆå§‹åŒ–ç©ºè³‡æ–™:', newUser);
      return newUser;
    }
  } catch (error) {
    console.error('åˆå§‹åŒ–ç”¨æˆ¶è³‡æ–™å‡ºéŒ¯:', error);
    // å‡ºéŒ¯æ™‚ä¹Ÿå˜—è©¦å‰µå»ºç”¨æˆ¶
    try {
      const newUser = await UserModel.createOrUpdate({
        username,
        balance: 0,
        status: 1
      });
      return newUser;
    } catch (innerError) {
      console.error('å‰µå»ºç”¨æˆ¶æ™‚å‡ºéŒ¯:', innerError);
      throw error;
    }
  }
}

// è¨»å†ŠAPI
app.post('/api/register', async (req, res) => {
  const { username, password, confirmPassword } = req.body;
  
  // åŸºæœ¬é©—è­‰
  if (!username || !password) {
    return res.status(400).json({
      success: false,
      message: 'å¸³è™Ÿå’Œå¯†ç¢¼ä¸èƒ½ç‚ºç©º'
    });
  }
  
  if (password !== confirmPassword) {
    return res.status(400).json({
      success: false,
      message: 'å…©æ¬¡è¼¸å…¥çš„å¯†ç¢¼ä¸ä¸€è‡´'
    });
  }
  
  // ç”¨æˆ¶åæ ¼å¼é©—è­‰
  if (username.length < 3 || username.length > 20) {
    return res.status(400).json({
      success: false,
      message: 'ç”¨æˆ¶åé•·åº¦å¿…é ˆåœ¨3-20å€‹å­—ç¬¦ä¹‹é–“'
    });
  }
  
  // å¯†ç¢¼å¼·åº¦é©—è­‰
  if (password.length < 6) {
    return res.status(400).json({
      success: false,
      message: 'å¯†ç¢¼é•·åº¦ä¸èƒ½å°‘æ–¼6å€‹å­—ç¬¦'
    });
  }
  
  try {
    // æª¢æŸ¥ç”¨æˆ¶åæ˜¯å¦å·²å­˜åœ¨
    const existingUser = await UserModel.findByUsername(username);
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'è©²å¸³è™Ÿå·²è¢«è¨»å†Š'
      });
    }
    
    // å‰µå»ºæ–°ç”¨æˆ¶
    await UserModel.createOrUpdate({
      username,
      password,
      balance: 10000 // æ–°ç”¨æˆ¶åˆå§‹é¤˜é¡
    });
    
    // å˜—è©¦åŒæ­¥åˆ°ä»£ç†ç³»çµ±
    try {
      await fetch(`${AGENT_API_URL}/api/agent/sync-new-member`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          username: username,
          balance: 10000,
          reason: 'æ–°ç”¨æˆ¶è¨»å†Š'
        })
      });
    } catch (syncError) {
      console.warn('åŒæ­¥æ–°ç”¨æˆ¶åˆ°ä»£ç†ç³»çµ±å¤±æ•—:', syncError);
    }
    
    res.status(201).json({
      success: true,
      message: 'è¨»å†ŠæˆåŠŸ',
      username: username
    });
  } catch (error) {
    console.error('è¨»å†Šç”¨æˆ¶å‡ºéŒ¯:', error);
    res.status(500).json({
      success: false,
      message: 'è¨»å†Šå¤±æ•—ï¼Œç³»çµ±éŒ¯èª¤'
    });
  }
});

// å…¨å±€è®Šé‡
let gameLoopInterval = null;
let drawingTimeoutId = null;
let hotBetsInterval = null;

// å…§å­˜éŠæˆ²ç‹€æ…‹ï¼ˆæ¸›å°‘æ•¸æ“šåº«I/Oï¼‰
let memoryGameState = {
  current_period: null,
  countdown_seconds: 60,
  last_result: null,
  status: 'betting'
};

// æ¸…ç†å®šæ™‚å™¨
function cleanupTimers() {
  if (gameLoopInterval) {
    clearInterval(gameLoopInterval);
    gameLoopInterval = null;
    console.log('éŠæˆ²å¾ªç’°å®šæ™‚å™¨å·²æ¸…ç†');
  }
  
  if (drawingTimeoutId) {
    clearTimeout(drawingTimeoutId);
    drawingTimeoutId = null;
    console.log('é–‹çå®šæ™‚å™¨å·²æ¸…ç†');
  }
  
  if (hotBetsInterval) {
    clearInterval(hotBetsInterval);
    hotBetsInterval = null;
    console.log('ç†±é–€æŠ•æ³¨å®šæ™‚å™¨å·²æ¸…ç†');
  }
}

// è™•ç†é€²ç¨‹çµæŸä¿¡è™Ÿ
process.on('SIGTERM', () => {
  console.log('æ”¶åˆ°SIGTERMä¿¡è™Ÿï¼Œæ­£åœ¨æ¸…ç†è³‡æº...');
  cleanupTimers();
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('æ”¶åˆ°SIGINTä¿¡è™Ÿï¼Œæ­£åœ¨æ¸…ç†è³‡æº...');
  cleanupTimers();
  process.exit(0);
});

// æ¨¡æ“¬éŠæˆ²å¾ªç’°
async function startGameCycle() {
  try {
    // å¦‚æœå·²ç¶“æœ‰ä¸€å€‹éŠæˆ²å¾ªç’°åœ¨é‹è¡Œï¼Œå…ˆæ¸…é™¤å®ƒ
    if (gameLoopInterval) {
      console.log('æ¸…é™¤ç¾æœ‰éŠæˆ²å¾ªç’°...');
      clearInterval(gameLoopInterval);
      gameLoopInterval = null;
    }
    
    // å¦‚æœæœ‰é–‹çéç¨‹åœ¨é€²è¡Œï¼Œä¹Ÿæ¸…é™¤å®ƒ
    if (drawingTimeoutId) {
      console.log('æ¸…é™¤æœªå®Œæˆçš„é–‹çéç¨‹...');
      clearTimeout(drawingTimeoutId);
      drawingTimeoutId = null;
    }
    
    // åˆå§‹åŒ–éŠæˆ²ç‹€æ…‹
    let gameState = await GameModel.getCurrentState();
    if (!gameState) {
      // å¦‚æœä¸å­˜åœ¨ï¼Œå‰µå»ºåˆå§‹éŠæˆ²ç‹€æ…‹
      const today = new Date();
      const currentPeriod = parseInt(`${today.getFullYear()}${(today.getMonth()+1).toString().padStart(2,'0')}${today.getDate().toString().padStart(2,'0')}001`);
      
      gameState = await GameModel.updateState({
        current_period: currentPeriod, // æ ¼å¼: YYYYMMDD001
        countdown_seconds: 60,
        last_result: [4, 2, 7, 9, 8, 10, 6, 3, 5, 1],
        status: 'betting'
      });
      console.log('å‰µå»ºåˆå§‹éŠæˆ²ç‹€æ…‹æˆåŠŸ');
    } else {
      // å¦‚æœæ˜¯é‡å•Ÿï¼Œä¸”ç‹€æ…‹ç‚ºdrawingï¼Œé‡è¨­ç‚ºbetting
      if (gameState.status === 'drawing') {
        console.log('éŠæˆ²ä¹‹å‰å¡åœ¨é–‹çç‹€æ…‹ï¼Œé‡è¨­ç‚ºæŠ•æ³¨ç‹€æ…‹');
        
        // ç”Ÿæˆæ–°çµæœ
        const newResult = generateRaceResult();
        const current_period = parseInt(gameState.current_period) + 1;
        
        await GameModel.updateState({
          current_period,
          countdown_seconds: 60,
          last_result: newResult,
          status: 'betting'
        });
        
        // æ›´æ–°éŠæˆ²ç‹€æ…‹
        gameState = await GameModel.getCurrentState();
        console.log(`é‡è¨­å¾Œçš„éŠæˆ²ç‹€æ…‹: æœŸæ•¸=${gameState.current_period}, ç‹€æ…‹=${gameState.status}`);
      }
    }
    
    // åˆå§‹åŒ–å…§å­˜ç‹€æ…‹
    memoryGameState = {
      current_period: gameState.current_period,
      countdown_seconds: gameState.countdown_seconds,
      last_result: gameState.last_result,
      status: gameState.status
    };
    
    console.log(`å•Ÿå‹•éŠæˆ²å¾ªç’°: ç•¶å‰æœŸæ•¸=${memoryGameState.current_period}, ç‹€æ…‹=${memoryGameState.status}`);
    
    // æ¯ç§’æ›´æ–°å…§å­˜ç‹€æ…‹ï¼Œæ¸›å°‘æ•¸æ“šåº«å¯«å…¥
    gameLoopInterval = setInterval(async () => {
      try {
        if (memoryGameState.countdown_seconds > 0) {
          // åªæ›´æ–°å…§å­˜è¨ˆæ•¸å™¨
          memoryGameState.countdown_seconds--;
          
          // ğŸ¯ é—œéµä¿®æ”¹ï¼šå€’è¨ˆæ™‚æœ€å¾Œ10ç§’æ™‚é å…ˆç”Ÿæˆçµæœï¼ˆåªåœ¨bettingç‹€æ…‹ï¼‰
          if (memoryGameState.countdown_seconds === 10 && memoryGameState.status === 'betting' && !memoryGameState.next_result) {
            console.log('ğŸ² å€’è¨ˆæ™‚æœ€å¾Œ10ç§’ï¼Œé å…ˆç”Ÿæˆæ–°é–‹ççµæœ...');
            try {
              const preResult = await generateSmartRaceResult(memoryGameState.current_period);
              memoryGameState.next_result = preResult; // æš«å­˜æ–°çµæœ
              console.log(`ğŸ¯ æœŸè™Ÿ ${memoryGameState.current_period} é å…ˆç”Ÿæˆçµæœå·²å®Œæˆ`);
            } catch (error) {
              console.error('é å…ˆç”Ÿæˆçµæœå¤±æ•—:', error);
            }
          }
          
          // æ¯10ç§’åŒæ­¥ä¸€æ¬¡åˆ°æ•¸æ“šåº«ï¼Œç¢ºä¿æ•¸æ“šä¸€è‡´æ€§
          if (memoryGameState.countdown_seconds % 10 === 0) {
            await GameModel.updateState({
              current_period: memoryGameState.current_period,
              countdown_seconds: memoryGameState.countdown_seconds,
              last_result: memoryGameState.last_result,
              status: memoryGameState.status
            });
            console.log(`åŒæ­¥éŠæˆ²ç‹€æ…‹åˆ°æ•¸æ“šåº«: æœŸæ•¸=${memoryGameState.current_period}, å€’è¨ˆæ™‚=${memoryGameState.countdown_seconds}, ç‹€æ…‹=${memoryGameState.status}`);
          }
        } else {
          // æ ¹æ“šç•¶å‰ç‹€æ…‹è™•ç†å€’è¨ˆæ™‚çµæŸ
          if (memoryGameState.status === 'betting') {
            // bettingç‹€æ…‹å€’è¨ˆæ™‚çµæŸ -> åˆ‡æ›åˆ°drawingç‹€æ…‹
            memoryGameState.status = 'drawing';
            memoryGameState.countdown_seconds = 12; // è¨­ç½®é–‹çå€’è¨ˆæ™‚ç‚º12ç§’
            console.log('é–‹çä¸­...é–‹çå€’è¨ˆæ™‚12ç§’');
            
            // å¯«å…¥æ•¸æ“šåº«ï¼ˆé—œéµç‹€æ…‹è®Šæ›´ï¼‰
            await GameModel.updateState({
              current_period: memoryGameState.current_period,
              countdown_seconds: 12, // é–‹çéšæ®µå€’è¨ˆæ™‚12ç§’
              last_result: memoryGameState.last_result,
              status: 'drawing'
            });
          } else if (memoryGameState.status === 'drawing') {
            // drawingç‹€æ…‹å€’è¨ˆæ™‚çµæŸ -> åŸ·è¡Œé–‹çä¸¦åˆ‡æ›åˆ°ä¸‹ä¸€æœŸ
            console.log('ğŸ¯ 12ç§’é–‹çæ™‚é–“åˆ°ï¼Œé–‹å§‹çµç®—...');
            
            try {
              // ä½¿ç”¨é å…ˆç”Ÿæˆçš„çµæœï¼Œå¦‚æœæ²’æœ‰å‰‡ç¾å ´ç”Ÿæˆ
              let newResult = memoryGameState.next_result;
              if (!newResult) {
                console.log('âš ï¸ æ²’æœ‰é å…ˆç”Ÿæˆçš„çµæœï¼Œç¾å ´ç”Ÿæˆ...');
                newResult = await generateSmartRaceResult(memoryGameState.current_period);
              }
              console.log(`ğŸ² æœŸè™Ÿ ${memoryGameState.current_period} æœ€çµ‚é–‹ççµæœå·²ç”Ÿæˆ`);
              
              // ä¿å­˜ç•¶å‰æœŸè™Ÿç”¨æ–¼é–‹ç
              const currentDrawPeriod = memoryGameState.current_period;
              
              // å°‡çµæœæ·»åŠ åˆ°æ­·å²è¨˜éŒ„
              const addResultResponse = await GameModel.addResult(currentDrawPeriod, newResult);
              
              // æª¢æŸ¥æ˜¯å¦ç‚ºé‡è¤‡æœŸè™Ÿ
              if (addResultResponse && addResultResponse.isDuplicate) {
                console.log(`âš ï¸ æœŸè™Ÿ ${currentDrawPeriod} å·²å­˜åœ¨ï¼Œä½†ç¹¼çºŒè™•ç†é–‹çé‚è¼¯`);
              } else {
                console.log(`âœ… æœŸè™Ÿ ${currentDrawPeriod} é–‹ççµæœå·²æˆåŠŸä¿å­˜`);
              }
              
              // ç«‹å³åŒæ­¥åˆ°ä»£ç†ç³»çµ±
              await syncToAgentSystem(currentDrawPeriod, newResult);
              
              // çµç®—æ³¨å–®
              await settleBets(currentDrawPeriod, newResult);
              
              // ç”Ÿæˆä¸‹ä¸€æœŸè™Ÿä¸¦æ›´æ–°ç‹€æ…‹
              const nextPeriod = getNextPeriod(currentDrawPeriod);
              memoryGameState.current_period = nextPeriod;
              memoryGameState.countdown_seconds = 60;
              memoryGameState.last_result = newResult;
              memoryGameState.status = 'betting';
              memoryGameState.next_result = null; // æ¸…é™¤é å…ˆç”Ÿæˆçš„çµæœ
              
              // ç«‹å³å¯«å…¥æ•¸æ“šåº«ï¼ˆé‡è¦ç‹€æ…‹è®Šæ›´ï¼‰
              await GameModel.updateState({
                current_period: memoryGameState.current_period,
                countdown_seconds: 60,
                last_result: newResult,
                status: 'betting'
              });
              
              console.log(`âœ… ç¬¬${currentDrawPeriod}æœŸé–‹çå®Œæˆï¼Œç¬¬${memoryGameState.current_period}æœŸé–‹å§‹ï¼Œå¯ä»¥ä¸‹æ³¨ï¼Œå€’è¨ˆæ™‚é‡ç½®ç‚º60ç§’`);
              
              // æ¯5æœŸåŸ·è¡Œä¸€æ¬¡ç³»çµ±ç›£æ§èˆ‡è‡ªå‹•èª¿æ•´
              if (memoryGameState.current_period % 5 === 0) {
                monitorAndAdjustSystem();
              }
            } catch (error) {
              console.error('é–‹çéç¨‹å‡ºéŒ¯:', error);
              // å¦‚æœé–‹çå‡ºéŒ¯ï¼Œé‡ç½®ç‹€æ…‹
              memoryGameState.status = 'betting';
              memoryGameState.countdown_seconds = 60;
              memoryGameState.next_result = null;
            }
          }
        }
      } catch (error) {
        console.error('éŠæˆ²å¾ªç’°å‡ºéŒ¯:', error);
      }
    }, 1000);
    
    return { success: true, message: 'éŠæˆ²å¾ªç’°å·²å•Ÿå‹•' };
  } catch (error) {
    console.error('å•Ÿå‹•éŠæˆ²å¾ªç’°å‡ºéŒ¯:', error);
    throw error;
  }
}

// ç”Ÿæˆè³½è»Šæ¯”è³½çµæœ(1-10ä¸é‡è¤‡çš„éš¨æ©Ÿæ•¸)
function generateRaceResult() {
  const numbers = Array.from({length: 10}, (_, i) => i + 1);
  const result = [];
  
  while (numbers.length > 0) {
    const randomIndex = Math.floor(Math.random() * numbers.length);
    result.push(numbers[randomIndex]);
    numbers.splice(randomIndex, 1);
  }
  
  return result;
}

// æ™ºèƒ½æœŸè™Ÿç®¡ç† - ç¢ºä¿æœŸè™Ÿæ­£ç¢ºéå¢ä¸¦åœ¨æ¯æ—¥é‡ç½®ï¼Œæ”¯æŒè¶…é999å ´
function getNextPeriod(currentPeriod) {
  const today = new Date();
  const todayStr = `${today.getFullYear()}${(today.getMonth()+1).toString().padStart(2,'0')}${today.getDate().toString().padStart(2,'0')}`;
  
  const currentPeriodStr = currentPeriod.toString();
  
  // æª¢æŸ¥ç•¶å‰æœŸè™Ÿæ˜¯å¦ç‚ºä»Šå¤©
  if (currentPeriodStr.startsWith(todayStr)) {
    // æå–æœŸè™Ÿå¾Œç¶´ä¸¦éå¢
    const suffix = parseInt(currentPeriodStr.substring(8)) + 1;
    
    // å¦‚æœè¶…é999å ´ï¼Œä½¿ç”¨4ä½æ•¸å­—ï¼Œä½†ä¿æŒæ—¥æœŸéƒ¨åˆ†ä¸è®Š
    if (suffix > 999) {
      const newPeriod = `${todayStr}${suffix.toString().padStart(4, '0')}`;
      console.log(`ğŸ”„ æœŸè™Ÿéå¢(è¶…é999): ${currentPeriod} â†’ ${newPeriod}`);
      return newPeriod;
    } else {
      const newPeriod = parseInt(`${todayStr}${suffix.toString().padStart(3, '0')}`);
      console.log(`ğŸ”„ æœŸè™Ÿéå¢: ${currentPeriod} â†’ ${newPeriod}`);
      return newPeriod;
    }
  } else {
    // æ–°çš„ä¸€å¤©ï¼Œé‡ç½®æœŸè™Ÿç‚º001
    const newPeriod = parseInt(`${todayStr}001`);
    console.log(`ğŸŒ… æ–°çš„ä¸€å¤©ï¼ŒæœŸè™Ÿé‡ç½®: ${currentPeriod} â†’ ${newPeriod}`);
    return newPeriod;
  }
}

// æ§åˆ¶åƒæ•¸ - æ±ºå®šæ®ºå¤§è³ å°ç­–ç•¥çš„å¼·åº¦å’Œå¹³è¡¡
const CONTROL_PARAMS = {
  // ä¸‹æ³¨é¡åˆ¤å®šé–¾å€¼ï¼ˆè¶…éæ­¤å€¼è¦–ç‚ºå¤§é¡ä¸‹æ³¨ï¼‰
  thresholdAmount: 3000,
  
  // æ¬Šé‡èª¿æ•´ç³»æ•¸ (è¼ƒå¤§çš„å€¼è¡¨ç¤ºæ›´å¼·çš„å¹²é )
  adjustmentFactor: 0.7,
  
  // éš¨æ©Ÿæ€§ä¿ç•™æ¯”ä¾‹ (ç¢ºä¿ç³»çµ±ä¸æœƒå®Œå…¨å¯é æ¸¬)
  randomnessFactor: 0.3,
  
  // å–®å ´æç›Šæ§åˆ¶ (å¹³å°å–®å ´æœ€å¤§å¯æ¥å—çš„è™§æç‡)
  maxLossRate: 0.3,
  
  // æ˜¯å¦å•Ÿç”¨æ®ºå¤§è³ å°æ©Ÿåˆ¶ - æ”¹ç‚ºé è¨­é—œé–‰
  enabled: false
};

// æª¢æŸ¥è¼¸è´æ§åˆ¶è¨­å®š
async function checkWinLossControl(period) {
  try {
    console.log(`ğŸ” [åµéŒ¯] é–‹å§‹æª¢æŸ¥æœŸæ•¸ ${period} çš„è¼¸è´æ§åˆ¶è¨­å®š...`);
    console.log(`ğŸ” [åµéŒ¯] ä»£ç†ç³»çµ±API URL: ${AGENT_API_URL}/api/agent/internal/win-loss-control/active`);
    
    // èª¿ç”¨ä»£ç†ç³»çµ±å…§éƒ¨APIç²å–æ´»èºçš„è¼¸è´æ§åˆ¶è¨­å®š
    const response = await fetch(`${AGENT_API_URL}/api/agent/internal/win-loss-control/active`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      console.log(`âŒ [åµéŒ¯] æœŸæ•¸ ${period} ç„¡æ³•ç²å–è¼¸è´æ§åˆ¶è¨­å®šï¼ŒHTTPç‹€æ…‹: ${response.status}`);
              console.log(`âŒ [åµéŒ¯] API URL: ${AGENT_API_URL}/api/agent/internal/win-loss-control/active`);
      console.log(`âŒ [åµéŒ¯] éŸ¿æ‡‰ç‹€æ…‹æ–‡æœ¬: ${response.statusText}`);
      return { mode: 'normal', enabled: false };
    }

    const result = await response.json();
    console.log(`ğŸ” [åµéŒ¯] APIéŸ¿æ‡‰çµæœ:`, JSON.stringify(result, null, 2));
    
    if (!result.success || !result.data) {
      console.log(`âŒ [åµéŒ¯] æœŸæ•¸ ${period} ç„¡æ´»èºçš„è¼¸è´æ§åˆ¶è¨­å®š`);
      console.log(`âŒ [åµéŒ¯] APIéŸ¿æ‡‰: success=${result.success}, data=${result.data ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'}`);
      return { mode: 'normal', enabled: false };
    }

    const activeControl = result.data;
    console.log(`âœ… [åµéŒ¯] æ‰¾åˆ°æ´»èºæ§åˆ¶è¨­å®š:`, {
      id: activeControl.id,
      control_mode: activeControl.control_mode,
      target_username: activeControl.target_username,
      start_period: activeControl.start_period,
      control_percentage: activeControl.control_percentage,
      win_control: activeControl.win_control,
      loss_control: activeControl.loss_control,
      is_active: activeControl.is_active
    });
    
    // æª¢æŸ¥æœŸæ•¸æ˜¯å¦ç¬¦åˆæ§åˆ¶ç¯„åœ
    // çµ±ä¸€æœŸæ•¸æ ¼å¼é€²è¡Œæ¯”è¼ƒï¼ˆåªæ¯”è¼ƒæ•¸å­—éƒ¨åˆ†ï¼‰
    const currentPeriodNum = parseInt(period.toString());
    const startPeriodNum = parseInt(activeControl.start_period);
    
    if (activeControl.start_period && currentPeriodNum < startPeriodNum) {
      console.log(`âŒ [åµéŒ¯] æœŸæ•¸æª¢æŸ¥å¤±æ•—: ç•¶å‰æœŸæ•¸=${currentPeriodNum}, æ§åˆ¶é–‹å§‹æœŸæ•¸=${startPeriodNum}`);
      console.log(`âŒ [åµéŒ¯] æœŸæ•¸ ${period} æœªé”åˆ°æ§åˆ¶é–‹å§‹æœŸæ•¸ ${activeControl.start_period}ï¼Œä½¿ç”¨æ­£å¸¸æ¨¡å¼`);
      return { mode: 'normal', enabled: false };
    }

    console.log(`ğŸ¯ [åµéŒ¯] æœŸæ•¸æª¢æŸ¥é€šé: ç•¶å‰æœŸæ•¸=${period} >= æ§åˆ¶é–‹å§‹æœŸæ•¸=${activeControl.start_period || 'ç„¡é™åˆ¶'}`);
    console.log(`ğŸ¯ æœŸæ•¸ ${period} ä½¿ç”¨è¼¸è´æ§åˆ¶æ¨¡å¼: ${activeControl.control_mode}ï¼Œç›®æ¨™: ${activeControl.target_username || 'ç³»çµ±'}ï¼Œæ©Ÿç‡: ${activeControl.control_percentage}%`);
    
    return {
      mode: activeControl.control_mode,
      enabled: true,
      target_type: activeControl.target_type,
      target_username: activeControl.target_username,
      control_percentage: activeControl.control_percentage,
      win_control: activeControl.win_control,
      loss_control: activeControl.loss_control,
      start_period: activeControl.start_period
    };
  } catch (error) {
    console.error('âŒ [åµéŒ¯] æª¢æŸ¥è¼¸è´æ§åˆ¶è¨­å®šéŒ¯èª¤:', error.message);
            console.error('âŒ [åµéŒ¯] API URL:', `${AGENT_API_URL}/api/agent/internal/win-loss-control/active`);
    console.error('âŒ [åµéŒ¯] å®Œæ•´éŒ¯èª¤:', error);
    return { mode: 'normal', enabled: false };
  }
}

// æ ¹æ“šä¸‹æ³¨æƒ…æ³ç”Ÿæˆæ™ºèƒ½çµæœ
async function generateSmartRaceResult(period) {
  try {
    console.log(`ğŸ² [åµéŒ¯] æœŸæ•¸ ${period} é–‹å§‹æ™ºèƒ½é–‹çéç¨‹...`);
    
    // é¦–å…ˆæª¢æŸ¥è¼¸è´æ§åˆ¶è¨­å®š
    const winLossControl = await checkWinLossControl(period);
    console.log(`ğŸ² [åµéŒ¯] è¼¸è´æ§åˆ¶æª¢æŸ¥çµæœ:`, {
      mode: winLossControl.mode,
      enabled: winLossControl.enabled,
      target_username: winLossControl.target_username,
      control_percentage: winLossControl.control_percentage,
      start_period: winLossControl.start_period
    });
    
    // å¦‚æœæ˜¯æ­£å¸¸æ¨¡å¼ï¼Œä½¿ç”¨ç´”éš¨æ©Ÿ
    if (winLossControl.mode === 'normal' || !winLossControl.enabled) {
      console.log(`ğŸ² [åµéŒ¯] æœŸæ•¸ ${period} ä½¿ç”¨æ­£å¸¸æ©Ÿç‡æ¨¡å¼ï¼ŒåŸå› : mode=${winLossControl.mode}, enabled=${winLossControl.enabled}`);
      return generateRaceResult();
    }
    
    console.log(`ğŸ¯ [åµéŒ¯] æœŸæ•¸ ${period} é€²å…¥æ§åˆ¶æ¨¡å¼åˆ†æ...`);
    
    // åˆ†æè©²æœŸä¸‹æ³¨æƒ…æ³
    const betStats = await analyzeBetsForPeriod(period);
    console.log(`ğŸ“Š [åµéŒ¯] æœŸæ•¸ ${period} ä¸‹æ³¨åˆ†æå®Œæˆ:`, {
      totalAmount: betStats.totalAmount,
      numberBets: Object.keys(betStats.number || {}).length,
      sumValueBets: Object.keys(betStats.sumValue || {}).length
    });
    
    // è¨˜éŒ„ä¸‹æ³¨çµ±è¨ˆ
    console.log(`æœŸæ•¸ ${period} çš„ä¸‹æ³¨çµ±è¨ˆ:`, 
      { 
        totalAmount: betStats.totalAmount, 
        controlMode: winLossControl.mode,
        target: winLossControl.target_username
      }
    );
    
    // æ ¹æ“šæ§åˆ¶æ¨¡å¼æ±ºå®šç­–ç•¥
    let shouldApplyControl = false;
    
    if (winLossControl.mode === 'auto_detect') {
      console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] é–‹å§‹æ™ºèƒ½åˆ†æå…¨é«”ç©å®¶è¼¸è´æ¯”ä¾‹...`);
      
      
      // è‡ªå‹•åµæ¸¬æ¨¡å¼ï¼šåˆ†æå…¨é«”ç©å®¶èˆ‡å¹³å°çš„è¼¸è´æ¯”ä¾‹
      const autoDetectResult = await performAutoDetectAnalysis(period, betStats);
      
      console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] åˆ†æå®Œæˆ:`, {
        shouldApplyControl: autoDetectResult.shouldApplyControl,
        reason: autoDetectResult.reason,
        playerWinProbability: autoDetectResult.playerWinProbability,
        platformAdvantage: autoDetectResult.platformAdvantage
      });
      
      if (autoDetectResult.shouldApplyControl) {
        console.log(`âœ… [è‡ªå‹•åµæ¸¬] è§¸ç™¼æ™ºèƒ½æ§åˆ¶ç­–ç•¥: ${autoDetectResult.reason}`);
        const controlWeights = calculateAutoDetectWeights(autoDetectResult, betStats);
        const controlledResult = generateWeightedResult(controlWeights);
        console.log(`ğŸ¯ [è‡ªå‹•åµæ¸¬] æ™ºèƒ½æ§åˆ¶å¾Œçš„é–‹ççµæœ: ${JSON.stringify(controlledResult)}`);
        return controlledResult;
      } else {
        console.log(`ğŸ“Š [è‡ªå‹•åµæ¸¬] ç¶­æŒæ­£å¸¸æ©Ÿç‡: ${autoDetectResult.reason}`);
      }
    } else if (winLossControl.mode === 'agent_line' || winLossControl.mode === 'single_member') {
      console.log(`ğŸ” [åµéŒ¯] ä½¿ç”¨ ${winLossControl.mode} æ§åˆ¶æ¨¡å¼ï¼Œç›®æ¨™: ${winLossControl.target_username}`);
      
      // ä»£ç†ç·šæ§åˆ¶æˆ–å–®æœƒå“¡æ§åˆ¶
      shouldApplyControl = await checkTargetBets(period, winLossControl);
      
      console.log(`ğŸ” [åµéŒ¯] ç›®æ¨™ä¸‹æ³¨æª¢æŸ¥çµæœ: shouldApplyControl=${shouldApplyControl}`);
      
      if (shouldApplyControl) {
        console.log(`âœ… [åµéŒ¯] å°ç›®æ¨™ ${winLossControl.target_username} å¥—ç”¨æ§åˆ¶ç­–ç•¥`);
        const weights = await calculateTargetControlWeights(period, winLossControl, betStats);
        const controlledResult = generateWeightedResult(weights);
        console.log(`ğŸ¯ [åµéŒ¯] æ§åˆ¶å¾Œçš„é–‹ççµæœå·²ç”Ÿæˆ: ${JSON.stringify(controlledResult)}`);
        return controlledResult;
      } else {
        console.log(`âŒ [åµéŒ¯] ç›®æ¨™ ${winLossControl.target_username} æ²’æœ‰ä¸‹æ³¨ï¼Œä¸å¥—ç”¨æ§åˆ¶`);
      }
    } else {
      console.log(`âš ï¸ [åµéŒ¯] æœªçŸ¥çš„æ§åˆ¶æ¨¡å¼: ${winLossControl.mode}`);
    }
    
    // æ²’æœ‰è§¸ç™¼æ§åˆ¶æ¢ä»¶ï¼Œä½¿ç”¨æ­£å¸¸æ©Ÿç‡
    console.log(`ğŸ² [åµéŒ¯] æœŸæ•¸ ${period} æœªè§¸ç™¼æ§åˆ¶æ¢ä»¶ï¼Œä½¿ç”¨æ­£å¸¸æ©Ÿç‡ï¼ŒåŸå› : shouldApplyControl=${shouldApplyControl}`);
    const normalResult = generateRaceResult();
    console.log(`ğŸ² [åµéŒ¯] æ­£å¸¸æ©Ÿç‡é–‹ççµæœ: ${JSON.stringify(normalResult)}`);
    return normalResult;
    
  } catch (error) {
    console.error('âŒ [åµéŒ¯] æ™ºèƒ½é–‹çéç¨‹å‡ºéŒ¯:', error);
    console.error('âŒ [åµéŒ¯] éŒ¯èª¤å †æ£§:', error.stack);
    // å‡ºéŒ¯æ™‚ä½¿ç”¨æ­£å¸¸æ©Ÿç‡
    const fallbackResult = generateRaceResult();
    console.log(`ğŸ†˜ [åµéŒ¯] å‡ºéŒ¯æ™‚çš„å‚™ç”¨çµæœ: ${JSON.stringify(fallbackResult)}`);
    return fallbackResult;
  }
}

// æª¢æŸ¥ç›®æ¨™ç”¨æˆ¶æ˜¯å¦æœ‰ä¸‹æ³¨
async function checkTargetBets(period, control) {
  try {
    console.log(`ğŸ” [åµéŒ¯] æª¢æŸ¥ç›®æ¨™ä¸‹æ³¨ - æœŸæ•¸: ${period}, æ¨¡å¼: ${control.mode}, ç›®æ¨™: ${control.target_username}`);
    
    if (control.mode === 'single_member') {
      console.log(`ğŸ” [åµéŒ¯] åŸ·è¡Œå–®æœƒå“¡ä¸‹æ³¨æŸ¥è©¢...`);
      // å–®æœƒå“¡æ§åˆ¶ï¼šæª¢æŸ¥è©²æœƒå“¡æ˜¯å¦æœ‰ä¸‹æ³¨
      const memberBets = await db.oneOrNone(`
        SELECT SUM(amount) as total_amount 
        FROM bet_history 
        WHERE period = $1 AND username = $2 AND settled = false
      `, [period, control.target_username]);
      
      const totalAmount = memberBets ? parseFloat(memberBets.total_amount) || 0 : 0;
      const hasTargetBets = totalAmount > 0;
      
      console.log(`ğŸ” [åµéŒ¯] å–®æœƒå“¡ä¸‹æ³¨æŸ¥è©¢çµæœ: ç”¨æˆ¶=${control.target_username}, ç¸½é‡‘é¡=${totalAmount}, æœ‰ä¸‹æ³¨=${hasTargetBets}`);
      
      return hasTargetBets;
    } else if (control.mode === 'agent_line') {
      console.log(`ğŸ” [åµéŒ¯] åŸ·è¡Œä»£ç†ç·šä¸‹æ³¨æŸ¥è©¢...`);
      // ä»£ç†ç·šæ§åˆ¶ï¼šæª¢æŸ¥è©²ä»£ç†ä¸‹æ‰€æœ‰æœƒå“¡ï¼ˆåŒ…æ‹¬ä¸‹ç´šä»£ç†çš„æœƒå“¡ï¼‰æ˜¯å¦æœ‰ä¸‹æ³¨
      
      // é¦–å…ˆç²å–ç›®æ¨™ä»£ç†çš„ID
      const targetAgent = await db.oneOrNone('SELECT id FROM agents WHERE username = $1', [control.target_username]);
      if (!targetAgent) {
        console.log(`âŒ [åµéŒ¯] æ‰¾ä¸åˆ°ä»£ç†: ${control.target_username}`);
        return false;
      }
      
      // ä½¿ç”¨éæ­¸CTEæŸ¥è©¢ç²å–æ‰€æœ‰ä¸‹ç·šä»£ç†IDï¼ˆåŒ…æ‹¬å¤šå±¤ç´šï¼‰
      const agentLineBets = await db.oneOrNone(`
        WITH RECURSIVE agent_hierarchy AS (
          -- èµ·å§‹ï¼šç›®æ¨™ä»£ç†æœ¬èº«
          SELECT id, username, parent_id FROM agents WHERE id = $2
          UNION ALL
          -- éæ­¸ï¼šæ‰€æœ‰ä¸‹ç´šä»£ç†
          SELECT a.id, a.username, a.parent_id 
          FROM agents a
          INNER JOIN agent_hierarchy ah ON a.parent_id = ah.id
        )
        SELECT SUM(b.amount) as total_amount, COUNT(DISTINCT b.username) as member_count
        FROM bet_history b
        JOIN members m ON b.username = m.username
        JOIN agent_hierarchy ah ON m.agent_id = ah.id
        WHERE b.period = $1 AND b.settled = false
      `, [period, targetAgent.id]);
      
      const totalAmount = agentLineBets ? parseFloat(agentLineBets.total_amount) || 0 : 0;
      const memberCount = agentLineBets ? parseInt(agentLineBets.member_count) || 0 : 0;
      const hasTargetBets = totalAmount > 0;
      
      console.log(`ğŸ” [åµéŒ¯] ä»£ç†ç·šä¸‹æ³¨æŸ¥è©¢çµæœ: ä»£ç†=${control.target_username}, ç¸½é‡‘é¡=${totalAmount}, æœƒå“¡æ•¸=${memberCount}, æœ‰ä¸‹æ³¨=${hasTargetBets}`);
      
      return hasTargetBets;
    }
    
    console.log(`âš ï¸ [åµéŒ¯] æœªçŸ¥çš„æ§åˆ¶æ¨¡å¼: ${control.mode}`);
    return false;
  } catch (error) {
    console.error('âŒ [åµéŒ¯] æª¢æŸ¥ç›®æ¨™ä¸‹æ³¨éŒ¯èª¤:', error);
    console.error('âŒ [åµéŒ¯] SQLåƒæ•¸:', [period, control.target_username]);
    console.error('âŒ [åµéŒ¯] éŒ¯èª¤å †æ£§:', error.stack);
    return false;
  }
}

// è¨ˆç®—ç›®æ¨™æ§åˆ¶æ¬Šé‡
async function calculateTargetControlWeights(period, control, betStats) {
  const weights = {
    positions: Array.from({ length: 10 }, () => Array(10).fill(1)),
    sumValue: Array(17).fill(1)
  };
  
  try {
    let targetBets = [];
    
    if (control.mode === 'single_member') {
      // ç²å–è©²æœƒå“¡çš„ä¸‹æ³¨
      targetBets = await db.any(`
        SELECT bet_type, bet_value, position, amount
        FROM bet_history 
        WHERE period = $1 AND username = $2 AND settled = false
      `, [period, control.target_username]);
    } else if (control.mode === 'agent_line') {
      // ç²å–è©²ä»£ç†ä¸‹æ‰€æœ‰æœƒå“¡çš„ä¸‹æ³¨ï¼ˆåŒ…æ‹¬ä¸‹ç´šä»£ç†çš„æœƒå“¡ï¼‰
      
      // é¦–å…ˆç²å–ç›®æ¨™ä»£ç†çš„ID
      const targetAgent = await db.oneOrNone('SELECT id FROM agents WHERE username = $1', [control.target_username]);
      if (!targetAgent) {
        console.log(`âŒ [è¨ˆç®—æ¬Šé‡] æ‰¾ä¸åˆ°ä»£ç†: ${control.target_username}`);
        return weights;
      }
      
      // ä½¿ç”¨éæ­¸CTEæŸ¥è©¢ç²å–æ‰€æœ‰ä¸‹ç·šçš„ä¸‹æ³¨
      targetBets = await db.any(`
        WITH RECURSIVE agent_hierarchy AS (
          -- èµ·å§‹ï¼šç›®æ¨™ä»£ç†æœ¬èº«
          SELECT id, username, parent_id FROM agents WHERE id = $2
          UNION ALL
          -- éæ­¸ï¼šæ‰€æœ‰ä¸‹ç´šä»£ç†
          SELECT a.id, a.username, a.parent_id 
          FROM agents a
          INNER JOIN agent_hierarchy ah ON a.parent_id = ah.id
        )
        SELECT b.bet_type, b.bet_value, b.position, b.amount, b.username
        FROM bet_history b
        JOIN members m ON b.username = m.username
        JOIN agent_hierarchy ah ON m.agent_id = ah.id
        WHERE b.period = $1 AND b.settled = false
      `, [period, targetAgent.id]);
    }
    
    // æ ¹æ“šæ§åˆ¶è¨­å®šèª¿æ•´æ¬Šé‡ - ä½¿ç”¨æ›´å¼·çš„æ§åˆ¶é‚è¼¯
    const controlFactor = (control.control_percentage / 100);
    
    console.log(`ğŸ¯ ç›®æ¨™æ§åˆ¶è©³æƒ…: ç”¨æˆ¶=${control.target_username}, æ¨¡å¼=${control.mode}, è´æ§åˆ¶=${control.win_control}, è¼¸æ§åˆ¶=${control.loss_control}, æ©Ÿç‡=${control.control_percentage}%`);
    console.log(`ğŸ“Š æ‰¾åˆ° ${targetBets.length} ç­†ç›®æ¨™ä¸‹æ³¨`);
    
    // çµ±è¨ˆä¸‹æ³¨åˆ†ä½ˆä»¥è™•ç†å¤šäººä¸‹æ³¨è¡çª
    const betConflicts = {};
    targetBets.forEach(bet => {
      let betKey;
      if (bet.bet_type === 'number') {
        betKey = `number_${bet.position}_${bet.bet_value}`;
      } else if (bet.bet_type === 'sumValue') {
        betKey = `sumValue_${bet.bet_value}`;
      } else {
        betKey = `${bet.bet_type}_${bet.bet_value}`;
      }
      
      if (!betConflicts[betKey]) {
        betConflicts[betKey] = { 
          totalAmount: 0, 
          userCount: 0, 
          users: new Set(),
          bets: []
        };
      }
      
      betConflicts[betKey].totalAmount += parseFloat(bet.amount);
      betConflicts[betKey].users.add(bet.username);
      betConflicts[betKey].userCount = betConflicts[betKey].users.size;
      betConflicts[betKey].bets.push(bet);
    });
    
    // è¨˜éŒ„è¡çªæƒ…æ³
    Object.entries(betConflicts).forEach(([key, conflict]) => {
      if (conflict.userCount > 1) {
        console.log(`âš ï¸ å¤šäººä¸‹æ³¨è¡çª: ${key}, ç”¨æˆ¶æ•¸=${conflict.userCount}, ç¸½é‡‘é¡=${conflict.totalAmount}, ç”¨æˆ¶=[${Array.from(conflict.users).join(', ')}]`);
      }
    });
    
    // ä½¿ç”¨åˆä½µå¾Œçš„ä¸‹æ³¨è³‡æ–™é€²è¡Œæ¬Šé‡èª¿æ•´ï¼Œé¿å…é‡è¤‡è™•ç†
    Object.entries(betConflicts).forEach(([betKey, conflict]) => {
      const bet = conflict.bets[0]; // ä½¿ç”¨ç¬¬ä¸€ç­†ä¸‹æ³¨çš„è³‡æ–™åšé¡å‹åˆ¤æ–·
      const totalAmount = conflict.totalAmount;
      const userCount = conflict.userCount;
      
      // ğŸ¯ è¨ˆç®—çµ±ä¸€çš„æ§åˆ¶ä¿‚æ•¸ï¼ŒåŒ…å«è¡çªè™•ç†
      const baseControlFactor = parseFloat(control.control_percentage) / 100; // åŸºç¤æ§åˆ¶ä¿‚æ•¸ (0-1)
      const conflictMultiplier = Math.min(1.0 + (userCount - 1) * 0.2, 2.0); // è¡çªå€æ•¸ï¼šæ¯å¤š1äººå¢åŠ 20%ï¼Œæœ€é«˜200%
      const finalControlFactor = Math.min(baseControlFactor * conflictMultiplier, 1.0); // æœ€çµ‚æ§åˆ¶ä¿‚æ•¸ï¼Œä¸è¶…é100%
      
      console.log(`ğŸ“‹ è™•ç†åˆä½µä¸‹æ³¨: ${betKey}, é¡å‹=${bet.bet_type}, å€¼=${bet.bet_value}, ä½ç½®=${bet.position}`);
      console.log(`ğŸ’° ç¸½é‡‘é¡=${totalAmount}, ç”¨æˆ¶æ•¸=${userCount}, åŸºç¤æ§åˆ¶=${(baseControlFactor*100).toFixed(1)}%, è¡çªå€æ•¸=${conflictMultiplier.toFixed(2)}, æœ€çµ‚æ§åˆ¶=${(finalControlFactor*100).toFixed(1)}%`);
      
      if (bet.bet_type === 'number') {
        const position = parseInt(bet.position) - 1;
        const value = parseInt(bet.bet_value) - 1;
        if (position >= 0 && position < 10 && value >= 0 && value < 10) {
          if (control.win_control) {
            // è´æ§åˆ¶ï¼šç¢ºä¿ç›®æ¨™ä¸‹æ³¨æ›´å®¹æ˜“ä¸­ç
            if (finalControlFactor >= 0.95) {
              weights.positions[position][value] = 1000; // 95%ä»¥ä¸Šæ§åˆ¶æ™‚ä½¿ç”¨æ¥µé«˜æ¬Šé‡
            } else if (finalControlFactor <= 0.05) {
              weights.positions[position][value] = 1; // 5%ä»¥ä¸‹æ§åˆ¶æ™‚ä¸èª¿æ•´æ¬Šé‡
            } else {
              // ç²¾ç¢ºæ¬Šé‡è¨ˆç®—ï¼šè€ƒæ…®è©²ä½ç½®çš„ç›®æ¨™è™Ÿç¢¼æ•¸é‡
              const samePositionBets = Object.keys(betConflicts).filter(key => 
                key.startsWith(`number_${bet.position}_`)
              ).length;
              
              const targetCount = samePositionBets;
              const nonTargetCount = 10 - targetCount;
              
              // æ¬Šé‡å…¬å¼ï¼šW = (P * M) / ((1 - P) * N)ï¼Œå…¶ä¸­Pç‚ºæ§åˆ¶ä¿‚æ•¸ï¼ŒMç‚ºéç›®æ¨™æ•¸ï¼ŒNç‚ºç›®æ¨™æ•¸
              const targetWeight = (finalControlFactor * nonTargetCount) / ((1 - finalControlFactor) * Math.max(targetCount, 1));
              weights.positions[position][value] = Math.max(targetWeight, 0.001);
              
              console.log(`ğŸ“Š [è´æ§åˆ¶] ä½ç½®${position+1}: ${targetCount}å€‹ç›®æ¨™è™Ÿç¢¼, ${nonTargetCount}å€‹éç›®æ¨™è™Ÿç¢¼ â†’ æ¬Šé‡=${targetWeight.toFixed(3)}`);
            }
            
            console.log(`âœ… å¢åŠ ä½ç½®${position+1}è™Ÿç¢¼${value+1}çš„æ¬Šé‡ (è´æ§åˆ¶), æœ€çµ‚æ¬Šé‡=${weights.positions[position][value].toFixed(3)}, ç”¨æˆ¶æ•¸=${userCount}`);
          } else if (control.loss_control) {
            // è¼¸æ§åˆ¶ï¼šç¢ºä¿ç›®æ¨™ä¸‹æ³¨æ›´é›£ä¸­ç
            if (finalControlFactor >= 0.95) {
              weights.positions[position][value] = 0.001; // 95%ä»¥ä¸Šæ§åˆ¶æ™‚ä½¿ç”¨æ¥µä½æ¬Šé‡
            } else if (finalControlFactor <= 0.05) {
              weights.positions[position][value] = 1; // 5%ä»¥ä¸‹æ§åˆ¶æ™‚ä¸èª¿æ•´æ¬Šé‡
            } else {
              // è¼¸æ§åˆ¶é‚è¼¯ï¼šæœƒå“¡ä¸­çæ©Ÿç‡ = (1 - æ§åˆ¶ä¿‚æ•¸)
              const samePositionBets = Object.keys(betConflicts).filter(key => 
                key.startsWith(`number_${bet.position}_`)
              ).length;
              
              const targetCount = samePositionBets;
              const nonTargetCount = 10 - targetCount;
              const winProbability = 1 - finalControlFactor; // æœƒå“¡å¯¦éš›ä¸­çæ©Ÿç‡
              
              // è¨ˆç®—è¼¸æ§åˆ¶æ¬Šé‡ï¼šW = (winP * M) / ((1 - winP) * N)
              const targetWeight = (winProbability * nonTargetCount) / ((1 - winProbability) * Math.max(targetCount, 1));
              weights.positions[position][value] = Math.max(targetWeight, 0.001);
              
              console.log(`ğŸ“Š [è¼¸æ§åˆ¶] ä½ç½®${position+1}: ${targetCount}å€‹ç›®æ¨™è™Ÿç¢¼, ä¸­çæ©Ÿç‡=${(winProbability*100).toFixed(1)}% â†’ æ¬Šé‡=${targetWeight.toFixed(3)}`);
            }
            
            console.log(`âŒ è¨­ç½®ä½ç½®${position+1}è™Ÿç¢¼${value+1}çš„æ¬Šé‡ (è¼¸æ§åˆ¶), æœ€çµ‚æ¬Šé‡=${weights.positions[position][value].toFixed(3)}, ç”¨æˆ¶æ•¸=${userCount}`);
          }
        }
      } else if (bet.bet_type === 'sumValue') {
        if (!isNaN(parseInt(bet.bet_value))) {
          const sumIndex = parseInt(bet.bet_value) - 3;
          if (sumIndex >= 0 && sumIndex < 17) {
            if (control.win_control) {
              // è´æ§åˆ¶ï¼šå¢åŠ è©²å’Œå€¼çš„æ¬Šé‡
              if (finalControlFactor >= 0.95) {
                weights.sumValue[sumIndex] = 1000; // æ¥µé«˜æ§åˆ¶æ™‚ä½¿ç”¨æ¥µé«˜æ¬Šé‡
              } else {
                weights.sumValue[sumIndex] *= (1 + finalControlFactor * 15); // æ ¹æ“šæ§åˆ¶ä¿‚æ•¸èª¿æ•´æ¬Šé‡
              }
              console.log(`âœ… å¢åŠ å’Œå€¼${bet.bet_value}çš„æ¬Šé‡ (è´æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
            } else if (control.loss_control) {
              // è¼¸æ§åˆ¶ï¼šæ¸›å°‘è©²å’Œå€¼çš„æ¬Šé‡
              if (finalControlFactor >= 0.95) {
                weights.sumValue[sumIndex] = 0.001; // æ¥µé«˜æ§åˆ¶æ™‚ä½¿ç”¨æ¥µä½æ¬Šé‡
              } else {
                weights.sumValue[sumIndex] *= Math.max(1 - finalControlFactor * 0.95, 0.001); // æ ¹æ“šæ§åˆ¶ä¿‚æ•¸èª¿æ•´æ¬Šé‡
              }
              console.log(`âŒ æ¸›å°‘å’Œå€¼${bet.bet_value}çš„æ¬Šé‡ (è¼¸æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
            }
          }
        } else if (['big', 'small', 'odd', 'even'].includes(bet.bet_value)) {
          // è™•ç†å† äºå’Œå¤§å°å–®é›™
          if (control.win_control) {
            // è´æ§åˆ¶ï¼šèª¿æ•´ç›¸æ‡‰ç¯„åœçš„å’Œå€¼æ¬Šé‡
            for (let i = 0; i < 17; i++) {
              const sumValue = i + 3; // å¯¦éš›å’Œå€¼ 3-19
              let shouldIncrease = false;
              
              if (bet.bet_value === 'big' && sumValue >= 12) shouldIncrease = true;
              else if (bet.bet_value === 'small' && sumValue <= 11) shouldIncrease = true;
              else if (bet.bet_value === 'odd' && sumValue % 2 === 1) shouldIncrease = true;
              else if (bet.bet_value === 'even' && sumValue % 2 === 0) shouldIncrease = true;
              
              if (shouldIncrease) {
                if (finalControlFactor >= 0.95) {
                  weights.sumValue[i] *= 1000;
                } else {
                  weights.sumValue[i] *= (1 + finalControlFactor * 15);
                }
              }
            }
            console.log(`âœ… å¢åŠ å† äºå’Œ${bet.bet_value}çš„æ¬Šé‡ (è´æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
          } else if (control.loss_control) {
            // è¼¸æ§åˆ¶ï¼šèª¿æ•´ç›¸æ‡‰ç¯„åœçš„å’Œå€¼æ¬Šé‡
            for (let i = 0; i < 17; i++) {
              const sumValue = i + 3;
              let shouldDecrease = false;
              
              if (bet.bet_value === 'big' && sumValue >= 11) shouldDecrease = true;
              else if (bet.bet_value === 'small' && sumValue <= 10) shouldDecrease = true;
              else if (bet.bet_value === 'odd' && sumValue % 2 === 1) shouldDecrease = true;
              else if (bet.bet_value === 'even' && sumValue % 2 === 0) shouldDecrease = true;
              
              if (shouldDecrease) {
                if (finalControlFactor >= 0.95) {
                  weights.sumValue[i] = 0.001;
                } else {
                  weights.sumValue[i] *= Math.max(1 - finalControlFactor * 0.95, 0.001);
                }
              }
            }
            console.log(`âŒ æ¸›å°‘å† äºå’Œ${bet.bet_value}çš„æ¬Šé‡ (è¼¸æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
          }
        }
      } else if (['champion', 'runnerup', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth'].includes(bet.bet_type)) {
        // è™•ç†ä½ç½®æŠ•æ³¨ï¼ˆåŒ…æ‹¬è™Ÿç¢¼æŠ•æ³¨å’Œå¤§å°å–®é›™ï¼‰
        const positionMap = {
          'champion': 0, 'runnerup': 1, 'third': 2, 'fourth': 3, 'fifth': 4,
          'sixth': 5, 'seventh': 6, 'eighth': 7, 'ninth': 8, 'tenth': 9
        };
        const position = positionMap[bet.bet_type];
        
        if (!isNaN(parseInt(bet.bet_value))) {
          // è™Ÿç¢¼æŠ•æ³¨
          const value = parseInt(bet.bet_value) - 1;
          if (value >= 0 && value < 10) {
            if (control.win_control) {
              if (finalControlFactor >= 0.95) {
                weights.positions[position][value] *= 1000;
              } else {
                weights.positions[position][value] *= (1 + finalControlFactor * 15);
              }
              console.log(`âœ… å¢åŠ ${bet.bet_type}è™Ÿç¢¼${bet.bet_value}çš„æ¬Šé‡ (è´æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
            } else if (control.loss_control) {
              if (finalControlFactor >= 0.95) {
                weights.positions[position][value] = 0.001;
              } else {
                weights.positions[position][value] *= Math.max(1 - finalControlFactor * 0.95, 0.001);
              }
              console.log(`âŒ æ¸›å°‘${bet.bet_type}è™Ÿç¢¼${bet.bet_value}çš„æ¬Šé‡ (è¼¸æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
            }
          }
        } else if (['big', 'small', 'odd', 'even'].includes(bet.bet_value)) {
          // å…©é¢æŠ•æ³¨ï¼ˆå¤§å°å–®é›™ï¼‰
          if (control.win_control) {
            // è´æ§åˆ¶ï¼šèª¿æ•´è©²ä½ç½®ç¬¦åˆæ¢ä»¶çš„è™Ÿç¢¼æ¬Šé‡
            for (let value = 0; value < 10; value++) {
              const actualValue = value + 1; // å¯¦éš›è™Ÿç¢¼ 1-10
              let shouldIncrease = false;
              
              if (bet.bet_value === 'big' && actualValue >= 6) shouldIncrease = true;
              else if (bet.bet_value === 'small' && actualValue <= 5) shouldIncrease = true;
              else if (bet.bet_value === 'odd' && actualValue % 2 === 1) shouldIncrease = true;
              else if (bet.bet_value === 'even' && actualValue % 2 === 0) shouldIncrease = true;
              
              if (shouldIncrease) {
                if (finalControlFactor >= 0.95) {
                  weights.positions[position][value] *= 1000;
                } else {
                  weights.positions[position][value] *= (1 + finalControlFactor * 15);
                }
              }
            }
            console.log(`âœ… å¢åŠ ${bet.bet_type}${bet.bet_value}çš„æ¬Šé‡ (è´æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
          } else if (control.loss_control) {
            // è¼¸æ§åˆ¶ï¼šèª¿æ•´è©²ä½ç½®ç¬¦åˆæ¢ä»¶çš„è™Ÿç¢¼æ¬Šé‡
            for (let value = 0; value < 10; value++) {
              const actualValue = value + 1;
              let shouldDecrease = false;
              
              if (bet.bet_value === 'big' && actualValue >= 6) shouldDecrease = true;
              else if (bet.bet_value === 'small' && actualValue <= 5) shouldDecrease = true;
              else if (bet.bet_value === 'odd' && actualValue % 2 === 1) shouldDecrease = true;
              else if (bet.bet_value === 'even' && actualValue % 2 === 0) shouldDecrease = true;
              
              if (shouldDecrease) {
                if (finalControlFactor >= 0.95) {
                  weights.positions[position][value] = 0.001;
                } else {
                  weights.positions[position][value] *= Math.max(1 - finalControlFactor * 0.95, 0.001);
                }
              }
            }
            console.log(`âŒ æ¸›å°‘${bet.bet_type}${bet.bet_value}çš„æ¬Šé‡ (è¼¸æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
          }
        }

      } else if (bet.bet_type === 'dragonTiger') {
        // è™•ç†é¾è™æŠ•æ³¨ - æ”¯æ´æ‰€æœ‰ä½ç½®å°æ¯”
        // æ ¼å¼ï¼šdragon, tiger (å‚³çµ±å† è»vsäºè») æˆ– dragon_pos1_pos2, tiger_pos1_pos2
        
        let dragonTigerType, pos1, pos2;
        
        if (bet.bet_value === 'dragon' || bet.bet_value === 'tiger') {
          // å‚³çµ±æ ¼å¼ï¼šé»˜èªå† è»vsäºè»
          dragonTigerType = bet.bet_value;
          pos1 = 0; // å† è»
          pos2 = 1; // äºè»
        } else if (typeof bet.bet_value === 'string' && 
                   (bet.bet_value.startsWith('dragon_') || bet.bet_value.startsWith('tiger_'))) {
          // è¤‡é›œæ ¼å¼ï¼šdragon_4_7 è¡¨ç¤ºç¬¬4åvsç¬¬7å
          const parts = bet.bet_value.split('_');
          if (parts.length === 3) {
            dragonTigerType = parts[0];
            pos1 = parseInt(parts[1]) - 1; // è½‰ç‚º0-9ç´¢å¼•
            pos2 = parseInt(parts[2]) - 1;
            
            // é©—è­‰ä½ç½®æœ‰æ•ˆæ€§
            if (isNaN(pos1) || isNaN(pos2) || pos1 < 0 || pos1 > 9 || pos2 < 0 || pos2 > 9 || pos1 === pos2) {
              console.warn(`âš ï¸ ç„¡æ•ˆçš„é¾è™æŠ•æ³¨æ ¼å¼: ${bet.bet_value}`);
              return weights;
            }
          } else {
            console.warn(`âš ï¸ ç„¡æ³•è§£æé¾è™æŠ•æ³¨æ ¼å¼: ${bet.bet_value}`);
            return weights;
          }
        } else {
          console.warn(`âš ï¸ æœªçŸ¥çš„é¾è™æŠ•æ³¨æ ¼å¼: ${bet.bet_value}`);
          return weights;
        }
        
        if (control.win_control) {
          if (dragonTigerType === 'dragon') {
            // é¾è´ï¼špos1 > pos2ï¼Œå¢åŠ pos1å¤§è™Ÿç¢¼æ¬Šé‡ï¼Œæ¸›å°‘pos2å¤§è™Ÿç¢¼æ¬Šé‡
            for (let value = 5; value < 10; value++) {
              if (finalControlFactor >= 0.95) {
                weights.positions[pos1][value] *= 1000; // pos1å¤§è™Ÿç¢¼
                weights.positions[pos2][value] = 0.001; // pos2å¤§è™Ÿç¢¼
              } else {
                weights.positions[pos1][value] *= (1 + finalControlFactor * 15);
                weights.positions[pos2][value] *= Math.max(1 - finalControlFactor * 0.8, 0.001);
              }
            }
            // åŒæ™‚å¢åŠ pos1å°è™Ÿç¢¼çš„åå‘æ¬Šé‡ï¼Œæ¸›å°‘pos2å°è™Ÿç¢¼æ¬Šé‡
            for (let value = 0; value < 5; value++) {
              if (finalControlFactor >= 0.95) {
                weights.positions[pos1][value] = 0.001; // pos1å°è™Ÿç¢¼
                weights.positions[pos2][value] *= 1000; // pos2å°è™Ÿç¢¼
              } else {
                weights.positions[pos1][value] *= Math.max(1 - finalControlFactor * 0.8, 0.001);
                weights.positions[pos2][value] *= (1 + finalControlFactor * 15);
              }
            }
            console.log(`âœ… å¢åŠ é¾çš„ç²å‹æ¬Šé‡ (ç¬¬${pos1+1}åvsç¬¬${pos2+1}å) (è´æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
          } else if (dragonTigerType === 'tiger') {
            // è™è´ï¼špos2 > pos1ï¼Œå¢åŠ pos2å¤§è™Ÿç¢¼æ¬Šé‡ï¼Œæ¸›å°‘pos1å¤§è™Ÿç¢¼æ¬Šé‡
            for (let value = 5; value < 10; value++) {
              if (finalControlFactor >= 0.95) {
                weights.positions[pos2][value] *= 1000; // pos2å¤§è™Ÿç¢¼
                weights.positions[pos1][value] = 0.001; // pos1å¤§è™Ÿç¢¼
              } else {
                weights.positions[pos2][value] *= (1 + finalControlFactor * 15);
                weights.positions[pos1][value] *= Math.max(1 - finalControlFactor * 0.8, 0.001);
              }
            }
            // åŒæ™‚è™•ç†å°è™Ÿç¢¼
            for (let value = 0; value < 5; value++) {
              if (finalControlFactor >= 0.95) {
                weights.positions[pos2][value] = 0.001; // pos2å°è™Ÿç¢¼
                weights.positions[pos1][value] *= 1000; // pos1å°è™Ÿç¢¼
              } else {
                weights.positions[pos2][value] *= Math.max(1 - finalControlFactor * 0.8, 0.001);
                weights.positions[pos1][value] *= (1 + finalControlFactor * 15);
              }
            }
            console.log(`âœ… å¢åŠ è™çš„ç²å‹æ¬Šé‡ (ç¬¬${pos1+1}åvsç¬¬${pos2+1}å) (è´æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
          }
        } else if (control.loss_control) {
          // è¼¸æ§åˆ¶ï¼šåå‘æ“ä½œ
          if (dragonTigerType === 'dragon') {
            // é¾è¼¸ï¼šè®“è™è´ï¼Œå¢åŠ pos2å¤§è™Ÿç¢¼æ¬Šé‡
            for (let value = 5; value < 10; value++) {
              if (finalControlFactor >= 0.95) {
                weights.positions[pos2][value] *= 1000;
                weights.positions[pos1][value] = 0.001;
              } else {
                weights.positions[pos2][value] *= (1 + finalControlFactor * 15);
                weights.positions[pos1][value] *= Math.max(1 - finalControlFactor * 0.8, 0.001);
              }
            }
            for (let value = 0; value < 5; value++) {
              if (finalControlFactor >= 0.95) {
                weights.positions[pos2][value] = 0.001;
                weights.positions[pos1][value] *= 1000;
              } else {
                weights.positions[pos2][value] *= Math.max(1 - finalControlFactor * 0.8, 0.001);
                weights.positions[pos1][value] *= (1 + finalControlFactor * 15);
              }
            }
            console.log(`âŒ æ¸›å°‘é¾çš„ç²å‹æ¬Šé‡ (ç¬¬${pos1+1}åvsç¬¬${pos2+1}å) (è¼¸æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
          } else if (dragonTigerType === 'tiger') {
            // è™è¼¸ï¼šè®“é¾è´ï¼Œå¢åŠ pos1å¤§è™Ÿç¢¼æ¬Šé‡
            for (let value = 5; value < 10; value++) {
              if (finalControlFactor >= 0.95) {
                weights.positions[pos1][value] *= 1000;
                weights.positions[pos2][value] = 0.001;
              } else {
                weights.positions[pos1][value] *= (1 + finalControlFactor * 15);
                weights.positions[pos2][value] *= Math.max(1 - finalControlFactor * 0.8, 0.001);
              }
            }
            for (let value = 0; value < 5; value++) {
              if (finalControlFactor >= 0.95) {
                weights.positions[pos1][value] = 0.001;
                weights.positions[pos2][value] *= 1000;
              } else {
                weights.positions[pos1][value] *= Math.max(1 - finalControlFactor * 0.8, 0.001);
                weights.positions[pos2][value] *= (1 + finalControlFactor * 15);
              }
            }
            console.log(`âŒ æ¸›å°‘è™çš„ç²å‹æ¬Šé‡ (ç¬¬${pos1+1}åvsç¬¬${pos2+1}å) (è¼¸æ§åˆ¶), ç”¨æˆ¶æ•¸=${userCount}, æ§åˆ¶ä¿‚æ•¸=${finalControlFactor.toFixed(3)}`);
          }
        }
      } else {
        // å…¶ä»–æœªçŸ¥ä¸‹æ³¨é¡å‹
        console.log(`âš ï¸ æœªè™•ç†çš„ä¸‹æ³¨é¡å‹: ${bet.bet_type}=${bet.bet_value}, ä½ç½®=${bet.position || 'N/A'}`);
      }
    });
    
    console.log(`ç›®æ¨™æ§åˆ¶æ¬Šé‡èª¿æ•´å®Œæˆ: ${control.target_username}, æ§åˆ¶æ¯”ä¾‹: ${control.control_percentage}%`);
    
  } catch (error) {
    console.error('è¨ˆç®—ç›®æ¨™æ§åˆ¶æ¬Šé‡éŒ¯èª¤:', error);
  }
  
  return weights;
}

// åœ¨é–‹çå‰åˆ†ææ­¤æœŸæ‰€æœ‰æ³¨å–®
async function analyzeBetsForPeriod(period) {
  // ç²å–è©²æœŸæ‰€æœ‰æ³¨å–®
  const allBets = await BetModel.getUnsettledByPeriod(period);
  
  // åˆå§‹åŒ–çµ±è¨ˆ
  const betStats = {
    sumValue: {}, // å† äºå’Œ
    number: {}, // è™Ÿç¢¼ç©æ³•
    champion: {}, // å† è»
    runnerup: {}, // äºè»
    third: {}, // ç¬¬ä¸‰
    fourth: {}, // ç¬¬å››
    fifth: {}, // ç¬¬äº”
    sixth: {}, // ç¬¬å…­
    seventh: {}, // ç¬¬ä¸ƒ
    eighth: {}, // ç¬¬å…«
    ninth: {}, // ç¬¬ä¹
    tenth: {}, // ç¬¬å
    dragonTiger: {}, // é¾è™
    totalAmount: 0 // ç¸½ä¸‹æ³¨é‡‘é¡
  };
  
  // çµ±è¨ˆæ¯ç¨®æŠ•æ³¨é¡å‹å’Œå€¼çš„ä¸‹æ³¨ç¸½é¡
  allBets.forEach(bet => {
    const betType = bet.bet_type;
    const betValue = bet.bet_value;
    const position = bet.position ? bet.position : null;
    const amount = parseFloat(bet.amount);
    
    // å¢åŠ ç¸½é‡‘é¡
    betStats.totalAmount += amount;
    
    // æ ¹æ“šæ³¨å–®é¡å‹é€²è¡Œåˆ†é¡çµ±è¨ˆ
    if (betType === 'number') {
      // è™Ÿç¢¼ç©æ³•éœ€è¦è€ƒæ…®ä½ç½®
      const key = `${position}_${betValue}`;
      if (!betStats.number[key]) betStats.number[key] = 0;
      betStats.number[key] += amount;
    } else {
      // å…¶ä»–é¡å‹ç›´æ¥æŒ‰å€¼çµ±è¨ˆ
      if (!betStats[betType][betValue]) betStats[betType][betValue] = 0;
      betStats[betType][betValue] += amount;
    }
  });
  
  return betStats;
}

// æ‰¾å‡ºå¤§é¡ä¸‹æ³¨çµ„åˆ
function findHighBetCombinations(betStats) {
  const highBets = [];
  const threshold = CONTROL_PARAMS.thresholdAmount;
  
  // æª¢æŸ¥è™Ÿç¢¼ç©æ³•
  for (const [key, amount] of Object.entries(betStats.number)) {
    if (amount >= threshold) {
      const [position, value] = key.split('_');
      highBets.push({
        type: 'number',
        position: parseInt(position),
        value: parseInt(value),
        amount: amount
      });
    }
  }
  
  // æª¢æŸ¥å† äºå’Œå€¼
  for (const [value, amount] of Object.entries(betStats.sumValue)) {
    if (amount >= threshold) {
      highBets.push({
        type: 'sumValue',
        value: value,
        amount: amount
      });
    }
  }
  
  // æª¢æŸ¥å† è»
  for (const [value, amount] of Object.entries(betStats.champion)) {
    if (amount >= threshold) {
      highBets.push({
        type: 'champion',
        value: value,
        amount: amount
      });
    }
  }
  
  // æª¢æŸ¥äºè»
  for (const [value, amount] of Object.entries(betStats.runnerup)) {
    if (amount >= threshold) {
      highBets.push({
        type: 'runnerup',
        value: value,
        amount: amount
      });
    }
  }
  
  // æª¢æŸ¥é¾è™
  for (const [value, amount] of Object.entries(betStats.dragonTiger)) {
    if (amount >= threshold) {
      highBets.push({
        type: 'dragonTiger',
        value: value,
        amount: amount
      });
    }
  }
  
  return highBets;
}

// è¨ˆç®—é–‹ççµæœçš„æ¬Šé‡
function calculateResultWeights(highBets, betStats) {
  // åˆå§‹åŒ–æ¬Šé‡ï¼Œæ‰€æœ‰ä½ç½®å’Œè™Ÿç¢¼çš„èµ·å§‹æ¬Šé‡ç‚º1
  const weights = {
    positions: Array.from({ length: 10 }, () => Array(10).fill(1)),
    sumValue: Array(17).fill(1) // å† äºå’Œå€¼3-19çš„æ¬Šé‡ï¼ˆ3åˆ°19å…±17å€‹å€¼ï¼‰
  };
  
  // æ ¹æ“šå¤§é¡ä¸‹æ³¨èª¿æ•´æ¬Šé‡
  highBets.forEach(bet => {
    const adjustmentFactor = CONTROL_PARAMS.adjustmentFactor;
    const randomnessFactor = CONTROL_PARAMS.randomnessFactor;
    
    if (bet.type === 'number') {
      // æ¸›å°‘è©²ä½ç½®è©²è™Ÿç¢¼çš„æ¬Šé‡ï¼Œä½¿å…¶ä¸å¤ªå¯èƒ½ä¸­ç
      const position = bet.position - 1; // è½‰æ›ç‚º0-basedç´¢å¼•
      const value = bet.value - 1;
      weights.positions[position][value] *= randomnessFactor;
    } 
    else if (bet.type === 'champion') {
      // å¤§å°å–®é›™è™•ç†
      if (bet.value === 'big') {
        // æ¸›å°‘å† è»ç‚ºå¤§(6-10)çš„æ¬Šé‡
        for (let i = 5; i < 10; i++) {
          weights.positions[0][i] *= randomnessFactor;
        }
      } else if (bet.value === 'small') {
        // æ¸›å°‘å† è»ç‚ºå°(1-5)çš„æ¬Šé‡
        for (let i = 0; i < 5; i++) {
          weights.positions[0][i] *= randomnessFactor;
        }
      } else if (bet.value === 'odd') {
        // æ¸›å°‘å† è»ç‚ºå–®æ•¸çš„æ¬Šé‡
        for (let i = 0; i < 10; i += 2) {
          weights.positions[0][i] *= randomnessFactor;
        }
      } else if (bet.value === 'even') {
        // æ¸›å°‘å† è»ç‚ºé›™æ•¸çš„æ¬Šé‡
        for (let i = 1; i < 10; i += 2) {
          weights.positions[0][i] *= randomnessFactor;
        }
      }
    }
    else if (bet.type === 'runnerup') {
      // èˆ‡å† è»é¡ä¼¼çš„è™•ç†ï¼Œä½†æ˜¯å°äºè»
      if (bet.value === 'big') {
        for (let i = 5; i < 10; i++) {
          weights.positions[1][i] *= randomnessFactor;
        }
      } else if (bet.value === 'small') {
        for (let i = 0; i < 5; i++) {
          weights.positions[1][i] *= randomnessFactor;
        }
      } else if (bet.value === 'odd') {
        for (let i = 0; i < 10; i += 2) {
          weights.positions[1][i] *= randomnessFactor;
        }
      } else if (bet.value === 'even') {
        for (let i = 1; i < 10; i += 2) {
          weights.positions[1][i] *= randomnessFactor;
        }
      }
    }
    else if (bet.type === 'sumValue') {
      // æ¸›å°‘è©²å’Œå€¼çš„çµ„åˆæ¬Šé‡
      if (bet.value === 'big') {
        // æ¸›å°‘å¤§å€¼(12-19)çš„æ¬Šé‡
        for (let i = 12 - 3; i <= 19 - 3; i++) {
          if (i < weights.sumValue.length) {
            weights.sumValue[i] *= randomnessFactor;
          }
        }
      } else if (bet.value === 'small') {
        // æ¸›å°‘å°å€¼(3-11)çš„æ¬Šé‡
        for (let i = 0; i <= 11 - 3; i++) {
          if (i < weights.sumValue.length) {
            weights.sumValue[i] *= randomnessFactor;
          }
        }
      } else if (bet.value === 'odd') {
        // æ¸›å°‘å–®æ•¸å’Œå€¼çš„æ¬Šé‡
        for (let i = 0; i < weights.sumValue.length; i++) {
          if ((i + 3) % 2 === 1) weights.sumValue[i] *= randomnessFactor;
        }
      } else if (bet.value === 'even') {
        // æ¸›å°‘é›™æ•¸å’Œå€¼çš„æ¬Šé‡
        for (let i = 0; i < weights.sumValue.length; i++) {
          if ((i + 3) % 2 === 0) weights.sumValue[i] *= randomnessFactor;
        }
      } else {
        // å…·é«”å’Œå€¼
        const sumIndex = parseInt(bet.value) - 3;
        if (sumIndex >= 0 && sumIndex < weights.sumValue.length) {
          weights.sumValue[sumIndex] *= randomnessFactor;
        }
      }
    }
    else if (bet.type === 'dragonTiger') {
      // é¾è™è™•ç†
      if (bet.value === 'dragon') {
        // æ¸›å°‘é¾(å† è»>äºè»)çš„å¯èƒ½æ€§
        // ç­–ç•¥ï¼šå¢åŠ å† è»å°å€¼å’Œäºè»å¤§å€¼çš„æ¬Šé‡
        for (let i = 0; i < 5; i++) {
          weights.positions[0][i] *= randomnessFactor;
          weights.positions[1][i+5] *= (2 - randomnessFactor);
        }
      } else if (bet.value === 'tiger') {
        // æ¸›å°‘è™(å† è»<äºè»)çš„å¯èƒ½æ€§
        // ç­–ç•¥ï¼šå¢åŠ å† è»å¤§å€¼å’Œäºè»å°å€¼çš„æ¬Šé‡
        for (let i = 5; i < 10; i++) {
          weights.positions[0][i] *= (2 - randomnessFactor);
          weights.positions[1][i-5] *= randomnessFactor;
        }
      }
    }
  });
  
  return weights;
}

// åŸºæ–¼æ¬Šé‡ç”Ÿæˆçµæœ
function generateWeightedResult(weights, attempts = 0) {
  const MAX_ATTEMPTS = 50; // å¢åŠ æœ€å¤§å˜—è©¦æ¬¡æ•¸ä»¥ç¢ºä¿100%æ§åˆ¶æ•ˆæœ
  const numbers = Array.from({length: 10}, (_, i) => i + 1);
  const result = [];
  let availableNumbers = [...numbers];
  
  console.log(`ğŸ² ç”Ÿæˆæ¬Šé‡çµæœ (ç¬¬${attempts + 1}æ¬¡å˜—è©¦)`);
  
  // ğŸ”¥ ä¿®å¾©ï¼šæª¢æŸ¥çœŸæ­£çš„100%ä½ç½®æ§åˆ¶ï¼ŒåŒ…æ‹¬è´æ§åˆ¶å’Œè¼¸æ§åˆ¶
  // æª¢æŸ¥æ˜¯å¦æœ‰çœŸæ­£ç¨ç«‹çš„100%ä½ç½®æ§åˆ¶ï¼ˆæ¬Šé‡è¶…é«˜æˆ–è¶…ä½ä¸”ä¸æ˜¯ç¯„åœæ¬Šé‡ï¼‰
  const extremePositionControls = [];
  for (let position = 0; position < 10; position++) {
    let extremeHighCount = 0;
    let extremeLowCount = 0;
    let extremeHighNumbers = [];
    let extremeLowNumbers = [];
    
    // è¨ˆç®—è©²ä½ç½®çš„æ¥µé«˜æ¬Šé‡å’Œæ¥µä½æ¬Šé‡è™Ÿç¢¼
    for (let num = 0; num < 10; num++) {
      const weight = weights.positions[position][num];
      if (weight > 100) {
        extremeHighCount++;
        extremeHighNumbers.push(num + 1);
      } else if (weight < 0.01) {
        extremeLowCount++;
        extremeLowNumbers.push(num + 1);
      }
    }
    
    // æª¢æŸ¥è´æ§åˆ¶ï¼šåªæœ‰1-2å€‹æ¥µé«˜æ¬Šé‡è™Ÿç¢¼æ™‚ï¼Œèªç‚ºæ˜¯çœŸæ­£çš„ä½ç½®æ§åˆ¶
    if (extremeHighCount > 0 && extremeHighCount <= 2) {
      for (const num of extremeHighNumbers) {
        const weight = weights.positions[position][num - 1];
        extremePositionControls.push({
          position: position,
          number: num,
          weight: weight,
          type: 'win'
        });
      }
      console.log(`ğŸ¯ ä½ç½®${position + 1}æª¢æ¸¬åˆ°${extremeHighCount}å€‹100%è´æ§åˆ¶è™Ÿç¢¼[${extremeHighNumbers.join(',')}]`);
    }
    
    // æª¢æŸ¥è¼¸æ§åˆ¶ï¼šå¦‚æœæœ‰å¤šå€‹æ¥µä½æ¬Šé‡è™Ÿç¢¼ï¼Œèªç‚ºæ˜¯100%è¼¸æ§åˆ¶
    if (extremeLowCount >= 3) {
      // 100%è¼¸æ§åˆ¶ï¼šè®“æœƒå“¡è¼¸éŒ¢ï¼Œé¸æ“‡æ­£å¸¸æ¬Šé‡è™Ÿç¢¼ï¼ˆç”¨æˆ¶æœªä¸‹æ³¨çš„è™Ÿç¢¼ï¼‰
      const normalWeightNumbers = [];
      for (let num = 0; num < 10; num++) {
        const weight = weights.positions[position][num];
        if (weight >= 1) { // æ­£å¸¸æ¬Šé‡ï¼ˆç”¨æˆ¶æœªä¸‹æ³¨çš„è™Ÿç¢¼ï¼‰
          normalWeightNumbers.push(num + 1);
        }
      }
      
      if (normalWeightNumbers.length > 0) {
        const randomNormalNumber = normalWeightNumbers[Math.floor(Math.random() * normalWeightNumbers.length)];
        extremePositionControls.push({
          position: position,
          number: randomNormalNumber,
          weight: 1,
          type: 'loss'
        });
        console.log(`ğŸ’° ä½ç½®${position + 1}æª¢æ¸¬åˆ°100%è¼¸æ§åˆ¶[ç”¨æˆ¶ä¸‹æ³¨:${extremeLowNumbers.join(',')}]ï¼Œé¸æ“‡æœªä¸‹æ³¨è™Ÿç¢¼${randomNormalNumber}è®“æœƒå“¡è¼¸éŒ¢`);
      } else {
        console.log(`âš ï¸ ä½ç½®${position + 1}è¼¸æ§åˆ¶ï¼šç„¡æ­£å¸¸æ¬Šé‡è™Ÿç¢¼å¯é¸ï¼Œè·³éé å…ˆåˆ†é…`);
      }
    }
    
    // é¾è™æ§åˆ¶æª¢æ¸¬
    if (extremeHighCount > 2 || extremeLowCount > 2) {
      if (extremeHighCount === 5 && extremeLowCount === 5) {
        console.log(`ğŸ‰ğŸ… ä½ç½®${position + 1}æª¢æ¸¬åˆ°é¾è™æ§åˆ¶æ¬Šé‡è¨­ç½®ï¼Œä¸é€²è¡Œé å…ˆåˆ†é…`);
      } else if (extremeHighCount > 2) {
        console.log(`ğŸ‰ğŸ… ä½ç½®${position + 1}æª¢æ¸¬åˆ°${extremeHighCount}å€‹æ¥µé«˜æ¬Šé‡è™Ÿç¢¼[${extremeHighNumbers.join(',')}]ï¼Œåˆ¤æ–·ç‚ºç¯„åœæ§åˆ¶ï¼Œä¸é€²è¡Œé å…ˆåˆ†é…`);
      }
    }
  }
  
  // å¦‚æœæœ‰çœŸæ­£çš„100%ä½ç½®æ§åˆ¶ï¼ŒæŒ‰æ¬Šé‡æ’åºä¸¦å„ªå…ˆè™•ç†
  if (extremePositionControls.length > 0) {
    extremePositionControls.sort((a, b) => b.weight - a.weight);
    console.log(`ğŸ¯ æª¢æ¸¬åˆ°${extremePositionControls.length}å€‹çœŸæ­£çš„100%ä½ç½®æ§åˆ¶:`, extremePositionControls.map(c => `ä½ç½®${c.position+1}è™Ÿç¢¼${c.number}(æ¬Šé‡:${c.weight})`).join(', '));
    
    // é å…ˆåˆ†é…100%æ§åˆ¶çš„ä½ç½®
    const reservedNumbers = new Set();
    const positionAssignments = Array(10).fill(null);
    
    for (const control of extremePositionControls) {
      if (!reservedNumbers.has(control.number)) {
        positionAssignments[control.position] = control.number;
        reservedNumbers.add(control.number);
        console.log(`ğŸ”’ é å…ˆåˆ†é…ä½ç½®${control.position + 1}è™Ÿç¢¼${control.number}`);
      } else {
        console.log(`âš ï¸ è™Ÿç¢¼${control.number}å·²è¢«å…¶ä»–ä½ç½®é å…ˆåˆ†é…ï¼Œä½ç½®${control.position + 1}å°‡ä½¿ç”¨éš¨æ©Ÿé¸æ“‡`);
      }
    }
    
    // æ›´æ–°å¯ç”¨è™Ÿç¢¼åˆ—è¡¨
    availableNumbers = numbers.filter(num => !reservedNumbers.has(num));
    
    // æŒ‰ä½ç½®é †åºç”Ÿæˆçµæœ
    for (let position = 0; position < 10; position++) {
      if (positionAssignments[position] !== null) {
        // ä½¿ç”¨é å…ˆåˆ†é…çš„è™Ÿç¢¼
        const assignedNumber = positionAssignments[position];
        result.push(assignedNumber);
        console.log(`ğŸ¯ ä½ç½®${position + 1}ä½¿ç”¨é å…ˆåˆ†é…è™Ÿç¢¼${assignedNumber}`);
      } else {
        // å¾å‰©é¤˜è™Ÿç¢¼ä¸­é¸æ“‡
        if (availableNumbers.length > 0) {
          let numberWeights = [];
          for (let i = 0; i < availableNumbers.length; i++) {
            const num = availableNumbers[i];
            numberWeights.push(weights.positions[position][num-1] || 1);
          }
          
          const selectedIndex = weightedRandomIndex(numberWeights);
          const selectedNumber = availableNumbers[selectedIndex];
          console.log(`ğŸ² ä½ç½®${position + 1}æ¬Šé‡é¸æ“‡è™Ÿç¢¼${selectedNumber} (æ¬Šé‡:${numberWeights[selectedIndex]})`);
          result.push(selectedNumber);
          availableNumbers.splice(selectedIndex, 1);
        } else {
          console.error(`âŒ ä½ç½®${position + 1}æ²’æœ‰å¯ç”¨è™Ÿç¢¼ï¼`);
          // ç·Šæ€¥æƒ…æ³ï¼šä½¿ç”¨ä»»æ„è™Ÿç¢¼
          result.push(1);
        }
      }
    }
    
    console.log(`ğŸ é å…ˆåˆ†é…çµæœ: [${result.join(', ')}]`);
    return result;
  }
  
  // åŸæœ‰é‚è¼¯ï¼šæ­¥é©Ÿ1ï¼šç”Ÿæˆå‰å…©å(å† è»å’Œäºè»)ï¼Œç”¨æ–¼æª¢æŸ¥å† äºå’Œæ§åˆ¶
  for (let position = 0; position < 2; position++) {
    // æ ¹æ“šæ¬Šé‡é¸æ“‡ä½ç½®ä¸Šçš„è™Ÿç¢¼
    let numberWeights = [];
    for (let i = 0; i < availableNumbers.length; i++) {
      const num = availableNumbers[i];
      numberWeights.push(weights.positions[position][num-1] || 1);
    }
    
    // æª¢æŸ¥æ˜¯å¦æœ‰æ¥µé«˜æ¬Šé‡çš„è™Ÿç¢¼ï¼ˆ100%æ§åˆ¶çš„æƒ…æ³ï¼‰
    const maxWeight = Math.max(...numberWeights);
    const hasExtremeWeight = maxWeight > 100; // æ¥µé«˜æ¬Šé‡é–¾å€¼
    
    if (hasExtremeWeight) {
      // 100%æ§åˆ¶æƒ…æ³ï¼Œç›´æ¥é¸æ“‡æœ€é«˜æ¬Šé‡çš„è™Ÿç¢¼
      const maxIndex = numberWeights.indexOf(maxWeight);
      const selectedNumber = availableNumbers[maxIndex];
      console.log(`ğŸ¯ ä½ç½®${position + 1}å¼·åˆ¶é¸æ“‡è™Ÿç¢¼${selectedNumber} (æ¬Šé‡:${maxWeight})`);
      result.push(selectedNumber);
      availableNumbers.splice(maxIndex, 1);
    } else {
      // ä½¿ç”¨æ¬Šé‡é€²è¡Œé¸æ“‡
      const selectedIndex = weightedRandomIndex(numberWeights);
      const selectedNumber = availableNumbers[selectedIndex];
      console.log(`ğŸ² ä½ç½®${position + 1}æ¬Šé‡é¸æ“‡è™Ÿç¢¼${selectedNumber} (æ¬Šé‡:${numberWeights[selectedIndex]})`);
      result.push(selectedNumber);
      availableNumbers.splice(selectedIndex, 1);
    }
  }
  
  // æª¢æŸ¥æ˜¯å¦ç¬¦åˆç›®æ¨™å’Œå€¼æ¬Šé‡
  const sumValue = result[0] + result[1];
  const sumValueIndex = sumValue - 3;
  const sumWeight = weights.sumValue[sumValueIndex] || 1;
  
  console.log(`ğŸ“Š ç•¶å‰å† äºè»: ${result[0]}, ${result[1]}, å’Œå€¼: ${sumValue}, å’Œå€¼æ¬Šé‡: ${sumWeight}`);
  
  // æª¢æŸ¥å’Œå€¼æ§åˆ¶é‚è¼¯
  const hasHighSumWeight = sumWeight > 100; // æ¥µé«˜å’Œå€¼æ¬Šé‡
  const hasLowSumWeight = sumWeight < 0.1; // æ¥µä½å’Œå€¼æ¬Šé‡
  
  // ğŸ¯ æ–°å¢æ™ºèƒ½å’Œå€¼æ§åˆ¶é‚è¼¯
  if (hasLowSumWeight && attempts < MAX_ATTEMPTS) {
    // 100%è¼¸æ§åˆ¶çš„å’Œå€¼ï¼Œå¿…é ˆé‡æ–°ç”Ÿæˆ
    console.log(`âŒ æª¢æ¸¬åˆ°100%è¼¸æ§åˆ¶å’Œå€¼${sumValue}ï¼Œé‡æ–°ç”Ÿæˆ (ç¬¬${attempts + 1}æ¬¡å˜—è©¦)`);
    return generateWeightedResult(weights, attempts + 1);
  } else if (hasHighSumWeight) {
    // 100%è´æ§åˆ¶çš„å’Œå€¼ï¼Œæ¥å—çµæœ
    console.log(`âœ… æª¢æ¸¬åˆ°100%è´æ§åˆ¶å’Œå€¼${sumValue}ï¼Œæ¥å—çµæœ`);
  } else {
    // æª¢æŸ¥æ˜¯å¦æœ‰å…¶ä»–é«˜æ¬Šé‡å’Œå€¼ï¼Œå¦‚æœæœ‰ï¼Œå„ªå…ˆç”Ÿæˆé‚£äº›å’Œå€¼
    const maxSumWeight = Math.max(...weights.sumValue);
    if (maxSumWeight > 100 && attempts < MAX_ATTEMPTS) {
      // æ‰¾åˆ°æ‰€æœ‰é«˜æ¬Šé‡å’Œå€¼
      const highWeightSums = [];
      for (let i = 0; i < weights.sumValue.length; i++) {
        if (weights.sumValue[i] > 100) {
          highWeightSums.push(i + 3); // å¯¦éš›å’Œå€¼
        }
      }
      
      if (highWeightSums.length > 0 && !highWeightSums.includes(sumValue)) {
        const targetSum = highWeightSums[Math.floor(Math.random() * highWeightSums.length)];
        console.log(`ğŸ¯ æª¢æ¸¬åˆ°é«˜æ¬Šé‡å’Œå€¼${highWeightSums.join(',')}ï¼Œç•¶å‰${sumValue}ä¸ç¬¦åˆï¼Œé‡æ–°ç”Ÿæˆç›®æ¨™å’Œå€¼${targetSum} (ç¬¬${attempts + 1}æ¬¡å˜—è©¦)`);
        
        // æ™ºèƒ½ç”Ÿæˆç›®æ¨™å’Œå€¼
        return generateTargetSumResult(weights, targetSum, attempts + 1);
      }
    } else if (sumWeight < 0.5 && Math.random() < 0.7 && attempts < MAX_ATTEMPTS) {
      // ä¸€èˆ¬æ§åˆ¶æƒ…æ³
      console.log(`ğŸ”„ å’Œå€¼${sumValue}æ¬Šé‡è¼ƒä½ï¼Œå˜—è©¦é‡æ–°ç”Ÿæˆ (ç¬¬${attempts + 1}æ¬¡å˜—è©¦)`);
      return generateWeightedResult(weights, attempts + 1);
    }
  }

  // ğŸ‰ğŸ… ä¿®å¾©é¾è™æ§åˆ¶æª¢æŸ¥é‚è¼¯ - åœ¨çµæœå®Œå…¨ç”Ÿæˆå¾Œé€²è¡Œå®Œæ•´æª¢æŸ¥
  // æª¢æŸ¥æ˜¯å¦éœ€è¦é¾è™æ§åˆ¶
  let needsDragonTigerCheck = false;
  
  // å…ˆæª¢æŸ¥æ˜¯å¦æœ‰é¾è™æ§åˆ¶æ¬Šé‡è¨­ç½®
  for (let pos1 = 0; pos1 < 10; pos1++) {
    for (let pos2 = 0; pos2 < 10; pos2++) {
      if (pos1 !== pos2) {
        // æª¢æŸ¥æ˜¯å¦æœ‰é¾è™æ§åˆ¶çš„æ¥µç«¯æ¬Šé‡è¨­ç½®
        let pos1HasDragonTigerWeight = false;
        let pos2HasDragonTigerWeight = false;
        
        // æª¢æŸ¥pos1æ˜¯å¦æœ‰é¾è™æ§åˆ¶æ¬Šé‡ï¼ˆ5å€‹å¤§è™Ÿç¢¼æ¬Šé‡é«˜æˆ–5å€‹å°è™Ÿç¢¼æ¬Šé‡ä½ï¼‰
        let pos1HighCount = 0, pos1LowCount = 0;
        for (let num = 0; num < 10; num++) {
          const weight = weights.positions[pos1][num];
          if (weight > 100) pos1HighCount++;
          if (weight < 0.01) pos1LowCount++;
        }
        pos1HasDragonTigerWeight = (pos1HighCount === 5 && pos1LowCount === 5);
        
        // æª¢æŸ¥pos2æ˜¯å¦æœ‰é¾è™æ§åˆ¶æ¬Šé‡
        let pos2HighCount = 0, pos2LowCount = 0;
        for (let num = 0; num < 10; num++) {
          const weight = weights.positions[pos2][num];
          if (weight > 100) pos2HighCount++;
          if (weight < 0.01) pos2LowCount++;
        }
        pos2HasDragonTigerWeight = (pos2HighCount === 5 && pos2LowCount === 5);
        
        if (pos1HasDragonTigerWeight && pos2HasDragonTigerWeight) {
          needsDragonTigerCheck = true;
          console.log(`ğŸ‰ğŸ… æª¢æ¸¬åˆ°ç¬¬${pos1+1}åvsç¬¬${pos2+1}åçš„é¾è™æ§åˆ¶æ¬Šé‡è¨­ç½®`);
          break;
        }
      }
    }
    if (needsDragonTigerCheck) break;
  }
  
  // å¦‚æœé”åˆ°æœ€å¤§å˜—è©¦æ¬¡æ•¸ï¼Œè¨˜éŒ„è­¦å‘Šä½†æ¥å—ç•¶å‰çµæœ
  if (attempts >= MAX_ATTEMPTS) {
    console.warn(`âš ï¸ é”åˆ°æœ€å¤§å˜—è©¦æ¬¡æ•¸(${MAX_ATTEMPTS})ï¼Œä½¿ç”¨ç•¶å‰çµæœ - å’Œå€¼: ${sumValue}`);
  }
  
  // æ­¥é©Ÿ2ï¼šç”Ÿæˆå‰©é¤˜ä½ç½®(ç¬¬3-10å)ï¼Œæ¯å€‹ä½ç½®éƒ½ä½¿ç”¨æ¬Šé‡æ§åˆ¶
  for (let position = 2; position < 10; position++) {
    let attempts = 0;
    const MAX_POSITION_ATTEMPTS = 10; // æ¯å€‹ä½ç½®æœ€å¤šå˜—è©¦10æ¬¡
    let selectedNumber = null;
    
    while (attempts < MAX_POSITION_ATTEMPTS && selectedNumber === null) {
      // æ ¹æ“šæ¬Šé‡é¸æ“‡ä½ç½®ä¸Šçš„è™Ÿç¢¼
      let numberWeights = [];
      for (let i = 0; i < availableNumbers.length; i++) {
        const num = availableNumbers[i];
        numberWeights.push(weights.positions[position][num-1] || 1);
      }
      
      // æª¢æŸ¥æ˜¯å¦æœ‰æ¥µé«˜æ¬Šé‡çš„è™Ÿç¢¼ï¼ˆ100%æ§åˆ¶çš„æƒ…æ³ï¼‰
      const maxWeight = Math.max(...numberWeights);
      const minWeight = Math.min(...numberWeights);
      const hasExtremeWeight = maxWeight > 100; // æ¥µé«˜æ¬Šé‡é–¾å€¼
      const hasExtremelyLowWeight = minWeight < 0.01; // æ¥µä½æ¬Šé‡é–¾å€¼ï¼ˆ100%è¼¸æ§åˆ¶ï¼‰
      
      if (hasExtremeWeight) {
        // 100%è´æ§åˆ¶æƒ…æ³ï¼Œç›´æ¥é¸æ“‡æœ€é«˜æ¬Šé‡çš„è™Ÿç¢¼
        const maxIndex = numberWeights.indexOf(maxWeight);
        selectedNumber = availableNumbers[maxIndex];
        console.log(`ğŸ¯ ä½ç½®${position + 1}å¼·åˆ¶é¸æ“‡è™Ÿç¢¼${selectedNumber} (æ¬Šé‡:${maxWeight})`);
      } else if (hasExtremelyLowWeight) {
        // ğŸ”¥ ä¿®å¾©ï¼š100%è¼¸æ§åˆ¶æƒ…æ³ï¼Œæ‡‰è©²é¸æ“‡æ¥µä½æ¬Šé‡çš„è™Ÿç¢¼
        const lowWeightIndices = [];
        const normalWeightIndices = [];
        
        for (let i = 0; i < numberWeights.length; i++) {
          if (numberWeights[i] < 0.01) { // æ¥µä½æ¬Šé‡è™Ÿç¢¼ï¼ˆè¢«æ§åˆ¶çš„è™Ÿç¢¼ï¼‰
            lowWeightIndices.push(i);
          } else {
            normalWeightIndices.push(i);
          }
        }
        
        if (lowWeightIndices.length > 0) {
          // å„ªå…ˆå¾æ¥µä½æ¬Šé‡è™Ÿç¢¼ä¸­é¸æ“‡ï¼Œå¯¦ç¾100%è¼¸æ§åˆ¶
          const randomLowIndex = lowWeightIndices[Math.floor(Math.random() * lowWeightIndices.length)];
          selectedNumber = availableNumbers[randomLowIndex];
          console.log(`âŒ ä½ç½®${position + 1}è¼¸æ§åˆ¶ï¼šé¸æ“‡ä½æ¬Šé‡è™Ÿç¢¼${selectedNumber} (æ¬Šé‡:${numberWeights[randomLowIndex]})`);
        } else if (normalWeightIndices.length > 0) {
          // å¦‚æœæ²’æœ‰æ¥µä½æ¬Šé‡è™Ÿç¢¼ï¼Œå¾æ­£å¸¸æ¬Šé‡ä¸­é¸æ“‡
          const randomNormalIndex = normalWeightIndices[Math.floor(Math.random() * normalWeightIndices.length)];
          selectedNumber = availableNumbers[randomNormalIndex];
          console.log(`âš ï¸ ä½ç½®${position + 1}è¼¸æ§åˆ¶ï¼šç„¡ä½æ¬Šé‡è™Ÿç¢¼ï¼Œé¸æ“‡æ­£å¸¸æ¬Šé‡${selectedNumber} (æ¬Šé‡:${numberWeights[randomNormalIndex]})`);
        } else {
          // æ‰€æœ‰è™Ÿç¢¼æ¬Šé‡éƒ½å¾ˆä½ï¼Œéš¨æ©Ÿé¸æ“‡ä¸€å€‹
          const randomIndex = Math.floor(Math.random() * availableNumbers.length);
          selectedNumber = availableNumbers[randomIndex];
          console.log(`âš ï¸ ä½ç½®${position + 1}è¼¸æ§åˆ¶ï¼šæ‰€æœ‰æ¬Šé‡éƒ½å¾ˆä½ï¼Œéš¨æ©Ÿé¸æ“‡${selectedNumber} (æ¬Šé‡:${numberWeights[randomIndex]})`);
        }
      } else {
        // ä½¿ç”¨æ¬Šé‡é€²è¡Œé¸æ“‡
        const selectedIndex = weightedRandomIndex(numberWeights);
        const candidateNumber = availableNumbers[selectedIndex];
        const candidateWeight = numberWeights[selectedIndex];
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦é‡æ–°é¸æ“‡ï¼ˆé‡å°ä¸­ç­‰æ¬Šé‡çš„æ§åˆ¶ï¼‰
        if (candidateWeight < 0.5 && Math.random() < 0.7 && attempts < MAX_POSITION_ATTEMPTS - 1) {
          console.log(`ğŸ”„ ä½ç½®${position + 1}è™Ÿç¢¼${candidateNumber}æ¬Šé‡è¼ƒä½(${candidateWeight})ï¼Œé‡æ–°é¸æ“‡ (ç¬¬${attempts + 1}æ¬¡å˜—è©¦)`);
          attempts++;
          continue;
        }
        
        selectedNumber = candidateNumber;
        console.log(`ğŸ² ä½ç½®${position + 1}æ¬Šé‡é¸æ“‡è™Ÿç¢¼${selectedNumber} (æ¬Šé‡:${candidateWeight})`);
      }
      
      attempts++;
    }
    
    // å¦‚æœç¶“éå¤šæ¬¡å˜—è©¦é‚„æ˜¯æ²’æœ‰é¸åˆ°åˆé©çš„è™Ÿç¢¼ï¼Œä½¿ç”¨æœ€å¾Œé¸æ“‡çš„è™Ÿç¢¼
    if (selectedNumber === null && availableNumbers.length > 0) {
      selectedNumber = availableNumbers[0]; // ä½¿ç”¨ç¬¬ä¸€å€‹å¯ç”¨è™Ÿç¢¼
      console.warn(`âš ï¸ ä½ç½®${position + 1}ç¶“é${MAX_POSITION_ATTEMPTS}æ¬¡å˜—è©¦ï¼Œä½¿ç”¨é»˜èªè™Ÿç¢¼${selectedNumber}`);
    }
    
    // å°‡é¸ä¸­çš„è™Ÿç¢¼åŠ å…¥çµæœä¸¦å¾å¯ç”¨è™Ÿç¢¼ä¸­ç§»é™¤
    if (selectedNumber !== null) {
      result.push(selectedNumber);
      const removeIndex = availableNumbers.indexOf(selectedNumber);
      if (removeIndex > -1) {
        availableNumbers.splice(removeIndex, 1);
      }
    }
  }
  
  // ğŸ‰ğŸ… åœ¨å®Œæ•´çµæœç”Ÿæˆå¾Œé€²è¡Œé¾è™æ§åˆ¶æª¢æŸ¥
  if (needsDragonTigerCheck) {
    console.log(`ğŸ‰ğŸ… é–‹å§‹æª¢æŸ¥é¾è™æ§åˆ¶çµæœ: [${result.join(', ')}]`);
    
    // æª¢æŸ¥æ‰€æœ‰ä½ç½®çš„é¾è™æ§åˆ¶
    for (let pos1 = 0; pos1 < 10; pos1++) {
      for (let pos2 = 0; pos2 < 10; pos2++) {
        if (pos1 !== pos2 && result[pos1] && result[pos2]) {
          // æª¢æŸ¥è©²ä½ç½®å°æ˜¯å¦æœ‰é¾è™æ§åˆ¶æ¬Šé‡
          let pos1HighCount = 0, pos1LowCount = 0;
          let pos2HighCount = 0, pos2LowCount = 0;
          
          for (let num = 0; num < 10; num++) {
            const weight1 = weights.positions[pos1][num];
            const weight2 = weights.positions[pos2][num];
            if (weight1 > 100) pos1HighCount++;
            if (weight1 < 0.01) pos1LowCount++;
            if (weight2 > 100) pos2HighCount++;
            if (weight2 < 0.01) pos2LowCount++;
          }
          
          const pos1HasDragonTigerWeight = (pos1HighCount === 5 && pos1LowCount === 5);
          const pos2HasDragonTigerWeight = (pos2HighCount === 5 && pos2LowCount === 5);
          
          if (pos1HasDragonTigerWeight && pos2HasDragonTigerWeight) {
            const pos1Value = result[pos1];
            const pos2Value = result[pos2];
            const pos1Weight = weights.positions[pos1][pos1Value - 1] || 1;
            const pos2Weight = weights.positions[pos2][pos2Value - 1] || 1;
            
            // åˆ¤æ–·æœŸæœ›çš„é¾è™çµæœ
            let shouldDragonWin = false;
            if (pos1Weight > 100 && pos2Weight < 0.01) {
              shouldDragonWin = true; // pos1æ‡‰è©²å¤§æ–¼pos2ï¼ˆé¾å‹ï¼‰
            } else if (pos1Weight < 0.01 && pos2Weight > 100) {
              shouldDragonWin = false; // pos1æ‡‰è©²å°æ–¼pos2ï¼ˆè™å‹ï¼‰
            } else {
              continue; // æ²’æœ‰æ˜ç¢ºçš„é¾è™æ§åˆ¶è¦æ±‚
            }
            
            const actualDragonWins = pos1Value > pos2Value;
            
            if (shouldDragonWin !== actualDragonWins && attempts < MAX_ATTEMPTS) {
              console.log(`ğŸ‰ğŸ… é¾è™æ§åˆ¶å¤±æ•ˆ: ç¬¬${pos1+1}å(${pos1Value})vsç¬¬${pos2+1}å(${pos2Value})ï¼ŒæœŸæœ›é¾${shouldDragonWin ? 'è´' : 'è¼¸'}ï¼Œå¯¦éš›é¾${actualDragonWins ? 'è´' : 'è¼¸'}ï¼Œé‡æ–°ç”Ÿæˆ (ç¬¬${attempts + 1}æ¬¡å˜—è©¦)`);
              return generateWeightedResult(weights, attempts + 1);
            } else if (shouldDragonWin === actualDragonWins) {
              console.log(`âœ… é¾è™æ§åˆ¶ç”Ÿæ•ˆ: ç¬¬${pos1+1}å(${pos1Value})vsç¬¬${pos2+1}å(${pos2Value})ï¼Œé¾${actualDragonWins ? 'è´' : 'è¼¸'}ï¼Œç¬¦åˆé æœŸ`);
            }
          }
        }
      }
    }
  }

  console.log(`ğŸ æœ€çµ‚é–‹ççµæœ: [${result.join(', ')}]`);
  return result;
}

// æ ¹æ“šæ¬Šé‡éš¨æ©Ÿé¸æ“‡ç´¢å¼•
function weightedRandomIndex(weights) {
  const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
  
  // å¦‚æœç¸½æ¬Šé‡ç‚º0ï¼Œç›´æ¥è¿”å›0
  if (totalWeight === 0) {
    console.warn('æ¬Šé‡ç¸½å’Œç‚º0ï¼Œè¿”å›ç´¢å¼•0');
    return 0;
  }
  
  let random = Math.random() * totalWeight;
  
  for (let i = 0; i < weights.length; i++) {
    random -= weights[i];
    if (random <= 0) {
      return i;
    }
  }
  
  return weights.length - 1; // é˜²æ­¢æµ®é»èª¤å·®
}

// æ™ºèƒ½ç”Ÿæˆç›®æ¨™å’Œå€¼çš„é–‹ççµæœ
function generateTargetSumResult(weights, targetSum, attempts = 0) {
  const MAX_ATTEMPTS = 50;
  const numbers = Array.from({length: 10}, (_, i) => i + 1);
  const result = [];
  let availableNumbers = [...numbers];
  
  console.log(`ğŸ¯ æ™ºèƒ½ç”Ÿæˆç›®æ¨™å’Œå€¼${targetSum} (ç¬¬${attempts}æ¬¡å˜—è©¦)`);
  
  // æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„å† è»+äºè»çµ„åˆ
  const possiblePairs = [];
  for (let i = 1; i <= 10; i++) {
    for (let j = 1; j <= 10; j++) {
      if (i !== j && i + j === targetSum) {
        possiblePairs.push([i, j]);
      }
    }
  }
  
  if (possiblePairs.length === 0) {
    console.warn(`âš ï¸ ç„¡æ³•ç”Ÿæˆå’Œå€¼${targetSum}çš„æœ‰æ•ˆçµ„åˆï¼Œä½¿ç”¨æ™®é€šç”Ÿæˆ`);
    return generateWeightedResult(weights, attempts);
  }
  
  // æ ¹æ“šä½ç½®æ¬Šé‡é¸æ“‡æœ€å„ªçµ„åˆ
  let bestPair = possiblePairs[0];
  let bestWeight = 0;
  
  for (const [champion, runnerup] of possiblePairs) {
    const championWeight = weights.positions[0][champion - 1] || 1;
    const runnerupWeight = weights.positions[1][runnerup - 1] || 1;
    const combinedWeight = championWeight * runnerupWeight;
    
    if (combinedWeight > bestWeight) {
      bestWeight = combinedWeight;
      bestPair = [champion, runnerup];
    }
  }
  
  const [selectedChampion, selectedRunnerup] = bestPair;
  console.log(`ğŸ† é¸æ“‡å† è»${selectedChampion}ï¼Œäºè»${selectedRunnerup}ï¼Œå’Œå€¼=${selectedChampion + selectedRunnerup}`);
  
  result.push(selectedChampion);
  result.push(selectedRunnerup);
  
  // å¾å¯ç”¨è™Ÿç¢¼ä¸­ç§»é™¤å·²é¸æ“‡çš„
  availableNumbers = availableNumbers.filter(num => num !== selectedChampion && num !== selectedRunnerup);
  
  // ç”Ÿæˆå‰©é¤˜ä½ç½®(ç¬¬3-10å)ï¼ŒåŒæ¨£ä½¿ç”¨æ¬Šé‡æ§åˆ¶
  for (let position = 2; position < 10; position++) {
    let attempts = 0;
    const MAX_POSITION_ATTEMPTS = 10; // æ¯å€‹ä½ç½®æœ€å¤šå˜—è©¦10æ¬¡
    let selectedNumber = null;
    
    while (attempts < MAX_POSITION_ATTEMPTS && selectedNumber === null) {
      // æ ¹æ“šæ¬Šé‡é¸æ“‡ä½ç½®ä¸Šçš„è™Ÿç¢¼
      let numberWeights = [];
      for (let i = 0; i < availableNumbers.length; i++) {
        const num = availableNumbers[i];
        numberWeights.push(weights.positions[position][num-1] || 1);
      }
      
      // æª¢æŸ¥æ˜¯å¦æœ‰æ¥µé«˜æ¬Šé‡çš„è™Ÿç¢¼ï¼ˆ100%æ§åˆ¶çš„æƒ…æ³ï¼‰
      const maxWeight = Math.max(...numberWeights);
      const minWeight = Math.min(...numberWeights);
      const hasExtremeWeight = maxWeight > 100; // æ¥µé«˜æ¬Šé‡é–¾å€¼
      const hasExtremelyLowWeight = minWeight < 0.01; // æ¥µä½æ¬Šé‡é–¾å€¼ï¼ˆ100%è¼¸æ§åˆ¶ï¼‰
      
      if (hasExtremeWeight) {
        // 100%è´æ§åˆ¶æƒ…æ³ï¼Œç›´æ¥é¸æ“‡æœ€é«˜æ¬Šé‡çš„è™Ÿç¢¼
        const maxIndex = numberWeights.indexOf(maxWeight);
        selectedNumber = availableNumbers[maxIndex];
        console.log(`ğŸ¯ ç›®æ¨™å’Œå€¼-ä½ç½®${position + 1}å¼·åˆ¶é¸æ“‡è™Ÿç¢¼${selectedNumber} (æ¬Šé‡:${maxWeight})`);
      } else if (hasExtremelyLowWeight) {
        // 100%è¼¸æ§åˆ¶æƒ…æ³ï¼Œé¿å…é¸æ“‡æ¥µä½æ¬Šé‡çš„è™Ÿç¢¼
        const validIndices = [];
        for (let i = 0; i < numberWeights.length; i++) {
          if (numberWeights[i] >= 0.1) { // åªé¸æ“‡æ¬Šé‡ä¸å¤ªä½çš„è™Ÿç¢¼
            validIndices.push(i);
          }
        }
        
        if (validIndices.length > 0) {
          // å¾æœ‰æ•ˆè™Ÿç¢¼ä¸­éš¨æ©Ÿé¸æ“‡
          const randomValidIndex = validIndices[Math.floor(Math.random() * validIndices.length)];
          selectedNumber = availableNumbers[randomValidIndex];
          console.log(`ğŸš« ç›®æ¨™å’Œå€¼-ä½ç½®${position + 1}é¿é–‹ä½æ¬Šé‡è™Ÿç¢¼ï¼Œé¸æ“‡${selectedNumber} (æ¬Šé‡:${numberWeights[randomValidIndex]})`);
        } else {
          // å¦‚æœæ‰€æœ‰è™Ÿç¢¼æ¬Šé‡éƒ½å¾ˆä½ï¼Œå¼·åˆ¶é¸æ“‡æ¬Šé‡æœ€é«˜çš„
          const maxIndex = numberWeights.indexOf(maxWeight);
          selectedNumber = availableNumbers[maxIndex];
          console.log(`âš ï¸ ç›®æ¨™å’Œå€¼-ä½ç½®${position + 1}æ‰€æœ‰æ¬Šé‡éƒ½å¾ˆä½ï¼Œå¼·åˆ¶é¸æ“‡${selectedNumber} (æ¬Šé‡:${maxWeight})`);
        }
      } else {
        // ä½¿ç”¨æ¬Šé‡é€²è¡Œé¸æ“‡
        const selectedIndex = weightedRandomIndex(numberWeights);
        const candidateNumber = availableNumbers[selectedIndex];
        const candidateWeight = numberWeights[selectedIndex];
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦é‡æ–°é¸æ“‡ï¼ˆé‡å°ä¸­ç­‰æ¬Šé‡çš„æ§åˆ¶ï¼‰
        if (candidateWeight < 0.5 && Math.random() < 0.7 && attempts < MAX_POSITION_ATTEMPTS - 1) {
          console.log(`ğŸ”„ ç›®æ¨™å’Œå€¼-ä½ç½®${position + 1}è™Ÿç¢¼${candidateNumber}æ¬Šé‡è¼ƒä½(${candidateWeight})ï¼Œé‡æ–°é¸æ“‡ (ç¬¬${attempts + 1}æ¬¡å˜—è©¦)`);
          attempts++;
          continue;
        }
        
        selectedNumber = candidateNumber;
        console.log(`ğŸ² ç›®æ¨™å’Œå€¼-ä½ç½®${position + 1}æ¬Šé‡é¸æ“‡è™Ÿç¢¼${selectedNumber} (æ¬Šé‡:${candidateWeight})`);
      }
      
      attempts++;
    }
    
    // å¦‚æœç¶“éå¤šæ¬¡å˜—è©¦é‚„æ˜¯æ²’æœ‰é¸åˆ°åˆé©çš„è™Ÿç¢¼ï¼Œä½¿ç”¨æœ€å¾Œé¸æ“‡çš„è™Ÿç¢¼
    if (selectedNumber === null && availableNumbers.length > 0) {
      selectedNumber = availableNumbers[0]; // ä½¿ç”¨ç¬¬ä¸€å€‹å¯ç”¨è™Ÿç¢¼
      console.warn(`âš ï¸ ç›®æ¨™å’Œå€¼-ä½ç½®${position + 1}ç¶“é${MAX_POSITION_ATTEMPTS}æ¬¡å˜—è©¦ï¼Œä½¿ç”¨é»˜èªè™Ÿç¢¼${selectedNumber}`);
    }
    
    // å°‡é¸ä¸­çš„è™Ÿç¢¼åŠ å…¥çµæœä¸¦å¾å¯ç”¨è™Ÿç¢¼ä¸­ç§»é™¤
    if (selectedNumber !== null) {
      result.push(selectedNumber);
      const removeIndex = availableNumbers.indexOf(selectedNumber);
      if (removeIndex > -1) {
        availableNumbers.splice(removeIndex, 1);
      }
    }
  }
  
  console.log(`ğŸ¯ ç›®æ¨™å’Œå€¼${targetSum}ç”Ÿæˆå®Œæˆ: [${result.join(', ')}]`);
  return result;
}

// ç›£æ§ä¸¦èª¿æ•´ç³»çµ±
async function monitorAndAdjustSystem() {
  try {
    // è¨ˆç®—è¿‘æœŸå¹³å°ç›ˆè™§æƒ…æ³(æœ€è¿‘10æœŸ)
    const recentProfitLoss = await calculateRecentProfitLoss(10);
    
    console.log('ç³»çµ±ç›£æ§ - è¿‘æœŸå¹³å°ç›ˆè™§:', recentProfitLoss);
    
    // è¨­å®šèª¿æ•´é–¾å€¼
    const THRESHOLD = 5000;
    
    // å¦‚æœå¹³å°é€£çºŒè™§æï¼Œé©ç•¶èª¿æ•´æ§åˆ¶åƒæ•¸
    if (recentProfitLoss < -THRESHOLD) {
      CONTROL_PARAMS.adjustmentFactor += 0.05;
      CONTROL_PARAMS.randomnessFactor -= 0.05;
      console.log('ç³»çµ±ç›£æ§ - å¹³å°è™§æéå¤šï¼ŒåŠ å¼·æ§åˆ¶');
    } 
    // å¦‚æœå¹³å°ç²åˆ©éå¤šï¼Œé©ç•¶æ”¾å¯¬æ§åˆ¶
    else if (recentProfitLoss > THRESHOLD * 2) {
      CONTROL_PARAMS.adjustmentFactor -= 0.03;
      CONTROL_PARAMS.randomnessFactor += 0.03;
      console.log('ç³»çµ±ç›£æ§ - å¹³å°ç²åˆ©éå¤šï¼Œæ”¾å¯¬æ§åˆ¶');
    }
    
    // ç¢ºä¿åƒæ•¸åœ¨åˆç†ç¯„åœå…§
    CONTROL_PARAMS.adjustmentFactor = Math.max(0.3, Math.min(0.9, CONTROL_PARAMS.adjustmentFactor));
    CONTROL_PARAMS.randomnessFactor = Math.max(0.1, Math.min(0.5, CONTROL_PARAMS.randomnessFactor));
    
    console.log('ç³»çµ±ç›£æ§ - ç•¶å‰æ§åˆ¶åƒæ•¸:', CONTROL_PARAMS);
  } catch (error) {
    console.error('ç›£æ§èˆ‡èª¿æ•´ç³»çµ±å‡ºéŒ¯:', error);
  }
}

// è¨ˆç®—è¿‘æœŸå¹³å°ç›ˆè™§
async function calculateRecentProfitLoss(periods = 10) {
  try {
    // ç²å–æœ€è¿‘å¹¾æœŸçš„æ‰€æœ‰å·²çµç®—æ³¨å–®
    const recentBets = await BetModel.getRecentSettledBets(periods);
    
    // è¨ˆç®—å¹³å°æ·¨æ”¶ç›Š
    let platformProfit = 0;
    
    recentBets.forEach(bet => {
      if (bet.win) {
        // ç©å®¶è´éŒ¢ï¼Œå¹³å°è™§æ
        platformProfit -= parseFloat(bet.win_amount) - parseFloat(bet.amount);
      } else {
        // ç©å®¶è¼¸éŒ¢ï¼Œå¹³å°ç²åˆ©
        platformProfit += parseFloat(bet.amount);
      }
    });
    
    return platformProfit;
  } catch (error) {
    console.error('è¨ˆç®—è¿‘æœŸç›ˆè™§å‡ºéŒ¯:', error);
    return 0;
  }
}

// åœ¨éŠæˆ²çµç®—é‚è¼¯ä¸­è™•ç†é»æ•¸ç™¼æ”¾å’Œé€€æ°´åˆ†é…
async function settleBets(period, winResult) {
  console.log(`ğŸ¯ ä½¿ç”¨æ”¹é€²çš„çµç®—ç³»çµ±çµç®—ç¬¬${period}æœŸæ³¨å–®...`);
  
  try {
    // ä½¿ç”¨æ–°çš„çµç®—ç³»çµ±
    const result = await improvedSettleBets(period, winResult);
    
    if (result.success) {
      console.log(`âœ… ç¬¬${period}æœŸçµç®—å®Œæˆ:`);
      console.log(`  - çµç®—æ³¨å–®æ•¸: ${result.settledCount}`);
      console.log(`  - ç¸½ä¸­çé‡‘é¡: ${result.totalWinAmount}`);
      
      // åŒæ­¥ä¸­çæ•¸æ“šåˆ°ä»£ç†ç³»çµ±
      // æ³¨æ„ï¼šé¤˜é¡å·²ç¶“åœ¨éŠæˆ²ç³»çµ±æ›´æ–°ï¼Œä¸éœ€è¦å†åŒæ­¥åˆ°ä»£ç†ç³»çµ±
      // é€™è£¡åªè¨˜éŒ„æ—¥èªŒ
      if (result.userWinnings && Object.keys(result.userWinnings).length > 0) {
        for (const [username, winAmount] of Object.entries(result.userWinnings)) {
          console.log(`ğŸ’° ç”¨æˆ¶ ${username} ä¸­ç ${winAmount} å…ƒï¼ˆæœŸè™Ÿ ${period}ï¼‰`);
          // ä¸å†åŒæ­¥é¤˜é¡åˆ°ä»£ç†ç³»çµ±ï¼Œé¿å…é‡è¤‡è¨ˆç®—
        }
      }
    } else {
      console.log(`âš ï¸ ç¬¬${period}æœŸçµç®—è·³é: ${result.reason}`);
    }
  } catch (error) {
    console.error(`âŒ çµç®—ç¬¬${period}æœŸæ™‚ç™¼ç”ŸéŒ¯èª¤:`, error);
    // å¯ä»¥è€ƒæ…®ç™¼é€å‘Šè­¦é€šçŸ¥
  }
}

// ä¿ç•™åŸæœ‰çš„çµç®—å‡½æ•¸ä½œç‚ºå‚™ä»½
async function legacySettleBets(period, winResult) {
  console.log(`çµç®—ç¬¬${period}æœŸæ³¨å–®...`);
  
  // ç²å–ç³»çµ±æ™‚é–“å…§æœªçµç®—çš„æ³¨å–®
  const bets = await BetModel.getUnsettledByPeriod(period);
  
  console.log(`æ‰¾åˆ°${bets.length}å€‹æœªçµç®—æ³¨å–®`);
  
  if (bets.length === 0) {
    console.log(`ç¬¬${period}æœŸæ³¨å–®çµç®—å®Œæˆ`);
    return;
  }
  
  // ç²å–ç¸½ä»£ç†ID
  const adminAgent = await getAdminAgentId();
  if (!adminAgent) {
    console.error('çµç®—æ³¨å–®å¤±æ•—: æ‰¾ä¸åˆ°ç¸½ä»£ç†å¸³æˆ¶');
    return;
  }
  
  // éæ­·ä¸¦çµç®—æ¯å€‹æ³¨å–®
  for (const bet of bets) {
    try {
      const username = bet.username;
      
      // è¨ˆç®—è´éŒ¢é‡‘é¡
      const winAmount = calculateWinAmount(bet, winResult);
      const isWin = winAmount > 0;
      
      console.log(`çµç®—ç”¨æˆ¶ ${username} çš„æ³¨å–® ${bet.id}ï¼Œä¸‹æ³¨é¡å‹: ${bet.bet_type}ï¼Œä¸‹æ³¨å€¼: ${bet.bet_value}ï¼Œè´éŒ¢é‡‘é¡: ${winAmount}`);
      
      // æ¨™è¨˜ç‚ºå·²çµç®—
      await BetModel.updateSettlement(bet.id, isWin, winAmount);
      
      // å¦‚æœè´äº†ï¼Œç›´æ¥å¢åŠ æœƒå“¡é¤˜é¡ï¼ˆä¸å¾ä»£ç†æ‰£é™¤ï¼‰
      if (isWin) {
        try {
          // ç²å–ç•¶å‰é¤˜é¡ç”¨æ–¼æ—¥èªŒè¨˜éŒ„
          const currentBalance = await getBalance(username);
          
          // ğŸ”§ ä¿®æ­£ï¼šç”¨æˆ¶ä¸‹æ³¨æ™‚å·²æ‰£é™¤æœ¬é‡‘ï¼Œä¸­çæ™‚æ‡‰è¿”é‚„ç¸½çé‡‘
          const betAmount = parseFloat(bet.amount);
          const totalWinAmount = parseFloat(winAmount); // é€™æ˜¯ç¸½å›å ±ï¼ˆå«æœ¬é‡‘ï¼‰
          const netProfit = totalWinAmount - betAmount; // ç´”çé‡‘éƒ¨åˆ†
          
          console.log(`ğŸ¯ çµç®—è©³æƒ…: ä¸‹æ³¨ ${betAmount} å…ƒï¼Œç¸½å›å ± ${totalWinAmount} å…ƒï¼Œç´”çé‡‘ ${netProfit} å…ƒ`);
          
          // åŸå­æ€§å¢åŠ æœƒå“¡é¤˜é¡ï¼ˆå¢åŠ ç¸½å›å ±ï¼Œå› ç‚ºä¸‹æ³¨æ™‚å·²æ‰£é™¤æœ¬é‡‘ï¼‰
          const newBalance = await UserModel.addBalance(username, totalWinAmount);
          
          // åªåŒæ­¥é¤˜é¡åˆ°ä»£ç†ç³»çµ±ï¼ˆä¸æ‰£ä»£ç†é»æ•¸ï¼‰
          try {
            await fetch(`${AGENT_API_URL}/api/agent/sync-member-balance`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                username: username,
                balance: newBalance,
                reason: `ç¬¬${period}æœŸä¸­ç ${bet.bet_type}:${bet.bet_value} (ä¸‹æ³¨${betAmount}å…ƒï¼Œç¸½å›å ±${totalWinAmount}å…ƒï¼Œç´”çé‡‘${netProfit}å…ƒ)`
              })
            });
          } catch (syncError) {
            console.warn('åŒæ­¥é¤˜é¡åˆ°ä»£ç†ç³»çµ±å¤±æ•—ï¼Œä½†æœƒå“¡é¤˜é¡å·²æ›´æ–°:', syncError);
          }
          
          console.log(`ç”¨æˆ¶ ${username} ä¸­ççµç®—: ä¸‹æ³¨${betAmount}å…ƒ â†’ ç¸½å›å ±${totalWinAmount}å…ƒ â†’ ç´”çé‡‘${netProfit}å…ƒï¼Œé¤˜é¡å¾ ${currentBalance} æ›´æ–°ç‚º ${newBalance}`);
        } catch (error) {
          console.error(`æ›´æ–°ç”¨æˆ¶ ${username} ä¸­çé¤˜é¡å¤±æ•—:`, error);
        }
      }
      
      // åœ¨çµç®—æ™‚åˆ†é…é€€æ°´çµ¦ä»£ç†ï¼ˆä¸è«–è¼¸è´ï¼ŒåŸºæ–¼ä¸‹æ³¨é‡‘é¡ï¼‰
      try {
        await distributeRebate(username, parseFloat(bet.amount), period);
        console.log(`å·²ç‚ºæœƒå“¡ ${username} çš„æ³¨å–® ${bet.id} åˆ†é…é€€æ°´åˆ°ä»£ç†`);
      } catch (rebateError) {
        console.error(`åˆ†é…é€€æ°´å¤±æ•— (æ³¨å–®ID=${bet.id}):`, rebateError);
      }
        } catch (error) {
      console.error(`çµç®—ç”¨æˆ¶æ³¨å–®å‡ºéŒ¯ (ID=${bet.id}):`, error);
      }
    }
    
    console.log(`ç¬¬${period}æœŸæ³¨å–®çµç®—å®Œæˆ`);
}

// é€€æ°´åˆ†é…å‡½æ•¸
async function distributeRebate(username, betAmount, period) {
  try {
    console.log(`é–‹å§‹ç‚ºæœƒå“¡ ${username} åˆ†é…é€€æ°´ï¼Œä¸‹æ³¨é‡‘é¡: ${betAmount}`);
    
    // ç²å–æœƒå“¡çš„ä»£ç†éˆä¾†ç¢ºå®šæœ€å¤§é€€æ°´æ¯”ä¾‹
    const agentChain = await getAgentChain(username);
    if (!agentChain || agentChain.length === 0) {
      console.log(`æœƒå“¡ ${username} æ²’æœ‰ä»£ç†éˆï¼Œé€€æ°´æ­¸å¹³å°æ‰€æœ‰`);
      return;
    }
    
    // ğŸ”§ ä¿®æ­£ï¼šè¨ˆç®—å›ºå®šçš„ç¸½é€€æ°´æ± ï¼ˆæ ¹æ“šç›¤å£é¡å‹ï¼‰
    const directAgent = agentChain[0]; // ç¬¬ä¸€å€‹æ˜¯ç›´å±¬ä»£ç†
    const maxRebatePercentage = directAgent.market_type === 'A' ? 0.011 : 0.041; // Aç›¤1.1%, Dç›¤4.1%
    const totalRebatePool = parseFloat(betAmount) * maxRebatePercentage; // å›ºå®šç¸½æ± 
    
    console.log(`æœƒå“¡ ${username} çš„ä»£ç†éˆ:`, agentChain.map(a => `${a.username}(L${a.level}-${a.rebate_mode}:${(a.rebate_percentage*100).toFixed(1)}%)`));
    console.log(`å›ºå®šé€€æ°´æ± : ${totalRebatePool.toFixed(2)} å…ƒ (${(maxRebatePercentage*100).toFixed(1)}%)`);
    
    // ğŸ”§ ä¿®æ­£ï¼šæŒ‰å±¤ç´šé †åºåˆ†é…é€€æ°´ï¼Œä¸Šç´šåªæ‹¿å·®é¡
    let remainingRebate = totalRebatePool;
    let distributedPercentage = 0; // å·²ç¶“åˆ†é…çš„é€€æ°´æ¯”ä¾‹
    
    for (let i = 0; i < agentChain.length; i++) {
      const agent = agentChain[i];
      let agentRebateAmount = 0;
      
      // å¦‚æœæ²’æœ‰å‰©é¤˜é€€æ°´ï¼ŒçµæŸåˆ†é…
      if (remainingRebate <= 0.01) {
        console.log(`é€€æ°´æ± å·²å…¨éƒ¨åˆ†é…å®Œç•¢`);
        break;
      }
      
      const rebatePercentage = parseFloat(agent.rebate_percentage);
      
      if (isNaN(rebatePercentage) || rebatePercentage <= 0) {
        // é€€æ°´æ¯”ä¾‹ç‚º0ï¼Œè©²ä»£ç†ä¸æ‹¿é€€æ°´ï¼Œå…¨éƒ¨çµ¦ä¸Šç´š
        agentRebateAmount = 0;
        console.log(`ä»£ç† ${agent.username} é€€æ°´æ¯”ä¾‹ç‚º ${(rebatePercentage*100).toFixed(1)}%ï¼Œä¸æ‹¿ä»»ä½•é€€æ°´ï¼Œå‰©é¤˜ ${remainingRebate.toFixed(2)} å…ƒç¹¼çºŒå‘ä¸Šåˆ†é…`);
      } else {
        // ğŸ”§ ä¿®æ­£ï¼šè¨ˆç®—è©²ä»£ç†å¯¦éš›èƒ½æ‹¿çš„é€€æ°´æ¯”ä¾‹ï¼ˆä¸èƒ½è¶…éå·²åˆ†é…çš„ï¼‰
        const actualRebatePercentage = Math.max(0, rebatePercentage - distributedPercentage);
        
        if (actualRebatePercentage <= 0) {
          console.log(`ä»£ç† ${agent.username} é€€æ°´æ¯”ä¾‹ ${(rebatePercentage*100).toFixed(1)}% å·²è¢«ä¸‹ç´šåˆ†å®Œï¼Œä¸èƒ½å†ç²å¾—é€€æ°´`);
          agentRebateAmount = 0;
        } else {
          // è¨ˆç®—è©²ä»£ç†å¯¦éš›ç²å¾—çš„é€€æ°´é‡‘é¡
          agentRebateAmount = parseFloat(betAmount) * actualRebatePercentage;
          // ç¢ºä¿ä¸è¶…éå‰©é¤˜é€€æ°´æ± 
          agentRebateAmount = Math.min(agentRebateAmount, remainingRebate);
          // å››æ¨äº”å…¥åˆ°å°æ•¸é»å¾Œ2ä½
          agentRebateAmount = Math.round(agentRebateAmount * 100) / 100;
          remainingRebate -= agentRebateAmount;
          distributedPercentage += actualRebatePercentage;
          
          console.log(`ä»£ç† ${agent.username} é€€æ°´æ¯”ä¾‹ç‚º ${(rebatePercentage*100).toFixed(1)}%ï¼Œå¯¦éš›ç²å¾— ${(actualRebatePercentage*100).toFixed(1)}% = ${agentRebateAmount.toFixed(2)} å…ƒï¼Œå‰©é¤˜æ± é¡ ${remainingRebate.toFixed(2)} å…ƒ`);
        }
        
        // å¦‚æœè©²ä»£ç†çš„æ¯”ä¾‹é”åˆ°æˆ–è¶…éæœ€å¤§å€¼ï¼Œèªªæ˜æ˜¯å…¨æ‹¿æ¨¡å¼
        if (rebatePercentage >= maxRebatePercentage) {
          console.log(`ä»£ç† ${agent.username} æ‹¿äº†å…¨éƒ¨é€€æ°´æ± ï¼ŒçµæŸåˆ†é…`);
          remainingRebate = 0;
        }
      }
      
      if (agentRebateAmount > 0) {
        // åˆ†é…é€€æ°´çµ¦ä»£ç†
        await allocateRebateToAgent(agent.id, agent.username, agentRebateAmount, username, betAmount, period);
        console.log(`âœ… åˆ†é…é€€æ°´ ${agentRebateAmount.toFixed(2)} çµ¦ä»£ç† ${agent.username} (æ¯”ä¾‹: ${(parseFloat(agent.rebate_percentage)*100).toFixed(1)}%, å‰©é¤˜: ${remainingRebate.toFixed(2)})`);
        
        // å¦‚æœæ²’æœ‰å‰©é¤˜é€€æ°´äº†ï¼ŒçµæŸåˆ†é…
        if (remainingRebate <= 0.01) {
          break;
        }
      }
    }
    
    // å‰©é¤˜é€€æ°´æ­¸å¹³å°æ‰€æœ‰
    if (remainingRebate > 0.01) { // è€ƒæ…®æµ®é»æ•¸ç²¾åº¦å•é¡Œ
      console.log(`å‰©é¤˜é€€æ°´æ±  ${remainingRebate.toFixed(2)} å…ƒæ­¸å¹³å°æ‰€æœ‰`);
    }
    
    console.log(`âœ… é€€æ°´åˆ†é…å®Œæˆï¼Œç¸½æ± : ${totalRebatePool.toFixed(2)}å…ƒï¼Œå·²åˆ†é…: ${(totalRebatePool - remainingRebate).toFixed(2)}å…ƒï¼Œå¹³å°ä¿ç•™: ${remainingRebate.toFixed(2)}å…ƒ`);
    
  } catch (error) {
    console.error('åˆ†é…é€€æ°´æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
  }
}

// ç²å–æœƒå“¡çš„ä»£ç†éˆï¼ˆå¾ç›´å±¬ä»£ç†åˆ°ç¸½ä»£ç†ï¼‰
async function getAgentChain(username) {
  try {
    // å¾ä»£ç†ç³»çµ±ç²å–æœƒå“¡æ‰€å±¬çš„ä»£ç†
    const response = await fetch(`${AGENT_API_URL}/api/agent/member-agent-chain?username=${username}`);
    const data = await response.json();
    
    if (data.success && data.agentChain) {
      return data.agentChain;
    }
    
    console.log(`ç„¡æ³•ç²å–æœƒå“¡ ${username} çš„ä»£ç†éˆ`);
    return [];
  } catch (error) {
    console.error('ç²å–ä»£ç†éˆæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
    return [];
  }
}

// åˆ†é…é€€æ°´çµ¦ä»£ç†
async function allocateRebateToAgent(agentId, agentUsername, rebateAmount, memberUsername, betAmount, period) {
  try {
    // èª¿ç”¨ä»£ç†ç³»çµ±çš„é€€æ°´åˆ†é…API
    const response = await fetch(`${AGENT_API_URL}/api/agent/allocate-rebate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        agentId: agentId,
        agentUsername: agentUsername,
        rebateAmount: rebateAmount,
        memberUsername: memberUsername,
        betAmount: betAmount,
        reason: period
      })
    });
    
    // æª¢æŸ¥HTTPç‹€æ…‹ç¢¼
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const result = await response.json();
    if (!result.success) {
      console.error(`åˆ†é…é€€æ°´çµ¦ä»£ç† ${agentUsername} å¤±æ•—:`, result.message);
    }
  } catch (error) {
    console.error(`åˆ†é…é€€æ°´çµ¦ä»£ç† ${agentUsername} æ™‚ç™¼ç”ŸéŒ¯èª¤:`, error);
  }
}

// ä¿®æ”¹ç²å–é¤˜é¡çš„APIç«¯é»
app.get('/api/balance', async (req, res) => {
  const { username } = req.query;
  
  try {
    // åƒæ•¸é©—è­‰
  if (!username) {
    return res.status(400).json({ 
      success: false, 
        message: 'è«‹æä¾›ç”¨æˆ¶å' 
    });
  }

    // ç²å–ç”¨æˆ¶ä¿¡æ¯
    const user = await UserModel.findByUsername(username);
    if (!user) {
      console.log(`ç”¨æˆ¶ä¸å­˜åœ¨: ${username}`);
      return res.json({ 
          success: false,
        message: 'ç”¨æˆ¶ä¸å­˜åœ¨', 
        balance: 0 
        });
    }
    
    console.log(`ç‚ºç”¨æˆ¶ ${username} ç²å–é¤˜é¡`);

    try {
      // å¾ä»£ç†ç³»çµ±ç²å–é¤˜é¡
      const response = await fetch(`${AGENT_API_URL}/api/agent/member-balance?username=${username}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      const data = await response.json();
      
      if (data.success) {
        console.log('ä»£ç†ç³»çµ±è¿”å›çš„é¤˜é¡æ•¸æ“š:', data);
        
        // æ›´æ–°æœ¬åœ°é¤˜é¡
        await UserModel.setBalance(username, data.balance);
        console.log('æ›´æ–°æœ¬åœ°é¤˜é¡ç‚º:', data.balance);
        
        return res.json({ 
          success: true, 
          balance: data.balance,
          source: 'agent_system'
        });
      } else {
        console.log('ä»£ç†ç³»çµ±å›æ‡‰å¤±æ•—ï¼Œä½¿ç”¨æœ¬åœ°é¤˜é¡:', user.balance);
        return res.json({ 
          success: true, 
          balance: user.balance,
          source: 'local_db' 
        });
      }
    } catch (error) {
      console.error('ç²å–ä»£ç†ç³»çµ±é¤˜é¡å‡ºéŒ¯:', error);
      console.log('ç™¼ç”ŸéŒ¯èª¤ï¼Œä½¿ç”¨æœ¬åœ°é¤˜é¡:', user.balance);
      return res.json({ 
        success: true, 
        balance: user.balance,
        source: 'local_db_error' 
      });
    }
  } catch (error) {
    console.error('ç²å–é¤˜é¡å‡ºéŒ¯:', error);
    res.status(500).json({ 
      success: false, 
      message: 'ç³»çµ±éŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦' 
    });
  }
});

// ç²å–ä»Šæ—¥ç›ˆè™§çš„APIç«¯é»
app.get('/api/daily-profit', async (req, res) => {
  const { username } = req.query;
  
  try {
    // åƒæ•¸é©—è­‰
    if (!username) {
      return res.status(400).json({ 
        success: false, 
        message: 'è«‹æä¾›ç”¨æˆ¶å' 
      });
    }

    // å…ˆæª¢æŸ¥ä»£ç†ç³»çµ±ä¸­çš„æœƒå“¡ä¿¡æ¯
    try {
      const memberResponse = await fetch(`${AGENT_API_URL}/api/agent/member/info/${username}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      if (!memberResponse.ok) {
        return res.json({ 
          success: false,
          message: 'ç”¨æˆ¶ä¸å­˜åœ¨', 
          profit: 0 
        });
      }
      
      const memberData = await memberResponse.json();
      if (!memberData.success) {
        return res.json({ 
          success: false,
          message: 'ç”¨æˆ¶ä¸å­˜åœ¨', 
          profit: 0 
        });
      }
    } catch (error) {
      console.error('æª¢æŸ¥æœƒå“¡ä¿¡æ¯å¤±æ•—:', error);
      return res.json({ 
        success: false,
        message: 'ç”¨æˆ¶ä¸å­˜åœ¨', 
        profit: 0 
      });
    }

    // ç²å–ä»Šæ—¥é–‹å§‹å’ŒçµæŸæ™‚é–“ï¼ˆä½¿ç”¨UTCæ™‚é–“ï¼‰
    const today = new Date();
    const startOfDay = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));
    const endOfDay = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate() + 1));

    // æŸ¥è©¢ä»Šæ—¥æŠ•æ³¨è¨˜éŒ„ - ä¿®æ­£ç›ˆè™§è¨ˆç®—é‚è¼¯
    const result = await db.oneOrNone(
      `SELECT 
        COALESCE(SUM(amount), 0) as total_bet,
        COALESCE(SUM(CASE WHEN win = true THEN win_amount ELSE 0 END), 0) as total_win,
        COALESCE(SUM(CASE WHEN win = true THEN (win_amount - amount) ELSE -amount END), 0) as net_profit
      FROM bet_history 
      WHERE username = $1 
        AND settled = true 
        AND created_at >= $2 
        AND created_at < $3`,
      [username, startOfDay, endOfDay]
    );

    const totalBet = result ? parseFloat(result.total_bet) || 0 : 0;
    const totalWin = result ? parseFloat(result.total_win) || 0 : 0;
    const dailyProfit = result ? parseFloat(result.net_profit) || 0 : 0;

    console.log(`ç”¨æˆ¶ ${username} ä»Šæ—¥ç›ˆè™§: æŠ•æ³¨ ${totalBet}, è´å¾— ${totalWin}, ç›ˆè™§ ${dailyProfit}`);

    res.json({ 
      success: true, 
      profit: dailyProfit,
      totalBet: totalBet,
      totalWin: totalWin
    });

  } catch (error) {
    console.error('ç²å–ä»Šæ—¥ç›ˆè™§å‡ºéŒ¯:', error);
    res.status(500).json({ 
      success: false, 
      message: 'ç³»çµ±éŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦' 
    });
  }
});

// ç²å–ç›ˆè™§è¨˜éŒ„çš„APIç«¯é»
app.get('/api/profit-records', async (req, res) => {
  const { username, days = 7 } = req.query;
  
  try {
    // åƒæ•¸é©—è­‰
    if (!username) {
      return res.status(400).json({ 
        success: false, 
        message: 'è«‹æä¾›ç”¨æˆ¶å' 
      });
    }

    // å…ˆæª¢æŸ¥ä»£ç†ç³»çµ±ä¸­çš„æœƒå“¡ä¿¡æ¯
    try {
      const memberResponse = await fetch(`${AGENT_API_URL}/api/agent/member/info/${username}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      if (!memberResponse.ok) {
        return res.json({ 
          success: false,
          message: 'ç”¨æˆ¶ä¸å­˜åœ¨',
          records: [],
          totalBetCount: 0,
          totalProfit: 0
        });
      }
      
      const memberData = await memberResponse.json();
      if (!memberData.success) {
        return res.json({ 
          success: false,
          message: 'ç”¨æˆ¶ä¸å­˜åœ¨',
          records: [],
          totalBetCount: 0,
          totalProfit: 0
        });
      }
    } catch (error) {
      console.error('æª¢æŸ¥æœƒå“¡ä¿¡æ¯å¤±æ•—:', error);
      return res.json({ 
        success: false,
        message: 'ç”¨æˆ¶ä¸å­˜åœ¨',
        records: [],
        totalBetCount: 0,
        totalProfit: 0
      });
    }

    // è¨ˆç®—æ—¥æœŸç¯„åœ
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(endDate.getDate() - parseInt(days));

    // ç²å–æŒ‡å®šå¤©æ•¸å…§çš„æ¯æ—¥ç›ˆè™§è¨˜éŒ„ - ä¿®æ­£win_amountå•é¡Œ
    const query = `
      SELECT 
        DATE(created_at AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Taipei') as date,
        COUNT(*) as bet_count,
        COALESCE(SUM(amount), 0) as total_bet,
        COALESCE(SUM(CASE WHEN win = true THEN win_amount ELSE 0 END), 0) as total_win
      FROM bet_history 
      WHERE username = $1 
        AND settled = true 
        AND created_at >= $2 
        AND created_at < $3
      GROUP BY DATE(created_at AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Taipei')
      ORDER BY date DESC
    `;

    // åŸ·è¡ŒæŸ¥è©¢
    const result = await db.any(query, [username, startDate, endDate]);
    
    // è™•ç†æŸ¥è©¢çµæœ - ä¿®æ­£ç›ˆè™§è¨ˆç®—
    const records = result && result.length > 0 ? result.map(row => {
      const totalBet = parseFloat(row.total_bet);
      const totalWin = parseFloat(row.total_win);
      // æ­£ç¢ºè¨ˆç®—ç›ˆè™§ï¼šå¯¦éš›ç²å¾—çš„éŒ¢æ¸›å»æŠ•æ³¨çš„éŒ¢
      const profit = totalWin - totalBet;
      return {
        date: row.date,
        betCount: parseInt(row.bet_count),
        profit: profit
      };
    }) : [];
    
    // è¨ˆç®—ç¸½è¨ˆ
    const totalBetCount = records.reduce((sum, record) => sum + record.betCount, 0);
    const totalProfit = records.reduce((sum, record) => sum + record.profit, 0);
    
    console.log(`ç²å–ç”¨æˆ¶ ${username} çš„ ${days} å¤©ç›ˆè™§è¨˜éŒ„: ${records.length} å¤©è¨˜éŒ„`);
    
    res.json({
      success: true,
      records,
      totalBetCount,
      totalProfit
    });

  } catch (error) {
    console.error('ç²å–ç›ˆè™§è¨˜éŒ„å‡ºéŒ¯:', error);
    res.status(500).json({ 
      success: false, 
      message: 'ç²å–ç›ˆè™§è¨˜éŒ„å¤±æ•—',
      records: [],
      totalBetCount: 0,
      totalProfit: 0
    });
  }
});

// ç²å–é€±ç›ˆè™§è¨˜éŒ„çš„APIç«¯é»
app.get('/api/weekly-profit-records', async (req, res) => {
  const { username, startDate, endDate } = req.query;
  
  try {
    // åƒæ•¸é©—è­‰
    if (!username || !startDate || !endDate) {
      return res.status(400).json({ 
        success: false, 
        message: 'è«‹æä¾›ç”¨æˆ¶åã€é–‹å§‹æ—¥æœŸå’ŒçµæŸæ—¥æœŸ' 
      });
    }

    // å…ˆæª¢æŸ¥ä»£ç†ç³»çµ±ä¸­çš„æœƒå“¡ä¿¡æ¯
    try {
      const memberResponse = await fetch(`${AGENT_API_URL}/api/agent/member/info/${username}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      if (!memberResponse.ok) {
        return res.json({ 
          success: false,
          message: 'ç”¨æˆ¶ä¸å­˜åœ¨',
          records: [],
          totalBetCount: 0,
          totalProfit: 0
        });
      }
      
      const memberData = await memberResponse.json();
      if (!memberData.success) {
        return res.json({ 
          success: false,
          message: 'ç”¨æˆ¶ä¸å­˜åœ¨',
          records: [],
          totalBetCount: 0,
          totalProfit: 0
        });
      }
    } catch (error) {
      console.error('æª¢æŸ¥æœƒå“¡ä¿¡æ¯å¤±æ•—:', error);
      return res.json({ 
        success: false,
        message: 'ç”¨æˆ¶ä¸å­˜åœ¨',
        records: [],
        totalBetCount: 0,
        totalProfit: 0
      });
    }

    // è½‰æ›æ—¥æœŸç‚ºDateå°è±¡
    const start = new Date(startDate);
    const end = new Date(endDate);

    console.log(`ç²å–ç”¨æˆ¶ ${username} çš„é€±ç›ˆè™§è¨˜éŒ„ï¼Œæ™‚é–“ç¯„åœ: ${start.toISOString()} åˆ° ${end.toISOString()}`);

    // ç²å–æŒ‡å®šé€±æœŸå…§çš„æ¯æ—¥ç›ˆè™§è¨˜éŒ„ - ä½¿ç”¨æ­£ç¢ºçš„ç›ˆè™§è¨ˆç®—å…¬å¼
    const query = `
      SELECT 
        DATE(created_at AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Taipei') as date,
        COUNT(*) as bet_count,
        COALESCE(SUM(amount), 0) as total_bet,
        COALESCE(SUM(CASE WHEN win = true THEN win_amount ELSE 0 END), 0) as total_win,
        COALESCE(SUM(CASE WHEN win = true THEN (win_amount - amount) ELSE -amount END), 0) as net_profit
      FROM bet_history 
      WHERE username = $1 
        AND settled = true 
        AND created_at >= $2 
        AND created_at <= $3
      GROUP BY DATE(created_at AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Taipei')
      ORDER BY date ASC
    `;

    // åŸ·è¡ŒæŸ¥è©¢
    const result = await db.any(query, [username, start, end]);
    
    // è™•ç†æŸ¥è©¢çµæœï¼Œå¡«å……ç¼ºå¤±çš„æ—¥æœŸ
    const records = [];
    const weekDays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
    
    // ç”Ÿæˆä¸€é€±å…§æ¯ä¸€å¤©çš„è¨˜éŒ„
    for (let i = 0; i < 7; i++) {
      const currentDate = new Date(start);
      currentDate.setDate(start.getDate() + i);
      const dateStr = currentDate.toISOString().split('T')[0];
      
      // è¨ˆç®—ç•¶å‰æ—¥æœŸå°æ‡‰çš„æ˜ŸæœŸå¹¾
      const weekdayIndex = currentDate.getDay(); // 0=æ˜ŸæœŸæ—¥, 1=æ˜ŸæœŸä¸€, ..., 6=æ˜ŸæœŸå…­
      const weekdayName = weekDays[weekdayIndex];
      
      // æŸ¥æ‰¾è©²æ—¥æœŸçš„å¯¦éš›è¨˜éŒ„
      const dayRecord = result.find(row => {
        // row.date æ˜¯Dateå°è±¡ï¼ˆå°åŒ—æ™‚é–“ï¼‰ï¼Œéœ€è¦æ­£ç¢ºè½‰æ›ç‚ºå­—ç¬¦ä¸²æ¯”è¼ƒ
        let rowDateStr;
        if (row.date instanceof Date) {
          // ç”±æ–¼dateå·²ç¶“æ˜¯å°åŒ—æ™‚é–“çš„æ—¥æœŸï¼Œç›´æ¥æ ¼å¼åŒ–
          const year = row.date.getFullYear();
          const month = String(row.date.getMonth() + 1).padStart(2, '0');
          const day = String(row.date.getDate()).padStart(2, '0');
          rowDateStr = `${year}-${month}-${day}`;
        } else {
          rowDateStr = String(row.date).split('T')[0];
        }
        return rowDateStr === dateStr;
      });
      
      if (dayRecord) {
        const totalBet = parseFloat(dayRecord.total_bet);
        const totalWin = parseFloat(dayRecord.total_win);
        const netProfit = parseFloat(dayRecord.net_profit); // ä½¿ç”¨æ­£ç¢ºçš„æ·¨ç›ˆè™§
        records.push({
          date: dateStr,
          weekday: weekdayName,
          betCount: parseInt(dayRecord.bet_count),
          totalBet: totalBet,
          totalWin: totalWin,
          profit: netProfit // ä½¿ç”¨æ­£ç¢ºè¨ˆç®—çš„ç›ˆè™§
        });
      } else {
        // å¦‚æœè©²æ—¥æœŸæ²’æœ‰è¨˜éŒ„ï¼Œå¡«å……ç©ºè¨˜éŒ„
        records.push({
          date: dateStr,
          weekday: weekdayName,
          betCount: 0,
          totalBet: 0,
          totalWin: 0,
          profit: 0
        });
      }
    }
    
    // è¨ˆç®—ç¸½è¨ˆ
    const totalBetCount = records.reduce((sum, record) => sum + record.betCount, 0);
    const totalBetAmount = records.reduce((sum, record) => sum + record.totalBet, 0);
    const totalProfit = records.reduce((sum, record) => sum + record.profit, 0);
    
    console.log(`ç²å–ç”¨æˆ¶ ${username} çš„é€±ç›ˆè™§è¨˜éŒ„: ${records.length} å¤©è¨˜éŒ„ï¼Œç¸½æ³¨æ•¸ ${totalBetCount}ï¼Œç¸½æŠ•æ³¨é‡‘é¡ ${totalBetAmount}ï¼Œç¸½ç›ˆè™§ ${totalProfit}`);
    
    res.json({
      success: true,
      records,
      totalBetCount,
      totalBetAmount,
      totalProfit
    });

  } catch (error) {
    console.error('ç²å–é€±ç›ˆè™§è¨˜éŒ„å‡ºéŒ¯:', error);
    res.status(500).json({ 
      success: false, 
      message: 'ç²å–é€±ç›ˆè™§è¨˜éŒ„å¤±æ•—',
      records: [],
      totalBetCount: 0,
      totalProfit: 0
    });
  }
});

// ç²å–å–®æ—¥è©³ç´°è¨˜éŒ„çš„APIç«¯é»
app.get('/api/day-detail', async (req, res) => {
  const { username, date } = req.query;
  
  try {
    // åƒæ•¸é©—è­‰
    if (!username || !date) {
      return res.status(400).json({ 
        success: false, 
        message: 'è«‹æä¾›ç”¨æˆ¶åå’Œæ—¥æœŸ' 
      });
    }

    // æª¢æŸ¥ç”¨æˆ¶åæ˜¯å¦æœ‰æ•ˆ
    if (!username || username.trim() === '') {
      return res.json({ 
        success: false,
        message: 'ç„¡æ•ˆçš„ç”¨æˆ¶å',
        records: [],
        stats: { betCount: 0, profit: 0 }
      });
    }

    // è¨ˆç®—æ—¥æœŸç¯„åœï¼ˆç•¶æ—¥çš„é–‹å§‹å’ŒçµæŸï¼Œä½¿ç”¨å°åŒ—æ™‚å€ï¼‰
    const inputDate = new Date(date);
    
    // å¦‚æœè¼¸å…¥çš„æ˜¯ISOå­—ç¬¦ä¸²ï¼Œéœ€è¦æ­£ç¢ºè§£æ
    let targetDate;
    if (typeof date === 'string' && date.includes('T')) {
      // å¦‚æœæ˜¯å®Œæ•´çš„ISOå­—ç¬¦ä¸²ï¼Œè½‰æ›ç‚ºå°åŒ—æ™‚å€çš„æ—¥æœŸéƒ¨åˆ†
      targetDate = new Date(date);
      targetDate.setHours(targetDate.getHours() + 8); // è½‰æ›ç‚ºå°åŒ—æ™‚é–“
    } else {
      // å¦‚æœæ˜¯ç°¡å–®çš„æ—¥æœŸå­—ç¬¦ä¸²ï¼Œç›´æ¥ä½¿ç”¨
      targetDate = new Date(date);
    }
    
    // è¨ˆç®—å°åŒ—æ™‚å€çš„æ—¥æœŸé‚Šç•Œ
    const year = targetDate.getFullYear();
    const month = targetDate.getMonth();
    const day = targetDate.getDate();
    
    // å°åŒ—æ™‚é–“çš„ç•¶æ—¥é–‹å§‹å’ŒçµæŸ
    const startOfDayTaipei = new Date(year, month, day, 0, 0, 0);
    const endOfDayTaipei = new Date(year, month, day + 1, 0, 0, 0);
    
    // è½‰æ›ç‚ºUTCæ™‚é–“ï¼ˆå°åŒ—æ™‚é–“æ¸›å»8å°æ™‚ï¼‰
    const startOfDay = new Date(startOfDayTaipei.getTime() - 8 * 60 * 60 * 1000);
    const endOfDay = new Date(endOfDayTaipei.getTime() - 8 * 60 * 60 * 1000);

    console.log(`æŸ¥è©¢ç”¨æˆ¶ ${username} åœ¨ ${date} çš„è¨˜éŒ„ï¼Œæ™‚é–“ç¯„åœ: ${startOfDay.toISOString()} åˆ° ${endOfDay.toISOString()}`);

    // ç²å–ç•¶æ—¥çš„æ‰€æœ‰æ³¨å–®è¨˜éŒ„ï¼ŒåŒ…å«é–‹ççµæœ
    const query = `
      SELECT 
        bh.id, 
        bh.period, 
        bh.bet_type, 
        bh.bet_value, 
        bh.position, 
        bh.amount, 
        bh.odds,
        bh.win, 
        bh.win_amount, 
        bh.created_at,
        rh.result as draw_result
      FROM bet_history bh
      LEFT JOIN result_history rh ON bh.period = rh.period
      WHERE bh.username = $1 
        AND bh.settled = true 
        AND bh.created_at >= $2 
        AND bh.created_at < $3
      ORDER BY bh.created_at DESC
    `;

    console.log(`åŸ·è¡ŒæŸ¥è©¢: ${query}`);
    console.log(`æŸ¥è©¢åƒæ•¸: [${username}, ${startOfDay.toISOString()}, ${endOfDay.toISOString()}]`);

    // åŸ·è¡ŒæŸ¥è©¢
    const result = await db.any(query, [username, startOfDay, endOfDay]);
    console.log(`æŸ¥è©¢çµæœ: ${result ? result.length : 0} æ¢è¨˜éŒ„`);
    
    // è™•ç†æŸ¥è©¢çµæœ
    const records = result && result.length > 0 ? result.map(row => {
      let drawResult = null;
      try {
        if (row.draw_result && typeof row.draw_result === 'string') {
          drawResult = JSON.parse(row.draw_result);
        } else if (Array.isArray(row.draw_result)) {
          drawResult = row.draw_result;
        }
      } catch (e) {
        console.error('è§£æé–‹ççµæœå‡ºéŒ¯:', e, row.draw_result);
      }
      
      return {
        id: row.id,
        period: row.period,
        betType: row.bet_type,
        value: row.bet_value,
        position: row.position,
        amount: parseFloat(row.amount),
        odds: parseFloat(row.odds) || 1.0,
        win: row.win,
        winAmount: parseFloat(row.win_amount) || 0,
        time: row.created_at,
        drawResult: drawResult
      };
    }) : [];
    
    // è¨ˆç®—çµ±è¨ˆæ•¸æ“š
    const stats = {
      betCount: records.length,
      profit: records.reduce((sum, record) => {
        return sum + (record.win ? record.winAmount : 0) - record.amount;
      }, 0)
    };
    
    console.log(`ç²å–ç”¨æˆ¶ ${username} åœ¨ ${date} çš„è©³ç´°è¨˜éŒ„: ${records.length} æ¢è¨˜éŒ„`);

    res.json({
      success: true,
      records,
      stats
    });

  } catch (error) {
    console.error('ç²å–å–®æ—¥è©³ç´°è¨˜éŒ„å‡ºéŒ¯:', error);
    res.status(500).json({ 
      success: false, 
      message: 'ç²å–å–®æ—¥è©³ç´°è¨˜éŒ„å¤±æ•—',
      records: [],
      stats: { betCount: 0, profit: 0 }
    });
  }
});

// ä½ç½®è½‰æ›å‡½æ•¸
function positionToKey(position) {
  const positionMap = {
    1: 'first',
    2: 'second',
    3: 'third',
    4: 'fourth',
    5: 'fifth'
  };
  return positionMap[position] || 'first';
}

// ç²å–ç•¶å‰éŠæˆ²æ•¸æ“š
app.get('/api/game-data', async (req, res) => {
  try {
    // ç²å–è«‹æ±‚åƒæ•¸ä¸­çš„ç”¨æˆ¶åï¼ˆå¯é¸ï¼‰
    const username = req.query.username;
    let userMarketType = 'D'; // é»˜èªDç›¤
    
    // å¦‚æœæä¾›äº†ç”¨æˆ¶åï¼Œç²å–ç”¨æˆ¶ç›¤å£é¡å‹
    if (username) {
      try {
        // å…ˆå˜—è©¦ä½œç‚ºæœƒå“¡æŸ¥è©¢
        const memberResponse = await fetch(`${AGENT_API_URL}/api/agent/member/info/${username}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (memberResponse.ok) {
          const memberData = await memberResponse.json();
          if (memberData.success && memberData.member) {
            userMarketType = memberData.member.market_type || 'D';
            console.log(`æœƒå“¡ ${username} ç›¤å£é¡å‹: ${userMarketType}`);
          } else if (!memberData.success) {
            // å¦‚æœæœƒå“¡ä¸å­˜åœ¨(success=false)ï¼Œå˜—è©¦ä½œç‚ºä»£ç†æŸ¥è©¢
            console.log(`æœƒå“¡ ${username} ä¸å­˜åœ¨ï¼Œå˜—è©¦ä½œç‚ºä»£ç†æŸ¥è©¢...`);
            
            // ä»£ç†ç³»çµ±æš«æ™‚æ²’æœ‰ä»£ç†æŸ¥è©¢APIï¼Œç›´æ¥ä½¿ç”¨ç¡¬ç·¨ç¢¼é…ç½®
            if (username === 'ti2025A') {
              userMarketType = 'A';
              console.log(`ä½¿ç”¨ç¡¬ç·¨ç¢¼é…ç½®: ${username} ç›¤å£é¡å‹: ${userMarketType}`);
            } else {
              console.log(`æœªçŸ¥ä»£ç† ${username}ï¼Œä½¿ç”¨é»˜èªDç›¤`);
            }
          }
        }
      } catch (error) {
        console.warn('ç²å–ç”¨æˆ¶ç›¤å£é¡å‹å¤±æ•—ï¼Œä½¿ç”¨é»˜èªDç›¤:', error.message);
        
        // å¦‚æœæ˜¯å·²çŸ¥çš„æ¸¬è©¦ä»£ç†ï¼Œä½¿ç”¨ç¡¬ç·¨ç¢¼é…ç½®
        if (username === 'ti2025A') {
          userMarketType = 'A';
          console.log(`ç¶²çµ¡éŒ¯èª¤æ™‚ä½¿ç”¨ç¡¬ç·¨ç¢¼é…ç½®: ${username} ç›¤å£é¡å‹: ${userMarketType}`);
        }
      }
    }
    
    // å„ªå…ˆä½¿ç”¨å…§å­˜ç‹€æ…‹ï¼Œç¢ºä¿å¯¦æ™‚æ€§
    let currentGameState = memoryGameState;
    
    // å¦‚æœå…§å­˜ç‹€æ…‹ä¸å­˜åœ¨ï¼Œå¾æ•¸æ“šåº«ç²å–
    if (!currentGameState.current_period) {
      const dbGameState = await GameModel.getCurrentState();
      if (dbGameState) {
        currentGameState = {
          current_period: dbGameState.current_period,
          countdown_seconds: dbGameState.countdown_seconds,
          last_result: dbGameState.last_result,
          status: dbGameState.status
        };
        // åŒæ­¥åˆ°å…§å­˜
        memoryGameState = currentGameState;
      }
    }
    
    // è§£æJSONæ ¼å¼çš„last_result
    let last_result = currentGameState.last_result;
    if (typeof last_result === 'string') {
      try {
        last_result = JSON.parse(last_result);
      } catch (e) {
        console.warn('è§£ælast_resultå¤±æ•—:', e);
        last_result = [1,2,3,4,5,6,7,8,9,10]; // é»˜èªå€¼
      }
    }
    
    const gameData = {
      currentPeriod: currentGameState.current_period,
      countdownSeconds: currentGameState.countdown_seconds,
      lastResult: last_result,
      status: currentGameState.status
    };
    
    // æ ¹æ“šç”¨æˆ¶ç›¤å£é¡å‹å‹•æ…‹ç”Ÿæˆè³ ç‡
    const config = MARKET_CONFIG[userMarketType] || MARKET_CONFIG.D;
    const dynamicOdds = {
      // å† äºå’Œå€¼è³ ç‡ - ä½¿ç”¨æ–°çš„åŸºç¤è³ ç‡è¡¨
      sumValue: {
        '3': parseFloat((45.0 * (1 - config.rebatePercentage)).toFixed(3)), 
        '4': parseFloat((23.0 * (1 - config.rebatePercentage)).toFixed(3)), 
        '5': parseFloat((15.0 * (1 - config.rebatePercentage)).toFixed(3)), 
        '6': parseFloat((11.5 * (1 - config.rebatePercentage)).toFixed(3)), 
        '7': parseFloat((9.0 * (1 - config.rebatePercentage)).toFixed(3)), 
        '8': parseFloat((7.5 * (1 - config.rebatePercentage)).toFixed(3)), 
        '9': parseFloat((6.5 * (1 - config.rebatePercentage)).toFixed(3)), 
        '10': parseFloat((5.7 * (1 - config.rebatePercentage)).toFixed(3)), 
        '11': parseFloat((5.7 * (1 - config.rebatePercentage)).toFixed(3)), 
        '12': parseFloat((6.5 * (1 - config.rebatePercentage)).toFixed(3)), 
        '13': parseFloat((7.5 * (1 - config.rebatePercentage)).toFixed(3)), 
        '14': parseFloat((9.0 * (1 - config.rebatePercentage)).toFixed(3)), 
        '15': parseFloat((11.5 * (1 - config.rebatePercentage)).toFixed(3)), 
        '16': parseFloat((15.0 * (1 - config.rebatePercentage)).toFixed(3)), 
        '17': parseFloat((23.0 * (1 - config.rebatePercentage)).toFixed(3)),
        '18': parseFloat((45.0 * (1 - config.rebatePercentage)).toFixed(3)), 
        '19': parseFloat((90.0 * (1 - config.rebatePercentage)).toFixed(3)),
        big: config.twoSideOdds, small: config.twoSideOdds, 
        odd: config.twoSideOdds, even: config.twoSideOdds
      },
      // å–®è»Šè™Ÿç¢¼è³ ç‡
      number: {
        first: config.numberOdds, second: config.numberOdds, third: config.numberOdds,
        fourth: config.numberOdds, fifth: config.numberOdds, sixth: config.numberOdds,
        seventh: config.numberOdds, eighth: config.numberOdds, ninth: config.numberOdds,
        tenth: config.numberOdds
      },
      // å„ä½ç½®å¤§å°å–®é›™è³ ç‡
      champion: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
      runnerup: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
      third: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
      fourth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
      fifth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
      sixth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
      seventh: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
      eighth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
      ninth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
      tenth: { big: config.twoSideOdds, small: config.twoSideOdds, odd: config.twoSideOdds, even: config.twoSideOdds },
      // é¾è™è³ ç‡
      dragonTiger: {
        dragon: config.dragonTigerOdds,
        tiger: config.dragonTigerOdds
      }
    };
    
    console.log(`APIè¿”å›éŠæˆ²æ•¸æ“š: æœŸæ•¸=${gameData.currentPeriod}, å€’è¨ˆæ™‚=${gameData.countdownSeconds}, ç‹€æ…‹=${gameData.status}, ç›¤å£=${userMarketType}`);
    
    res.json({
      gameData,
      odds: dynamicOdds,
      marketType: userMarketType // è¿”å›ç›¤å£é¡å‹ä¾›å‰ç«¯ç¢ºèª
    });
  } catch (error) {
    console.error('ç²å–éŠæˆ²æ•¸æ“šå‡ºéŒ¯:', error);
    res.status(500).json({ success: false, message: 'ç²å–éŠæˆ²æ•¸æ“šå¤±æ•—' });
  }
});

// ç²å–ç•¶å‰éŠæˆ²æ•¸æ“š (ä¾›APIå…§éƒ¨ä½¿ç”¨)
async function getGameData() {
  // ä½¿ç”¨å…§å­˜ç‹€æ…‹ï¼Œé¿å…é »ç¹æ•¸æ“šåº«æŸ¥è©¢
  let last_result = memoryGameState.last_result;
  if (typeof last_result === 'string' && last_result) {
    try {
      last_result = JSON.parse(last_result);
    } catch (e) {
      console.error('è§£ælast_resultå‡ºéŒ¯:', e);
      last_result = null;
    }
  }
  
  return {
    period: memoryGameState.current_period,
    countdown: memoryGameState.countdown_seconds,
    lastResult: last_result,
    status: memoryGameState.status
  };
}

// ğŸ¯ æ–°å¢APIï¼šç²å–é å…ˆç”Ÿæˆçš„é–‹ççµæœ
app.get('/api/next-result', (req, res) => {
  try {
    console.log('å‰ç«¯è«‹æ±‚é å…ˆç”Ÿæˆçš„çµæœ...');
    
    // æª¢æŸ¥æ˜¯å¦æœ‰é å…ˆç”Ÿæˆçš„çµæœ
    if (memoryGameState.next_result && Array.isArray(memoryGameState.next_result)) {
      console.log('âœ… è¿”å›é å…ˆç”Ÿæˆçš„çµæœ');
      res.json({
        success: true,
        hasNextResult: true,
        nextResult: memoryGameState.next_result,
        currentPeriod: memoryGameState.current_period,
        countdown: memoryGameState.countdown_seconds,
        status: memoryGameState.status
      });
    } else {
      console.log('âŒ æ²’æœ‰é å…ˆç”Ÿæˆçš„çµæœ');
      res.json({
        success: true,
        hasNextResult: false,
        nextResult: null,
        currentPeriod: memoryGameState.current_period,
        countdown: memoryGameState.countdown_seconds,
        status: memoryGameState.status
      });
    }
  } catch (error) {
    console.error('ç²å–é å…ˆçµæœAPIéŒ¯èª¤:', error);
    res.status(500).json({ 
      success: false, 
      message: 'ç²å–é å…ˆçµæœå¤±æ•—',
      hasNextResult: false,
      nextResult: null
    });
  }
});

// è¼”åŠ©å‡½æ•¸ï¼šè¨ˆç®—çé‡‘ä¸¦ä¿ç•™å…©ä½å°æ•¸
function calculateWinningAmount(amount, odds) {
  return Math.round(amount * odds * 100) / 100;
}

// è¨ˆç®—ä¸‹æ³¨çé‡‘
function calculateWinAmount(bet, winResult) {
  try {
    // æ¯”è³½å°šæœªçµæŸ
    if (!winResult || !Array.isArray(winResult) || winResult.length !== 10) {
      console.error('ç„¡æ•ˆçš„é–‹ççµæœ:', winResult);
      return 0;
    }
    
    // æª¢æŸ¥æŠ•æ³¨é‡‘é¡
    const amount = parseFloat(bet.amount);
    if (isNaN(amount) || amount <= 0) {
      console.error('ç„¡æ•ˆçš„æŠ•æ³¨é‡‘é¡:', bet.amount);
      return 0;
    }
    
    // ç²å–è³ ç‡
    const betOdds = parseFloat(bet.odds);
    if (isNaN(betOdds) || betOdds <= 0) {
      console.error('ç„¡æ•ˆçš„è³ ç‡:', bet.odds);
      return 0;
    }
    
    // å† è»å’Œäºè»çš„å€¼
    const champion = winResult[0];
    const runnerup = winResult[1];
    const sumValue = champion + runnerup;
    
    switch (bet.bet_type) {
      case 'number':
        // è™Ÿç¢¼ç©æ³•
        const position = parseInt(bet.position) || 1;
        const value = parseInt(bet.bet_value);
        
        // æª¢æŸ¥çµæœ
        if (position >= 1 && position <= 10 && value === winResult[position - 1]) {
          return Math.round(amount * betOdds * 100) / 100;
        }
        break;
        
      case 'sumValue':
        // å† äºå’Œå€¼
        const betValue = bet.bet_value;
        
        if (betValue === 'big' && sumValue > 11) {
          return calculateWinningAmount(amount, betOdds);
        } else if (betValue === 'small' && sumValue <= 11) {
          return calculateWinningAmount(amount, betOdds);
        } else if (betValue === 'odd' && sumValue % 2 === 1) {
          return calculateWinningAmount(amount, betOdds);
        } else if (betValue === 'even' && sumValue % 2 === 0) {
          return calculateWinningAmount(amount, betOdds);
        } else if (parseInt(betValue) === sumValue) {
          return calculateWinningAmount(amount, betOdds);
        }
        break;
        
      case 'champion':
        // å† è»æŠ•æ³¨
        if (bet.bet_value === 'big' && champion > 5) {
          return calculateWinningAmount(amount, betOdds);
        } else if (bet.bet_value === 'small' && champion <= 5) {
          return calculateWinningAmount(amount, betOdds);
        } else if (bet.bet_value === 'odd' && champion % 2 === 1) {
          return calculateWinningAmount(amount, betOdds);
        } else if (bet.bet_value === 'even' && champion % 2 === 0) {
          return calculateWinningAmount(amount, betOdds);
        } else if (!isNaN(parseInt(bet.bet_value)) && parseInt(bet.bet_value) === champion) {
          // æŒ‡å®šè™Ÿç¢¼æŠ•æ³¨
          return calculateWinningAmount(amount, betOdds);
        }
        break;
        
      case 'runnerup':
        // äºè»æŠ•æ³¨
        if (bet.bet_value === 'big' && runnerup > 5) {
          return calculateWinningAmount(amount, betOdds);
        } else if (bet.bet_value === 'small' && runnerup <= 5) {
          return calculateWinningAmount(amount, betOdds);
        } else if (bet.bet_value === 'odd' && runnerup % 2 === 1) {
          return calculateWinningAmount(amount, betOdds);
        } else if (bet.bet_value === 'even' && runnerup % 2 === 0) {
          return calculateWinningAmount(amount, betOdds);
        } else if (!isNaN(parseInt(bet.bet_value)) && parseInt(bet.bet_value) === runnerup) {
          // æŒ‡å®šè™Ÿç¢¼æŠ•æ³¨
          return calculateWinningAmount(amount, betOdds);
        }
        break;
        
      case 'dragonTiger':
        // é¾è™æŠ•æ³¨ - æ”¯æ´å‚³çµ±æ ¼å¼å’Œä½ç½®å°æ¯”æ ¼å¼
        let dragonTigerType, pos1, pos2;
        
        if (bet.bet_value === 'dragon' || bet.bet_value === 'tiger') {
          // å‚³çµ±æ ¼å¼ï¼šé»˜èªå† è»vsäºè»
          dragonTigerType = bet.bet_value;
          pos1 = 0; // å† è»
          pos2 = 1; // äºè»
        } else if (typeof bet.bet_value === 'string' && 
                   (bet.bet_value.startsWith('dragon_') || bet.bet_value.startsWith('tiger_'))) {
          // è¤‡é›œæ ¼å¼ï¼šdragon_5_6 è¡¨ç¤ºç¬¬5åvsç¬¬6å
          const parts = bet.bet_value.split('_');
          if (parts.length === 3) {
            dragonTigerType = parts[0];
            pos1 = parseInt(parts[1]) - 1; // è½‰ç‚º0-9ç´¢å¼•
            pos2 = parseInt(parts[2]) - 1;
            
            // é©—è­‰ä½ç½®æœ‰æ•ˆæ€§
            if (isNaN(pos1) || isNaN(pos2) || pos1 < 0 || pos1 > 9 || pos2 < 0 || pos2 > 9 || pos1 === pos2) {
              console.warn(`âš ï¸ é¾è™çµç®—ï¼šç„¡æ•ˆçš„æŠ•æ³¨æ ¼å¼: ${bet.bet_value}`);
              break;
            }
          } else {
            console.warn(`âš ï¸ é¾è™çµç®—ï¼šç„¡æ³•è§£ææŠ•æ³¨æ ¼å¼: ${bet.bet_value}`);
            break;
          }
        } else {
          console.warn(`âš ï¸ é¾è™çµç®—ï¼šæœªçŸ¥çš„æŠ•æ³¨æ ¼å¼: ${bet.bet_value}`);
          break;
        }
        
        // ç²å–å°æ‡‰ä½ç½®çš„é–‹çè™Ÿç¢¼
        const pos1Value = winResult[pos1];
        const pos2Value = winResult[pos2];
        
        console.log(`ğŸ‰ğŸ… é¾è™çµç®—æª¢æŸ¥: ${bet.bet_value}, ç¬¬${pos1+1}å=${pos1Value}, ç¬¬${pos2+1}å=${pos2Value}`);
        
        // åˆ¤æ–·é¾è™çµæœ
        if (dragonTigerType === 'dragon' && pos1Value > pos2Value) {
          console.log(`âœ… é¾è™ä¸­ç: é¾å‹ (${pos1Value} > ${pos2Value})`);
          return calculateWinningAmount(amount, betOdds);
        } else if (dragonTigerType === 'tiger' && pos1Value < pos2Value) {
          console.log(`âœ… é¾è™ä¸­ç: è™å‹ (${pos1Value} < ${pos2Value})`);
          return calculateWinningAmount(amount, betOdds);
        } else {
          console.log(`âŒ é¾è™æœªä¸­ç: æŠ•æ³¨${dragonTigerType}, å¯¦éš›${pos1Value > pos2Value ? 'é¾' : pos1Value < pos2Value ? 'è™' : 'å’Œ'}å‹`);
        }
        break;
        
      case 'position':
        // å¿«é€ŸæŠ•æ³¨ - ä½ç½®æŠ•æ³¨
        const position_num = parseInt(bet.position) || 1;
        if (position_num >= 1 && position_num <= 10) {
          const ballValue = winResult[position_num - 1];
          
          if (bet.bet_value === 'big' && ballValue > 5) {
            return calculateWinningAmount(amount, betOdds);
          } else if (bet.bet_value === 'small' && ballValue <= 5) {
            return calculateWinningAmount(amount, betOdds);
          } else if (bet.bet_value === 'odd' && ballValue % 2 === 1) {
            return calculateWinningAmount(amount, betOdds);
          } else if (bet.bet_value === 'even' && ballValue % 2 === 0) {
            return calculateWinningAmount(amount, betOdds);
          }
        }
        break;
        
      default:
        // å…¶ä»–ä½ç½®çš„å¤§å°å–®é›™
        const posMap = {
          'third': 2, 'fourth': 3, 'fifth': 4, 
          'sixth': 5, 'seventh': 6, 'eighth': 7, 
          'ninth': 8, 'tenth': 9
        };
        
        if (posMap[bet.bet_type]) {
          const pos = posMap[bet.bet_type];
          const ballValue = winResult[pos];
          
          if (bet.bet_value === 'big' && ballValue > 5) {
            return calculateWinningAmount(amount, betOdds);
          } else if (bet.bet_value === 'small' && ballValue <= 5) {
            return calculateWinningAmount(amount, betOdds);
          } else if (bet.bet_value === 'odd' && ballValue % 2 === 1) {
            return calculateWinningAmount(amount, betOdds);
          } else if (bet.bet_value === 'even' && ballValue % 2 === 0) {
            return calculateWinningAmount(amount, betOdds);
          } else if (!isNaN(parseInt(bet.bet_value)) && parseInt(bet.bet_value) === ballValue) {
            // æŒ‡å®šè™Ÿç¢¼æŠ•æ³¨
            return calculateWinningAmount(amount, betOdds);
          }
        }
        break;
    }
    
    // æœªä¸­ç
    return 0;
  } catch (error) {
    console.error('è¨ˆç®—çé‡‘æ™‚å‡ºéŒ¯:', error);
    return 0;
  }
}

// ç²å–æ­·å²é–‹ççµæœ
app.get('/api/history', async (req, res) => {
  try {
    console.log('æ”¶åˆ°é–‹çæ­·å²æŸ¥è©¢è«‹æ±‚:', req.query);
    
    const { page = 1, limit = 20, period = '', date = '' } = req.query;
    const pageNumber = parseInt(page);
    const pageSize = parseInt(limit);
    
    // æ§‹å»ºæŸ¥è©¢æ¢ä»¶
    let whereClause = '';
    let params = [];
    let conditions = [];
    
    // æœŸæ•¸ç¯©é¸
    if (period) {
      conditions.push('period::text LIKE $' + (params.length + 1));
      params.push(`%${period}%`);
    }
    
    // æ—¥æœŸç¯©é¸
    if (date) {
      conditions.push('DATE(created_at) = $' + (params.length + 1));
      params.push(date);
    }
    
    if (conditions.length > 0) {
      whereClause = 'WHERE ' + conditions.join(' AND ');
    }
    
    console.log('æŸ¥è©¢æ¢ä»¶:', { whereClause, params });
    
    try {
      // è¨ˆç®—ç¸½è¨˜éŒ„æ•¸
      const countQuery = `SELECT COUNT(*) as total FROM result_history ${whereClause}`;
      console.log('åŸ·è¡Œè¨ˆæ•¸æŸ¥è©¢:', countQuery);
      const countResult = await db.one(countQuery, params);
      const totalRecords = parseInt(countResult.total);
      const totalPages = Math.ceil(totalRecords / pageSize);
      
      // ç²å–åˆ†é æ•¸æ“š
      const offset = (pageNumber - 1) * pageSize;
      const query = `
        SELECT period, result, created_at 
        FROM result_history 
        ${whereClause} 
        ORDER BY created_at DESC 
        LIMIT ${pageSize} OFFSET ${offset}
      `;
      console.log('åŸ·è¡ŒæŸ¥è©¢:', query);
      const results = await db.any(query, params);
    
    // è½‰æ›æ ¼å¼ä½¿å…¶èˆ‡å‰ç«¯ç›¸å®¹
    const formattedResults = results.map(record => {
      let result = record.result;
      if (typeof result === 'string') {
        result = JSON.parse(result);
      }
      
      return {
        period: record.period,
        result,
        time: record.created_at
      };
    });
    
      res.json({
        success: true,
        records: formattedResults,
        totalPages,
        currentPage: pageNumber,
        totalRecords
      });
    } catch (dbError) {
      console.error('è³‡æ–™åº«æŸ¥è©¢éŒ¯èª¤:', dbError);
      throw new Error(`è³‡æ–™åº«æŸ¥è©¢éŒ¯èª¤: ${dbError.message}`);
    }
  } catch (error) {
    console.error('ç²å–æ­·å²é–‹ççµæœå‡ºéŒ¯:', error);
    res.status(500).json({ 
      success: false, 
      message: 'ç²å–æ­·å²é–‹ççµæœå¤±æ•—',
      error: error.message
    });
  }
});

// ç²å–ä¸‹æ³¨è¨˜éŒ„API
app.get('/api/bet-history', async (req, res) => {
  try {
    console.log('æ”¶åˆ°ä¸‹æ³¨è¨˜éŒ„æŸ¥è©¢è«‹æ±‚:', req.query);
    
    const { username, page = 1, limit = 20, period = '', date = '' } = req.query;
    const pageNumber = parseInt(page);
    const pageSize = parseInt(limit);
    
    if (!username) {
      return res.status(400).json({
        success: false,
        message: 'æœªæä¾›ç”¨æˆ¶å'
      });
    }
    
    // æ§‹å»ºæŸ¥è©¢æ¢ä»¶
    let whereClause = 'WHERE username = $1';
    let params = [username];
    
    // æœŸæ•¸ç¯©é¸
    if (period) {
      whereClause += ' AND period::text LIKE $' + (params.length + 1);
      params.push(`%${period}%`);
    }
    
    // æ—¥æœŸç¯©é¸
    if (date) {
      whereClause += ' AND DATE(created_at) = $' + (params.length + 1);
      params.push(date);
    }
    
    console.log('æŸ¥è©¢æ¢ä»¶:', { whereClause, params });
    
    try {
      // è¨ˆç®—ç¸½è¨˜éŒ„æ•¸
      const countQuery = `SELECT COUNT(*) as total FROM bet_history ${whereClause}`;
      console.log('åŸ·è¡Œè¨ˆæ•¸æŸ¥è©¢:', countQuery);
      const countResult = await db.one(countQuery, params);
      const totalRecords = parseInt(countResult.total);
      const totalPages = Math.ceil(totalRecords / pageSize);
      
      // ç²å–åˆ†é æ•¸æ“š
      const offset = (pageNumber - 1) * pageSize;
      const query = `
        SELECT 
          id, 
          username, 
          amount, 
          bet_type as "betType", 
          bet_value as "value", 
          position, 
          period, 
          odds,
          created_at as "time", 
          win, 
          win_amount as "winAmount", 
          settled
        FROM bet_history 
        ${whereClause} 
        ORDER BY created_at DESC 
        LIMIT ${pageSize} OFFSET ${offset}
      `;
      console.log('åŸ·è¡ŒæŸ¥è©¢:', query);
      const results = await db.any(query, params);
      
      // æ ¼å¼åŒ–çµæœï¼Œç¢ºä¿å‰ç«¯å¯ä»¥ç›´æ¥ä½¿ç”¨
      const formattedResults = results.map(bet => ({
        id: bet.id,
        username: bet.username,
        amount: bet.amount,
        betType: bet.betType,
        value: bet.value,
        position: bet.position,
        period: bet.period,
        odds: parseFloat(bet.odds) || 1.0,
        time: bet.time,
        win: bet.win,
        winAmount: bet.winAmount,
        settled: bet.settled
      }));
      
      res.json({
        success: true,
        records: formattedResults,
        totalPages,
        currentPage: pageNumber,
        totalRecords
      });
    } catch (dbError) {
      console.error('è³‡æ–™åº«æŸ¥è©¢éŒ¯èª¤:', dbError);
      throw new Error(`è³‡æ–™åº«æŸ¥è©¢éŒ¯èª¤: ${dbError.message}`);
    }
  } catch (error) {
    console.error('ç²å–ä¸‹æ³¨è¨˜éŒ„å‡ºéŒ¯:', error);
    res.status(500).json({ 
      success: false, 
      message: 'ç²å–ä¸‹æ³¨è¨˜éŒ„å¤±æ•—',
      error: error.message,
      records: [] // ç¢ºä¿å³ä½¿éŒ¯èª¤ä¹Ÿè¿”å›ç©ºæ•¸çµ„
    });
  }
});

// èˆŠçš„ç™»å…¥ç«¯é»å·²ç§»é™¤ï¼Œçµ±ä¸€ä½¿ç”¨ /api/member/login

// æ›´æ–°ä¸‹æ³¨è™•ç†é‚è¼¯
app.post('/api/bet', async (req, res) => {
  try {
    // é©—è­‰å¿…è¦åƒæ•¸
    const { username, amount, betType, value, position } = req.body;
    
    console.log(`æ”¶åˆ°ä¸‹æ³¨è«‹æ±‚: ç”¨æˆ¶=${username}, é‡‘é¡=${amount}, é¡å‹=${betType}, å€¼=${value}, ä½ç½®=${position || 'N/A'}`);
    
    if (!username || !amount || !betType || !value) {
      console.error('ä¸‹æ³¨å¤±æ•—: è«‹æä¾›å®Œæ•´çš„ä¸‹æ³¨ä¿¡æ¯');
      return res.status(400).json({ success: false, message: 'è«‹æä¾›å®Œæ•´çš„ä¸‹æ³¨ä¿¡æ¯' });
    }
    
    // æª¢æŸ¥åƒæ•¸æœ‰æ•ˆæ€§
    const amountNum = parseFloat(amount);
    if (isNaN(amountNum) || amountNum <= 0) {
      console.error('ä¸‹æ³¨å¤±æ•—: ç„¡æ•ˆçš„ä¸‹æ³¨é‡‘é¡');
      return res.status(400).json({ success: false, message: 'ç„¡æ•ˆçš„ä¸‹æ³¨é‡‘é¡' });
    }
    
    // æª¢æŸ¥æœ€ä½æŠ•æ³¨é‡‘é¡é™åˆ¶ï¼ˆé˜²æ­¢å°é¡å¥—åˆ©ï¼‰
    const MIN_BET_AMOUNT = 1;
    if (amountNum < MIN_BET_AMOUNT) {
              console.error(`ä¸‹æ³¨å¤±è´¥: æŠ•æ³¨é‡‘é¢ä¸èƒ½å°‘äº ${MIN_BET_AMOUNT} å…ƒ`);
        return res.status(400).json({ success: false, message: `æŠ•æ³¨é‡‘é¢ä¸èƒ½å°‘äº ${MIN_BET_AMOUNT} å…ƒ` });
    }
    
    // æª¢æŸ¥ä¸‹æ³¨é¡å‹å’Œé¸é …çš„æœ‰æ•ˆæ€§
    if (!isValidBet(betType, value, position)) {
      console.error(`ä¸‹æ³¨å¤±æ•—: ç„¡æ•ˆçš„ä¸‹æ³¨é¸é … ${betType}=${value}`);
      return res.status(400).json({ success: false, message: 'ç„¡æ•ˆçš„ä¸‹æ³¨é¸é …' });
    }
    
    // ç²å–ç•¶å‰éŠæˆ²ç‹€æ…‹
    const gameState = await getGameData();
    const { period, status } = gameState;
    
    // æª¢æŸ¥éŠæˆ²ç‹€æ…‹
    if (status !== 'betting') {
      console.error('ä¸‹æ³¨å¤±æ•—: ç•¶å‰ä¸æ˜¯ä¸‹æ³¨éšæ®µ');
      return res.status(400).json({ success: false, message: 'ç•¶å‰ä¸æ˜¯ä¸‹æ³¨éšæ®µ' });
    }
    
    // ç²å–è³ ç‡ï¼ˆæš«æ™‚ä½¿ç”¨é»˜èªDç›¤ï¼Œæœƒåœ¨æœƒå“¡ä¿¡æ¯æª¢æŸ¥å¾Œæ›´æ–°ï¼‰
    let odds = getOdds(betType, value, 'D');
    console.log(`åˆå§‹ä¸‹æ³¨è³ ç‡: ${odds}`);
    
    try {
      // ç²å–ç¸½ä»£ç†ID
      const adminAgent = await getAdminAgentId();
      if (!adminAgent) {
        console.error('ä¸‹æ³¨å¤±æ•—: æ‰¾ä¸åˆ°ç¸½ä»£ç†å¸³æˆ¶');
        return res.status(500).json({ success: false, message: 'ç³»çµ±éŒ¯èª¤ï¼šæ‰¾ä¸åˆ°ç¸½ä»£ç†å¸³æˆ¶' });
      }
      
      console.log(`ä½¿ç”¨ç¸½ä»£ç† ID: ${adminAgent.id}, ç”¨æˆ¶å: ${adminAgent.username}`);
      
      // é¦–å…ˆæ£€æŸ¥ä¼šå‘˜çŠ¶æ€å’Œç›¤å£ä¿¡æ¯
      let memberMarketType = 'D'; // é»˜èªDç›¤
      try {
        console.log(`æ£€æŸ¥ä¼šå‘˜ ${username} çŠ¶æ€å’Œç›¤å£ä¿¡æ¯`);
        
        // è°ƒç”¨ä»£ç†ç³»ç»ŸAPIæ£€æŸ¥ä¼šå‘˜çŠ¶æ€
        const memberResponse = await fetch(`${AGENT_API_URL}/api/agent/member/info/${username}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (memberResponse.ok) {
          const memberData = await memberResponse.json();
          
          if (memberData.success && memberData.member) {
            // æ£€æŸ¥ä¼šå‘˜çŠ¶æ€ï¼š0=åœç”¨, 1=å¯ç”¨, 2=å‡çµ
            if (memberData.member.status === 0) {
              console.error(`ä¼šå‘˜ ${username} å·²è¢«åœç”¨`);
              return res.status(400).json({ success: false, message: 'å¸å·å·²è¢«åœç”¨ï¼Œè¯·è”ç³»å®¢æœ' });
            } else if (memberData.member.status === 2) {
              console.error(`ä¼šå‘˜ ${username} å·²è¢«å‡çµ`);
              return res.status(400).json({ success: false, message: 'å¸å·å·²è¢«å‡çµï¼Œåªèƒ½è§‚çœ‹æ¸¸æˆæ— æ³•ä¸‹æ³¨' });
            }
            
            // ç²å–æœƒå“¡ç›¤å£é¡å‹
            memberMarketType = memberData.member.market_type || 'D';
            console.log(`ä¼šå‘˜ ${username} ç›¤å£é¡å‹: ${memberMarketType}`);
          }
        }
      } catch (statusError) {
        console.warn('æ£€æŸ¥ä¼šå‘˜çŠ¶æ€å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨åŸæœ‰é€»è¾‘:', statusError.message);
      }
      
      // ç²å–ç”¨æˆ¶ç•¶å‰æœŸæŠ•æ³¨è¨˜éŒ„ï¼Œç”¨æ–¼é™ç´…æª¢æŸ¥
      let userCurrentBets = [];
      try {
        const existingBets = await BetModel.findByUserAndPeriod(username, period);
        userCurrentBets = existingBets || [];
      } catch (betError) {
        console.warn('è·å–ç”¨æˆ·å½“æœŸæŠ•æ³¨è®°å½•å¤±è´¥:', betError.message);
      }
      
             // é™ç´…é©—è­‰
       const limitCheck = await validateBetLimits(betType, value, amountNum, userCurrentBets, username);
       if (!limitCheck.valid) {
         console.error(`é™ç´…é©—è­‰å¤±æ•—: ${limitCheck.message}`);
         return res.status(400).json({ success: false, message: limitCheck.message });
       }
       
       // æ ¹æ“šæœƒå“¡ç›¤å£é¡å‹é‡æ–°è¨ˆç®—è³ ç‡
       odds = getOdds(betType, value, memberMarketType);
       console.log(`æ ¹æ“šç›¤å£ ${memberMarketType} èª¿æ•´å¾Œè³ ç‡: ${odds}`);

      // ä½¿ç”¨ä»£ç†ç³»çµ±æª¢æŸ¥å’Œæ‰£é™¤æœƒå“¡é¤˜é¡
      let updatedBalance;
      try {
        console.log(`å˜—è©¦å¾ä»£ç†ç³»çµ±æ‰£é™¤æœƒå“¡ ${username} é¤˜é¡ ${amountNum} å…ƒ`);
        
        // èª¿ç”¨ä»£ç†ç³»çµ±APIæ‰£é™¤é¤˜é¡
        const deductResponse = await fetch(`${AGENT_API_URL}/api/agent/deduct-member-balance`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            username: username,
            amount: amountNum,
            reason: 'éŠæˆ²ä¸‹æ³¨'
          })
        });
        
        const deductData = await deductResponse.json();
        
        if (!deductData.success) {
          console.error(`ä»£ç†ç³»çµ±æ‰£é™¤é¤˜é¡å¤±æ•—: ${deductData.message}`);
          return res.status(400).json({ success: false, message: deductData.message || 'ä½™é¢ä¸è¶³' });
        }
        
        updatedBalance = deductData.balance;
        console.log(`ç”¨æˆ¶ ${username} ä¸‹æ³¨ ${amountNum} å…ƒå¾Œé¤˜é¡: ${updatedBalance}`);
        
        // åŒæ­¥é¤˜é¡åˆ°æœ¬åœ°usersè¡¨ï¼ˆä¿æŒå…¼å®¹æ€§ï¼‰
        try {
          await UserModel.createOrUpdate({ username: username, balance: updatedBalance });
        } catch (syncError) {
          console.warn('åŒæ­¥é¤˜é¡åˆ°æœ¬åœ°usersè¡¨å¤±æ•—:', syncError);
        }
        
      } catch (balanceError) {
        console.error(`ä¸‹æ³¨å¤±æ•—: ${balanceError.message}`);
        return res.status(400).json({ success: false, message: 'é¤˜é¡æª¢æŸ¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' });
      }
      
      // é¤˜é¡å·²ç”±ä»£ç†ç³»çµ±è™•ç†ï¼Œç„¡éœ€é‡è¤‡åŒæ­¥
      
      // æº–å‚™ä¸‹æ³¨æ•¸æ“š
      // è™•ç† position è½‰æ›
      let positionValue = null;
      if (position) {
        // å¦‚æœ position æ˜¯å­—ä¸²ï¼ˆå¦‚ "champion"ï¼‰ï¼Œè½‰æ›ç‚ºå°æ‡‰çš„æ•¸å­—
        const positionMap = {
          'champion': 1,
          'runnerup': 2,
          'third': 3,
          'fourth': 4,
          'fifth': 5,
          'sixth': 6,
          'seventh': 7,
          'eighth': 8,
          'ninth': 9,
          'tenth': 10
        };
        
        if (typeof position === 'string' && positionMap[position]) {
          positionValue = positionMap[position];
        } else if (!isNaN(parseInt(position))) {
          positionValue = parseInt(position);
        }
      }
      
      const betData = {
        username: username,
        amount: amountNum,
        bet_type: betType,  // æ³¨æ„: é€™è£¡ä½¿ç”¨ bet_type è€Œä¸æ˜¯ betType
        bet_value: value,   // æ³¨æ„: é€™è£¡ä½¿ç”¨ bet_value è€Œä¸æ˜¯ value
        position: positionValue,
        period: period,
        odds: odds
      };
      
      console.log('æº–å‚™å‰µå»ºä¸‹æ³¨è¨˜éŒ„:', JSON.stringify(betData));
      
      // å˜—è©¦å‰µå»ºä¸‹æ³¨è¨˜éŒ„
      let betResult;
      try {
        // ä½¿ç”¨BetModelå‰µå»ºä¸‹æ³¨è¨˜éŒ„
        betResult = await BetModel.create(betData);
        console.log(`å‰µå»ºäº†ä¸€å€‹æ–°çš„ä¸‹æ³¨è¨˜éŒ„: ID=${betResult.id}`);
      } catch (dbError) {
        console.error('å‰µå»ºä¸‹æ³¨è¨˜éŒ„å¤±æ•—:', dbError);
        // å¦‚æœè¨˜éŒ„å‰µå»ºå¤±æ•—ï¼Œè¿”é‚„ç”¨æˆ¶é¤˜é¡
        await UserModel.addBalance(username, amountNum);
        return res.status(500).json({ success: false, message: `å‰µå»ºä¸‹æ³¨è¨˜éŒ„å¤±æ•—: ${dbError.message}` });
      }
      
      // ç§»é™¤ç«‹å³é€€æ°´åˆ†é… - é€€æ°´å°‡åœ¨çµç®—éšæ®µè™•ç†
      console.log(`ç”¨æˆ¶ ${username} ä¸‹æ³¨ ${amountNum} å…ƒæˆåŠŸï¼Œé€€æ°´å°‡åœ¨çµç®—å¾Œåˆ†é…`);
      
      console.log(`ç”¨æˆ¶ ${username} ä¸‹æ³¨ ${amountNum} å…ƒï¼Œé¡å‹ï¼š${betType}ï¼Œå€¼ï¼š${value}ï¼Œä½ç½®ï¼š${position || 'N/A'}`);
      console.log(`ç”¨æˆ¶ ${username} ä¸‹æ³¨ ${amountNum} å…ƒå¾Œé¤˜é¡æ›´æ–°ç‚º: ${updatedBalance}`);
      
      // ç›´æ¥ä½¿ç”¨ä»£ç†ç³»çµ±è¿”å›çš„é¤˜é¡ï¼Œé¿å…é‡æ–°æŸ¥è©¢å°è‡´ç«¶æ…‹æ¢ä»¶
      return res.json({ 
        success: true, 
        message: 'ä¸‹æ³¨æˆåŠŸ', 
        betId: betResult.id, 
        balance: updatedBalance.toString() 
      });
    } catch (innerError) {
      console.error('ä¸‹æ³¨è™•ç†éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤:', innerError);
      return res.status(500).json({ success: false, message: `ç³»çµ±éŒ¯èª¤: ${innerError.message}` });
    }
    
  } catch (error) {
    console.error('ä¸‹æ³¨è™•ç†éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤:', error);
    return res.status(500).json({ success: false, message: `ç³»çµ±éŒ¯èª¤: ${error.message}` });
  }
});

// é©—è­‰ä¸‹æ³¨æ˜¯å¦æœ‰æ•ˆ
function isValidBet(betType, value, position) {
  // æª¢æŸ¥ä¸‹æ³¨é¡å‹
  const validBetTypes = [
    'sumValue', 'champion', 'runnerup', 'third', 'fourth', 'fifth', 
    'sixth', 'seventh', 'eighth', 'ninth', 'tenth', 'dragonTiger', 'number', 'position'
  ];
  
  if (!validBetTypes.includes(betType)) {
    return false;
  }
  
  // æª¢æŸ¥æ•¸å€¼
  if (betType === 'number') {
    // å°æ–¼å–®è™ŸæŠ•æ³¨ï¼Œéœ€è¦æª¢æŸ¥æ•¸å­—å’Œä½ç½®
    if (!position || position < 1 || position > 10) {
      return false;
    }
    
    const numValue = parseInt(value);
    if (isNaN(numValue) || numValue < 1 || numValue > 10) {
      return false;
    }
    
    return true;
  } else if (betType === 'sumValue') {
    // å°æ–¼å† äºå’Œå€¼ï¼Œæª¢æŸ¥æ˜¯å¦ç‚ºæœ‰æ•ˆçš„å’Œå€¼æˆ–å¤§å°å–®é›™
    const validValues = ['big', 'small', 'odd', 'even', '3', '4', '5', '6', '7', 
                          '8', '9', '10', '11', '12', '13', '14', '15', '16', 
                          '17', '18', '19'];
    return validValues.includes(value.toString());
  } else if (betType === 'dragonTiger') {
    // é¾è™æŠ•æ³¨ï¼Œæ”¯æŒç°¡å–®æ ¼å¼ï¼ˆdragon, tigerï¼‰å’Œè¤‡é›œæ ¼å¼ï¼ˆdragon_1_10, tiger_2_9ç­‰ï¼‰
    if (value === 'dragon' || value === 'tiger') {
      return true;
    }
    
    // æª¢æŸ¥è¤‡é›œæ ¼å¼ï¼šdragon_pos1_pos2 æˆ– tiger_pos1_pos2
    if (typeof value === 'string' && (value.startsWith('dragon_') || value.startsWith('tiger_'))) {
      const parts = value.split('_');
      if (parts.length === 3) {
        const pos1 = parseInt(parts[1]);
        const pos2 = parseInt(parts[2]);
        // ä½ç½®å¿…é ˆåœ¨1-10ä¹‹é–“ä¸”ä¸ç›¸ç­‰
        return !isNaN(pos1) && !isNaN(pos2) && 
               pos1 >= 1 && pos1 <= 10 && 
               pos2 >= 1 && pos2 <= 10 && 
               pos1 !== pos2;
      }
    }
    
    return false;
  } else if (['champion', 'runnerup', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth'].includes(betType)) {
    // ä½ç½®æŠ•æ³¨ï¼šæ”¯æ´å¤§å°å–®é›™ AND æŒ‡å®šè™Ÿç¢¼(1-10)
    const validPropertyValues = ['big', 'small', 'odd', 'even'];
    if (validPropertyValues.includes(value)) {
      return true; // å¤§å°å–®é›™æŠ•æ³¨
    }
    
    // æª¢æŸ¥æ˜¯å¦ç‚ºæœ‰æ•ˆçš„è™Ÿç¢¼æŠ•æ³¨(1-10)
    const numValue = parseInt(value);
    return !isNaN(numValue) && numValue >= 1 && numValue <= 10;
  } else if (betType === 'position') {
    // å¿«é€ŸæŠ•æ³¨ï¼šä½ç½®æŠ•æ³¨ï¼Œæ”¯æ´å¤§å°å–®é›™å±¬æ€§
    const validPropertyValues = ['big', 'small', 'odd', 'even'];
    if (validPropertyValues.includes(value)) {
      // æª¢æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆ(1-10)
      return position && !isNaN(parseInt(position)) && parseInt(position) >= 1 && parseInt(position) <= 10;
    }
    return false;
  }
  
  return false;
}

// é‡è¤‡çš„createBetå‡½æ•¸å·²ç§»é™¤ï¼Œçµ±ä¸€ä½¿ç”¨BetModel.create

// æ–°å¢: ç²å–ç¸½ä»£ç†IDçš„å‡½æ•¸
async function getAdminAgentId() {
  try {
    // å¾ä»£ç†ç³»çµ±ç²å–ç¸½ä»£ç†ID
    const response = await fetch(`${AGENT_API_URL}/api/agent/admin-agent`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    const data = await response.json();
    
    if (data.success) {
      return { id: data.agent.id, username: data.agent.username };
    } else {
      console.error('ç²å–ç¸½ä»£ç†IDå¤±æ•—:', data.message);
      // è¿”å›æœ¬åœ°é»˜èªç¸½ä»£ç†
      console.log('ä½¿ç”¨æœ¬åœ°é»˜èªç¸½ä»£ç†ID');
      return { id: 1, username: 'admin' };
    }
  } catch (error) {
    console.error('ç²å–ç¸½ä»£ç†IDå‡ºéŒ¯:', error);
    // å‡ºéŒ¯æ™‚ä¹Ÿè¿”å›æœ¬åœ°é»˜èªç¸½ä»£ç†
    console.log('é€£æ¥ä»£ç†ç³»çµ±å¤±æ•—ï¼Œä½¿ç”¨æœ¬åœ°é»˜èªç¸½ä»£ç†ID');
    return { id: 1, username: 'admin' };
  }
}

// åˆå§‹åŒ–æ•¸æ“šåº«ä¸¦å•Ÿå‹•æœå‹™å™¨
async function startServer() {
  try {
    // åˆå§‹åŒ–æ•¸æ“šåº«
    await initDatabase();
    
    // ç¢ºä¿æ•¸æ“šåº«ç´„æŸæ­£ç¢ºè¨­ç½®
    await ensureDatabaseConstraints();
    
    // åˆå§‹åŒ–çµç®—ç›¸é—œè¡¨
    console.log('ğŸ”§ åˆå§‹åŒ–çµç®—ç³»çµ±è¡¨...');
    await createSettlementTables();
    
    // åˆå§‹åŒ–æœƒè©±ç®¡ç†ç³»çµ±
    await SessionManager.initialize();
    
    console.log('é–‹å§‹åˆå§‹åŒ–ç†±é–€æŠ•æ³¨æ•¸æ“š...');
    // æ›´æ–°ç†±é–€æŠ•æ³¨æ•¸æ“š
    try {
      await updateHotBets();
      console.log('ç†±é–€æŠ•æ³¨æ•¸æ“šåˆå§‹åŒ–æˆåŠŸ');
    } catch (hotBetsError) {
      console.error('åˆå§‹åŒ–ç†±é–€æŠ•æ³¨æ•¸æ“šæ™‚å‡ºéŒ¯:', hotBetsError);
    }
    
    // è¨­ç½®å®šæ™‚æ›´æ–°ç†±é–€æŠ•æ³¨ï¼ˆæ¯10åˆ†é˜ï¼‰
    hotBetsInterval = setInterval(async () => {
      try {
        console.log('å®šæ™‚æ›´æ–°ç†±é–€æŠ•æ³¨æ•¸æ“š...');
        await updateHotBets();
      } catch (error) {
        console.error('å®šæ™‚æ›´æ–°ç†±é–€æŠ•æ³¨æ•¸æ“šæ™‚å‡ºéŒ¯:', error);
      }
    }, 10 * 60 * 1000);
    
    // å•Ÿå‹•æœå‹™å™¨
    app.listen(port, () => {
      console.log(`æ¥µé€Ÿè³½è»ŠéŠæˆ²æœå‹™é‹è¡Œåœ¨ç«¯å£ ${port}`);
      console.log(`NODE_ENV: ${process.env.NODE_ENV || 'development'}`);
      console.log(`API Base URL: ${AGENT_API_URL}`);
      
      // ç¢ºèªç†±é–€æŠ•æ³¨APIç«¯é»å¯ç”¨
      console.log('å·²è¨»å†Š API ç«¯é»: /api/hot-bets');
      
      // å•Ÿå‹•éŠæˆ²å¾ªç’°
      startGameCycle();
    });
  } catch (error) {
    console.error('å•Ÿå‹•æœå‹™å™¨æ™‚å‡ºéŒ¯:', error);
  }
}

// å•Ÿå‹•æœå‹™å™¨
startServer();

// é™ç´…é©—è­‰å‡½æ•¸ - æ”¯æ´å‹•æ…‹é™ç´…é…ç½®
async function validateBetLimits(betType, value, amount, userBets = [], username = null) {
  let limits;
  
  // å¦‚æœæä¾›äº†ç”¨æˆ¶åï¼Œå˜—è©¦å¾ä»£ç†ç³»çµ±ç²å–æœƒå“¡çš„é™ç´…è¨­å®š
  if (username) {
    try {
      const response = await fetch(`${AGENT_API_URL}/api/agent/member-betting-limit-by-username?username=${username}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.config) {
          const userConfig = data.config;
          
          // æ ¹æ“šæŠ•æ³¨é¡å‹ç¢ºå®šé™ç´…é…ç½®
          if (betType === 'dragonTiger') {
            limits = userConfig.dragonTiger;
          } else if (betType === 'sumValue') {
            if (['big', 'small'].includes(value)) {
              limits = userConfig.sumValueSize;
            } else if (['odd', 'even'].includes(value)) {
              limits = userConfig.sumValueOddEven;
            } else {
              limits = userConfig.sumValue;
            }
          } else if (betType === 'number' || (
            ['champion', 'runnerup', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth'].includes(betType) && 
            !['big', 'small', 'odd', 'even'].includes(value)
          )) {
            limits = userConfig.number;
          } else if (
            ['champion', 'runnerup', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth', 'position'].includes(betType) && 
            ['big', 'small', 'odd', 'even'].includes(value)
          ) {
            limits = userConfig.twoSide;
          } else {
            limits = userConfig.twoSide;
          }
        }
      }
    } catch (error) {
      console.warn('ç²å–æœƒå“¡é™ç´…è¨­å®šå¤±æ•—ï¼Œä½¿ç”¨é è¨­é™ç´…:', error);
    }
  }
  
  // å¦‚æœæ²’æœ‰ç²å–åˆ°ç”¨æˆ¶é™ç´…è¨­å®šï¼Œä½¿ç”¨é è¨­é…ç½®
  if (!limits) {
    // æ ¹æ“šæŠ•æ³¨é¡å‹ç¢ºå®šé è¨­é™ç´…é…ç½®
    if (betType === 'dragonTiger') {
      // é¾è™æŠ•æ³¨ - 5000/5000
      limits = BET_LIMITS.dragonTiger;
    } else if (betType === 'sumValue') {
      // å† äºè»å’Œå€¼æŠ•æ³¨
      if (['big', 'small'].includes(value)) {
        // å† äºè»å’Œå¤§å° - 5000/5000
        limits = BET_LIMITS.sumValueSize;
      } else if (['odd', 'even'].includes(value)) {
        // å† äºè»å’Œå–®é›™ - 5000/5000
        limits = BET_LIMITS.sumValueOddEven;
      } else {
        // å† äºè»å’Œå€¼ - 1000/2000
        limits = BET_LIMITS.sumValue;
      }
    } else if (betType === 'number' || (
      ['champion', 'runnerup', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth'].includes(betType) && 
      !['big', 'small', 'odd', 'even'].includes(value)
    )) {
      // 1-10è»Šè™ŸæŠ•æ³¨ - 2500/5000
      limits = BET_LIMITS.number;
    } else if (
      ['champion', 'runnerup', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth', 'position'].includes(betType) && 
      ['big', 'small', 'odd', 'even'].includes(value)
    ) {
      // å…©é¢æŠ•æ³¨ï¼ˆå¤§å°å–®é›™ï¼‰- 5000/5000
      limits = BET_LIMITS.twoSide;
    } else {
      // å…¶ä»–æƒ…æ³ä½¿ç”¨å…©é¢é™é¡
      limits = BET_LIMITS.twoSide;
    }
  }
  
  // æª¢æŸ¥å–®æ³¨é™é¡
  if (amount < limits.minBet) {
    return {
      valid: false,
      message: `å–®æ³¨é‡‘é¡ä¸èƒ½ä½æ–¼ ${limits.minBet} å…ƒ`
    };
  }
  
  if (amount > limits.maxBet) {
    return {
      valid: false,
      message: `å–®æ³¨é‡‘é¡ä¸èƒ½è¶…é ${limits.maxBet} å…ƒ`
    };
  }
  
  // æª¢æŸ¥å–®æœŸé™é¡ï¼ˆè¨ˆç®—ç•¶å‰æœŸå·²æŠ•æ³¨é‡‘é¡ï¼‰
  const sameTypeBets = userBets.filter(bet => {
    if (betType === 'number' || (
      ['champion', 'runnerup', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth'].includes(betType) && 
      !['big', 'small', 'odd', 'even'].includes(value)
    )) {
      return bet.betType === 'number' || (
        ['champion', 'runnerup', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth'].includes(bet.betType) && 
        !['big', 'small', 'odd', 'even'].includes(bet.value)
      );
    } else if (betType === 'dragonTiger') {
      return bet.betType === 'dragonTiger';
    } else if (betType === 'sumValue') {
      if (['big', 'small'].includes(value)) {
        return bet.betType === 'sumValue' && ['big', 'small'].includes(bet.value);
      } else if (['odd', 'even'].includes(value)) {
        return bet.betType === 'sumValue' && ['odd', 'even'].includes(bet.value);
      } else {
        return bet.betType === 'sumValue' && !['big', 'small', 'odd', 'even'].includes(bet.value);
      }
    } else {
      return ['champion', 'runnerup', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth', 'position'].includes(bet.betType) && 
             ['big', 'small', 'odd', 'even'].includes(bet.value);
    }
  });
  
  const currentPeriodAmount = sameTypeBets.reduce((sum, bet) => sum + bet.amount, 0);
  
  if (currentPeriodAmount + amount > limits.periodLimit) {
    return {
      valid: false,
      message: `å–®æœŸé™é¡ç‚º ${limits.periodLimit} å…ƒï¼Œå·²æŠ•æ³¨ ${currentPeriodAmount} å…ƒï¼Œç„¡æ³•å†æŠ•æ³¨ ${amount} å…ƒ`
    };
  }
  
  return { valid: true };
}

// æœƒå“¡é™ç´…è¨­å®šAPI
app.get('/api/member-betting-limits', async (req, res) => {
  try {
    const { username } = req.query;
    
    if (!username) {
      return res.status(400).json({ success: false, message: 'ç¼ºå°‘æœƒå“¡ç”¨æˆ¶å' });
    }
    
    // å¾ä»£ç†ç³»çµ±ç²å–æœƒå“¡é™ç´…è¨­å®š
    const response = await fetch(`${AGENT_API_URL}/api/agent/member-betting-limit-by-username?username=${username}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      if (data.success && data.config) {
        return res.json({
          success: true,
          config: data.config,
          levelName: data.levelName,
          levelDisplayName: data.levelDisplayName
        });
      }
    }
    
    // å¦‚æœç„¡æ³•ç²å–æœƒå“¡é™ç´…è¨­å®šï¼Œè¿”å›é è¨­é…ç½®
    const defaultConfig = {
      number: { maxBet: 2500, periodLimit: 5000 },
      twoSide: { maxBet: 5000, periodLimit: 5000 },
      sumValueSize: { maxBet: 5000, periodLimit: 5000 },
      sumValueOddEven: { maxBet: 5000, periodLimit: 5000 },
      sumValue: { maxBet: 1000, periodLimit: 2000 },
      dragonTiger: { maxBet: 5000, periodLimit: 5000 }
    };
    
    res.json({
      success: true,
      config: defaultConfig,
      levelName: 'level1',
      levelDisplayName: 'æ¨™æº–é™ç´…'
    });
    
  } catch (error) {
    console.error('ç²å–æœƒå“¡é™ç´…è¨­å®šéŒ¯èª¤:', error);
    
    // éŒ¯èª¤æ™‚è¿”å›é è¨­é…ç½®
    const defaultConfig = {
      number: { maxBet: 2500, periodLimit: 5000 },
      twoSide: { maxBet: 5000, periodLimit: 5000 },
      sumValueSize: { maxBet: 5000, periodLimit: 5000 },
      sumValueOddEven: { maxBet: 5000, periodLimit: 5000 },
      sumValue: { maxBet: 1000, periodLimit: 2000 },
      dragonTiger: { maxBet: 5000, periodLimit: 5000 }
    };
    
    res.json({
      success: true,
      config: defaultConfig,
      levelName: 'level1',
      levelDisplayName: 'æ¨™æº–é™ç´…'
    });
  }
});

// ç²å–ä¸‹æ³¨è³ ç‡å‡½æ•¸ - æ”¯æŒç›¤å£ç³»çµ±
function getOdds(betType, value, marketType = 'D') {
  try {
    // æ ¹æ“šç›¤å£é¡å‹ç²å–é…ç½®
    const config = MARKET_CONFIG[marketType] || MARKET_CONFIG.D;
    const rebatePercentage = config.rebatePercentage;
    
    // å† äºå’Œå€¼è³ ç‡
    if (betType === 'sumValue') {
      if (value === 'big' || value === 'small' || value === 'odd' || value === 'even') {
        return config.twoSideOdds;  // ä½¿ç”¨ç›¤å£é…ç½®çš„å…©é¢è³ ç‡
      } else {
        // å’Œå€¼è³ ç‡è¡¨ - ä½¿ç”¨æ–°çš„åŸºç¤è³ ç‡è¡¨
        const sumOdds = {
          '3': parseFloat((45.0 * (1 - rebatePercentage)).toFixed(3)), 
          '4': parseFloat((23.0 * (1 - rebatePercentage)).toFixed(3)), 
          '5': parseFloat((15.0 * (1 - rebatePercentage)).toFixed(3)), 
          '6': parseFloat((11.5 * (1 - rebatePercentage)).toFixed(3)), 
          '7': parseFloat((9.0 * (1 - rebatePercentage)).toFixed(3)), 
          '8': parseFloat((7.5 * (1 - rebatePercentage)).toFixed(3)), 
          '9': parseFloat((6.5 * (1 - rebatePercentage)).toFixed(3)), 
          '10': parseFloat((5.7 * (1 - rebatePercentage)).toFixed(3)), 
          '11': parseFloat((5.7 * (1 - rebatePercentage)).toFixed(3)), 
          '12': parseFloat((6.5 * (1 - rebatePercentage)).toFixed(3)), 
          '13': parseFloat((7.5 * (1 - rebatePercentage)).toFixed(3)), 
          '14': parseFloat((9.0 * (1 - rebatePercentage)).toFixed(3)), 
          '15': parseFloat((11.5 * (1 - rebatePercentage)).toFixed(3)), 
          '16': parseFloat((15.0 * (1 - rebatePercentage)).toFixed(3)), 
          '17': parseFloat((23.0 * (1 - rebatePercentage)).toFixed(3)),
          '18': parseFloat((45.0 * (1 - rebatePercentage)).toFixed(3)), 
          '19': parseFloat((90.0 * (1 - rebatePercentage)).toFixed(3))
        };
        return sumOdds[value] || 1.0;
      }
    } 
    // å–®è™ŸæŠ•æ³¨
    else if (betType === 'number') {
      return config.numberOdds;  // ä½¿ç”¨ç›¤å£é…ç½®çš„å–®è™Ÿè³ ç‡
    }
    // é¾è™
    else if (betType === 'dragonTiger') {
      return config.dragonTigerOdds;  // ä½¿ç”¨ç›¤å£é…ç½®çš„é¾è™è³ ç‡
    } 
    // å¿«é€ŸæŠ•æ³¨ (positioné¡å‹)
    else if (betType === 'position') {
      if (['big', 'small', 'odd', 'even'].includes(value)) {
        return config.twoSideOdds;  // ä½¿ç”¨ç›¤å£é…ç½®çš„å…©é¢è³ ç‡
      } else {
        console.warn(`å¿«é€ŸæŠ•æ³¨æ”¶åˆ°ç„¡æ•ˆå€¼: ${value}ï¼Œè¿”å›é»˜èªè³ ç‡ 1.0`);
        return 1.0;
      }
    }
    // å† è»ã€äºè»ç­‰ä½ç½®æŠ•æ³¨
    else if (['champion', 'runnerup', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth'].includes(betType)) {
      if (['big', 'small', 'odd', 'even'].includes(value)) {
        return config.twoSideOdds;  // ä½¿ç”¨ç›¤å£é…ç½®çš„å…©é¢è³ ç‡
      } else {
        // æŒ‡å®šè™Ÿç¢¼æŠ•æ³¨ï¼šä½¿ç”¨ç›¤å£é…ç½®çš„å–®è™Ÿè³ ç‡
        const numValue = parseInt(value);
        if (!isNaN(numValue) && numValue >= 1 && numValue <= 10) {
          return config.numberOdds;
        } else {
          // ç„¡æ•ˆå€¼ï¼Œè¿”å›æœ€ä½è³ ç‡ä¸¦è¨˜éŒ„è­¦å‘Š
          console.warn(`ä½ç½®æŠ•æ³¨ ${betType} æ”¶åˆ°ç„¡æ•ˆå€¼: ${value}ï¼Œè¿”å›é»˜èªè³ ç‡ 1.0`);
          return 1.0;
        }
      }
    }
    
    // é è¨­è³ ç‡
    return 1.0;
  } catch (error) {
    console.error('è¨ˆç®—è³ ç‡æ™‚å‡ºéŒ¯:', error);
    return 1.0;
  }
}

// ç²å–é¤˜é¡å‡½æ•¸ï¼Œç”±å¤šå€‹APIä½¿ç”¨
async function getBalance(username) {
  try {
    if (!username) {
      console.log('ç²å–é¤˜é¡å¤±æ•—: æœªæä¾›ç”¨æˆ¶å');
      return 0;
    }
    
    // å˜—è©¦å¾ä»£ç†ç³»çµ±ç²å–é¤˜é¡
    try {
      const response = await fetch(`${AGENT_API_URL}/api/agent/member-balance?username=${username}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      const data = await response.json();
      
      if (data.success) {
        // æ›´æ–°æœ¬åœ°é¤˜é¡
        await UserModel.setBalance(username, data.balance);
        return parseFloat(data.balance);
      }
    } catch (error) {
      console.error('å¾ä»£ç†ç³»çµ±ç²å–é¤˜é¡å¤±æ•—:', error);
    }
    
    // å¦‚æœå¾ä»£ç†ç³»çµ±ç²å–å¤±æ•—ï¼Œå‰‡ä½¿ç”¨æœ¬åœ°é¤˜é¡
    const user = await UserModel.findByUsername(username);
    if (user) {
      return parseFloat(user.balance);
    }
    
    console.log(`ç”¨æˆ¶ ${username} ä¸å­˜åœ¨ï¼Œé¤˜é¡ç‚º 0`);
    return 0;
  } catch (error) {
    console.error('ç²å–é¤˜é¡å‡ºéŒ¯:', error);
    return 0;
  }
}

// æ›´æ–°æœƒå“¡é¤˜é¡çš„å‡½æ•¸
async function updateMemberBalance(username, amount, adminAgent, reason) {
  try {
    console.log(`å˜—è©¦æ›´æ–°æœƒå“¡ ${username} çš„é¤˜é¡ï¼š${amount}ï¼ŒåŸå› ï¼š${reason}`);
    console.log(`ä»£ç†ä¿¡æ¯:`, JSON.stringify(adminAgent));
    
    if (!username) {
      console.error('æ›´æ–°æœƒå“¡é¤˜é¡å¤±æ•—: æœªæä¾›ç”¨æˆ¶å');
      return { success: false, message: 'æœªæä¾›ç”¨æˆ¶å' };
    }

    // ç²å–ç•¶å‰é¤˜é¡
    const currentBalance = await getBalance(username);
    console.log(`ç”¨æˆ¶ ${username} çš„ç•¶å‰é¤˜é¡: ${currentBalance}`);
    
    // è¨ˆç®—æ–°é¤˜é¡
    const newBalance = parseFloat(currentBalance) + parseFloat(amount);
    console.log(`ç”¨æˆ¶ ${username} çš„æ–°é¤˜é¡å°‡ç‚º: ${newBalance}`);
    
    // æª¢æŸ¥é¤˜é¡æ˜¯å¦ç‚ºè² æ•¸
    if (newBalance < 0) {
              console.error(`æ›´æ–°ä¼šå‘˜ä½™é¢å¤±è´¥: ä½™é¢ä¸è¶³ (å½“å‰: ${currentBalance}, å°è¯•æ‰£é™¤: ${Math.abs(amount)})`);
        return { success: false, message: 'ä½™é¢ä¸è¶³' };
    }
    
    // å…ˆæ›´æ–°æœ¬åœ°ç”¨æˆ¶é¤˜é¡
    try {
      await UserModel.setBalance(username, newBalance);
      console.log(`æœ¬åœ°é¤˜é¡å·²æ›´æ–°ç‚º: ${newBalance}`);
    } catch (localError) {
      console.error('æ›´æ–°æœ¬åœ°é¤˜é¡å¤±æ•—:', localError);
      return { success: false, message: `æ›´æ–°æœ¬åœ°é¤˜é¡å¤±æ•—: ${localError.message}` };
    }
    
    // å˜—è©¦åŒæ­¥åˆ°ä»£ç†ç³»çµ±ï¼Œä½†å³ä½¿å¤±æ•—ä¹Ÿä¸å½±éŸ¿æœ¬åœ°æ›´æ–°çµæœ
    let agentSystemSuccess = false;
    if (adminAgent) {
      try {
        console.log(`å‘ä»£ç†ç³»çµ±ç™¼é€é¤˜é¡åŒæ­¥è«‹æ±‚: ${AGENT_API_URL}/api/agent/sync-member-balance`);
        console.log(`è«‹æ±‚é«”:`, JSON.stringify({
          username: username,
          balance: newBalance,
          reason: reason
        }));
        
        const response = await fetch(`${AGENT_API_URL}/api/agent/sync-member-balance`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            username: username,
            balance: newBalance,
            reason: reason
        })
      });
      
        console.log(`ä»£ç†ç³»çµ±éŸ¿æ‡‰ç‹€æ…‹ç¢¼: ${response.status}`);
        
        const data = await response.json();
        console.log(`ä»£ç†ç³»çµ±éŸ¿æ‡‰æ•¸æ“š:`, JSON.stringify(data));
        
        if (!data.success) {
          console.error('ä»£ç†ç³»çµ±åŒæ­¥é¤˜é¡å¤±æ•—:', data.message);
          // å³ä½¿ä»£ç†ç³»çµ±å¤±æ•—ï¼Œæˆ‘å€‘ä¹Ÿç¹¼çºŒä½¿ç”¨æœ¬åœ°æ›´æ–°çš„é¤˜é¡
        } else {
          console.log(`ä»£ç†ç³»çµ±æˆåŠŸåŒæ­¥é¤˜é¡`);
          agentSystemSuccess = true;
        }
      } catch (error) {
        console.error('å‘¼å«ä»£ç†ç³»çµ±APIå‡ºéŒ¯:', error);
        // ç¹¼çºŒä½¿ç”¨æœ¬åœ°æ›´æ–°çš„é¤˜é¡
      }
    } else {
      console.log('æœªæä¾›ä»£ç†ä¿¡æ¯ï¼Œåƒ…æ›´æ–°æœ¬åœ°é¤˜é¡');
    }
    
    console.log(`ç”¨æˆ¶ ${username} é¤˜é¡å·²æ›´æ–°: ${currentBalance} -> ${newBalance} (ä»£ç†ç³»çµ±åŒæ­¥ç‹€æ…‹: ${agentSystemSuccess ? 'æˆåŠŸ' : 'å¤±æ•—'})`);
    return { success: true, balance: newBalance };
    
  } catch (error) {
    console.error('æ›´æ–°æœƒå“¡é¤˜é¡æ™‚å‡ºéŒ¯:', error);
    return { success: false, message: `ç³»çµ±éŒ¯èª¤: ${error.message}` };
  }
}

// åˆå§‹åŒ–å…¨å±€ç†±é–€æŠ•æ³¨æ•¸æ“šçµæ§‹
const hotBetsData = {
  // æŒ‰ä¸‹æ³¨é¡å‹å’Œå€¼ä¿å­˜ç†±é–€ç¨‹åº¦
  byType: {
    sumValue: {}, // å† äºå’Œå€¼
    dragonTiger: {}, // é¾è™
    champion: {}, // å† è»ä½ç½®
    runnerup: {}, // äºè»ä½ç½®
    number: {} // å–®è™ŸæŠ•æ³¨
  },
  // ç†±é–€æŠ•æ³¨æ’è¡Œæ¦œï¼ˆæŒ‰ä¸‹æ³¨æ¬¡æ•¸æ’åºï¼‰
  topBets: [],
  // æœ€å¾Œæ›´æ–°æ™‚é–“
  lastUpdate: null
};

// å®šæœŸæ›´æ–°ç†±é–€æŠ•æ³¨æ•¸æ“š
async function updateHotBets() {
  try {
    console.log('é–‹å§‹æ›´æ–°ç†±é–€æŠ•æ³¨æ•¸æ“š');
    const now = new Date();
    
    // ç²å–æœ€è¿‘24å°æ™‚çš„ä¸‹æ³¨æ•¸æ“š
    const period = 24 * 60 * 60 * 1000; // 24å°æ™‚çš„æ¯«ç§’æ•¸
    const startTime = new Date(now.getTime() - period);
    
    // æŸ¥è©¢æ•¸æ“šåº«ï¼Œç²å–æœ€è¿‘ä¸‹æ³¨
    let recentBets = [];
    try {
      recentBets = await db.any(`
        SELECT 
          bet_type, 
          bet_value, 
          position,
          COUNT(*) as bet_count,
          SUM(amount) as total_amount
        FROM bet_history
        WHERE created_at > $1
        GROUP BY bet_type, bet_value, position
        ORDER BY bet_count DESC
      `, [startTime]);
      
      console.log(`æŸ¥è©¢åˆ° ${recentBets.length} æ¢è¿‘æœŸæŠ•æ³¨æ•¸æ“š`);
    } catch (dbError) {
      console.error('æŸ¥è©¢æ•¸æ“šåº«ç²å–ç†±é–€æŠ•æ³¨æ•¸æ“šå¤±æ•—:', dbError);
      // å¦‚æœæ•¸æ“šåº«æŸ¥è©¢å¤±æ•—ï¼Œè¨­ç½®ç‚ºç©ºæ•¸çµ„
      recentBets = [];
      throw new Error('æŸ¥è©¢æ•¸æ“šåº«ç²å–ç†±é–€æŠ•æ³¨æ•¸æ“šå¤±æ•—');
    }
    
    // é‡ç½®ç†±é–€æŠ•æ³¨æ•¸æ“š
    for (const type in hotBetsData.byType) {
      hotBetsData.byType[type] = {};
    }
    
    // å¦‚æœæ²’æœ‰æ•¸æ“šï¼Œå‰‡ç›´æ¥è¿”å›ç©ºæ•¸çµ„
    if (recentBets.length === 0) {
      console.log('æ²’æœ‰æŸ¥è©¢åˆ°æŠ•æ³¨æ•¸æ“šï¼Œè¿”å›ç©ºæ•¸æ“š');
      hotBetsData.topBets = [];
      hotBetsData.lastUpdate = now;
      return;
    }
    
    // æ­£å¸¸è™•ç†æŸ¥è©¢çµæœ
    recentBets.forEach(bet => {
      const betType = bet.bet_type;
      const betValue = bet.bet_value;
      const position = bet.position;
      const count = parseInt(bet.bet_count);
      const amount = parseFloat(bet.total_amount);
      
      if (betType === 'number' && position) {
        // å–®è™ŸæŠ•æ³¨éœ€è¦è€ƒæ…®ä½ç½®
        const key = `${position}_${betValue}`;
        hotBetsData.byType.number[key] = { count, amount, position, value: betValue };
      } else if (hotBetsData.byType[betType]) {
        // å…¶ä»–æŠ•æ³¨é¡å‹
        hotBetsData.byType[betType][betValue] = { count, amount, value: betValue };
      }
    });
    
    // æ•´ç†ç†±é–€æŠ•æ³¨æ’è¡Œæ¦œ
    const allBets = [];
    
    // è™•ç†è™Ÿç¢¼æŠ•æ³¨
    Object.entries(hotBetsData.byType.number).forEach(([key, data]) => {
      const [position, value] = key.split('_');
      allBets.push({
        type: 'number',
        typeLabel: 'å–®è™Ÿ',
        position: parseInt(position),
        value,
        count: data.count,
        amount: data.amount,
        label: `ç¬¬${position}å ${value}è™Ÿ`
      });
    });
    
    // è™•ç†å† äºå’Œå€¼
    Object.entries(hotBetsData.byType.sumValue).forEach(([value, data]) => {
      let label = '';
      if (['big', 'small', 'odd', 'even'].includes(value)) {
        const valueMap = {
          'big': 'å¤§',
          'small': 'å°',
          'odd': 'å–®',
          'even': 'é›™'
        };
        label = `å† äºå’Œ ${valueMap[value]}`;
      } else {
        label = `å† äºå’Œ ${value}`;
      }
      
      allBets.push({
        type: 'sumValue',
        typeLabel: 'å† äºå’Œ',
        value,
        count: data.count,
        amount: data.amount,
        label
      });
    });
    
    // è™•ç†é¾è™
    Object.entries(hotBetsData.byType.dragonTiger).forEach(([value, data]) => {
      let label = '';
      
      // è™•ç†é¾è™æŠ•æ³¨æ ¼å¼ï¼šdragon_1_10 -> é¾(å† è»vsç¬¬10å)
      if (value && value.includes('_')) {
        const parts = value.split('_');
        if (parts.length === 3) {
          const dragonTiger = parts[0] === 'dragon' ? 'é¾' : 'è™';
          const pos1 = parts[1] === '1' ? 'å† è»' : parts[1] === '2' ? 'äºè»' : `ç¬¬${parts[1]}å`;
          const pos2 = parts[2] === '10' ? 'ç¬¬åå' : `ç¬¬${parts[2]}å`;
          label = `${dragonTiger}(${pos1}vs${pos2})`;
        } else {
          label = `é¾è™ ${value}`;
        }
      } else {
        const valueMap = {
          'dragon': 'é¾',
          'tiger': 'è™'
        };
        label = `é¾è™ ${valueMap[value] || value}`;
      }
      
      allBets.push({
        type: 'dragonTiger',
        typeLabel: 'é¾è™',
        value,
        count: data.count,
        amount: data.amount,
        label
      });
    });
    
    // è™•ç†å† è»
    Object.entries(hotBetsData.byType.champion).forEach(([value, data]) => {
      let label = '';
      if (['big', 'small', 'odd', 'even'].includes(value)) {
        const valueMap = {
          'big': 'å¤§',
          'small': 'å°',
          'odd': 'å–®',
          'even': 'é›™'
        };
        label = `å† è» ${valueMap[value]}`;
      } else {
        label = `å† è» ${value}è™Ÿ`;
      }
      
      allBets.push({
        type: 'champion',
        typeLabel: 'å† è»',
        value,
        count: data.count,
        amount: data.amount,
        label
      });
    });
    
    // è™•ç†äºè»
    Object.entries(hotBetsData.byType.runnerup).forEach(([value, data]) => {
      let label = '';
      if (['big', 'small', 'odd', 'even'].includes(value)) {
        const valueMap = {
          'big': 'å¤§',
          'small': 'å°',
          'odd': 'å–®',
          'even': 'é›™'
        };
        label = `äºè» ${valueMap[value]}`;
      } else {
        label = `äºè» ${value}è™Ÿ`;
      }
      
      allBets.push({
        type: 'runnerup',
        typeLabel: 'äºè»',
        value,
        count: data.count,
        amount: data.amount,
        label
      });
    });
    
    // æ’åºä¸¦åªä¿ç•™å‰10å€‹
    hotBetsData.topBets = allBets
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
    
    hotBetsData.lastUpdate = now;
    console.log(`ç†±é–€æŠ•æ³¨æ•¸æ“šæ›´æ–°å®Œæˆï¼Œå…±æœ‰ ${hotBetsData.topBets.length} å€‹ç†±é–€é¸é …`);
  } catch (error) {
    console.error('æ›´æ–°ç†±é–€æŠ•æ³¨æ•¸æ“šå¤±æ•—:', error);
    // å‡ºéŒ¯æ™‚ä¸ç”¢ç”Ÿé»˜èªæ•¸æ“šï¼Œå°‡topBetsä¿æŒç‚ºåŸä¾†çš„å€¼ï¼Œä¸å½±éŸ¿å·²æœ‰æ•¸æ“š
  }
}

// REST APIç«¯é» - ç²å–æœ€æ–°é–‹ççµæœ
app.get('/api/results/latest', async (req, res) => {
  try {
    console.log('æ”¶åˆ°ç²å–æœ€æ–°é–‹ççµæœè«‹æ±‚');
    
    const result = await db.oneOrNone(`
      SELECT period, result, created_at 
      FROM result_history 
      ORDER BY created_at DESC 
      LIMIT 1
    `);
    
    if (result) {
      console.log(`è¿”å›æœ€æ–°é–‹ççµæœ: æœŸè™Ÿ=${result.period}`);
      res.json({
        success: true,
        result: {
          period: result.period,
          result_numbers: Array.isArray(result.result) ? result.result.join(',') : result.result,
          created_at: result.created_at
        }
      });
    } else {
      console.log('æ²’æœ‰æ‰¾åˆ°é–‹ççµæœ');
      res.json({
        success: false,
        message: 'æ²’æœ‰æ‰¾åˆ°é–‹ççµæœ'
      });
    }
  } catch (error) {
    console.error('ç²å–æœ€æ–°é–‹ççµæœå¤±æ•—:', error);
    res.status(500).json({
      success: false,
      message: 'ç²å–é–‹ççµæœå¤±æ•—'
    });
  }
});

// REST APIç«¯é» - ç²å–ç†±é–€æŠ•æ³¨
app.get('/api/hot-bets', (req, res) => {
  console.log('æ”¶åˆ°ç†±é–€æŠ•æ³¨APIè«‹æ±‚');
  try {
    // å¦‚æœhotBetsData.topBetsç‚ºç©ºæˆ–æœªåˆå§‹åŒ–ï¼Œè¿”å›ç©ºæ•¸æ“š
    if (!hotBetsData.topBets || hotBetsData.topBets.length === 0) {
      console.log('ç†±é–€æŠ•æ³¨æ•¸æ“šç‚ºç©ºï¼Œè¿”å›ç©ºæ•¸çµ„');
      return res.json({
        success: true,
        message: 'æš«ç„¡ç†±é–€æŠ•æ³¨æ•¸æ“š',
        hotBets: [],
        lastUpdate: null
      });
    }
    
    // æ­£å¸¸æ•¸æ“šè™•ç†
    const hotBets = hotBetsData.topBets.map(bet => ({
      betType: bet.type,      // å‰ç«¯æœŸæœ›betTypeå­—æ®µ
      betValue: bet.value,    // å‰ç«¯æœŸæœ›betValueå­—æ®µ
      typeLabel: bet.typeLabel,
      position: bet.position,
      count: bet.count,
      label: bet.label,
      isHot: true
    }));
    
    console.log(`ç†±é–€æŠ•æ³¨APIè¿”å› ${hotBets.length} å€‹æ•¸æ“š`);
    
    res.json({
      success: true,
      hotBets,
      lastUpdate: hotBetsData.lastUpdate
    });
  } catch (error) {
    console.error('ç²å–ç†±é–€æŠ•æ³¨æ•¸æ“šå¤±æ•—:', error);
    res.status(500).json({ 
      success: false, 
      message: 'ç²å–ç†±é–€æŠ•æ³¨æ•¸æ“šå¤±æ•—',
      error: error.message,
      hotBets: []
    });
  }
});

// ç²å–é•·é¾æ’è¡Œæ•¸æ“šçš„APIç«¯é»
app.get('/api/dragon-ranking', async (req, res) => {
  try {
    // ç²å–æœ€è¿‘100æœŸçš„é–‹çè¨˜éŒ„ï¼Œç”¨æ–¼è¨ˆç®—é•·é¾
    const query = `
      SELECT period, result, created_at as draw_time 
      FROM result_history 
      ORDER BY created_at DESC 
      LIMIT 100
    `;
    
    const results = await db.any(query);
    
    if (!results || results.length === 0) {
      return res.json({
        success: true,
        dragonRankings: []
      });
    }
    
    // è§£æçµæœä¸¦è¨ˆç®—é•·é¾
    const parsedResults = results.map(row => {
      let result;
      try {
        result = typeof row.result === 'string' ? JSON.parse(row.result) : row.result;
      } catch (e) {
        console.error('è§£æé–‹ççµæœå¤±æ•—:', e);
        return null;
      }
      return {
        period: row.period,
        result,
        time: row.draw_time
      };
    }).filter(item => item !== null).reverse(); // æŒ‰æ™‚é–“é †åºæ’åˆ—
    
    // è¨ˆç®—å„ç¨®é•·é¾çµ±è¨ˆ
    const dragonStats = calculateDragonStats(parsedResults);
    
    res.json({
      success: true,
      dragonRankings: dragonStats
    });

  } catch (error) {
    console.error('ç²å–é•·é¾æ’è¡Œå‡ºéŒ¯:', error);
    res.status(500).json({ 
      success: false, 
      message: 'ç²å–é•·é¾æ’è¡Œå¤±æ•—',
      dragonRankings: []
    });
  }
});

// è¨ˆç®—é•·é¾çµ±è¨ˆçš„è¼”åŠ©å‡½æ•¸
function calculateDragonStats(results) {
  // è¿”å›åƒ…ã€Œç•¶å‰ä¸ä¸­æ–·ã€é€£çºŒç´€éŒ„ï¼ˆå³å¾æœ€è¿‘ä¸€æœŸå¾€å‰æ¨é‡æ–·é»å³åœæ­¢ï¼‰
  const stats = [];

  // ç‚ºæ–¹ä¾¿ï¼Œæœ€æ–°ä¸€æœŸæ’åœ¨ results[0] ï¼Œè‹¥ä¸æ˜¯è«‹å…ˆç¢ºä¿é™£åˆ—æŒ‰æ™‚é–“ DESCã€‚
  const latestFirst = Array.isArray(results) ? [...results] : [];
  // ä¿è­‰æœ€æ–°åœ¨ç´¢å¼• 0
  latestFirst.sort((a,b)=> new Date(b.time||b.period) - new Date(a.time||a.period));

  // 10 åå¤§å° & å–®é›™
  for (let pos=1; pos<=10; pos++) {
    // å¤§å°
    addCurrentStreak(latestFirst, (num)=> num>5?'å¤§':'å°', `ç¬¬${getPositionName(pos)}å`, stats, `å¤§å°-${pos}`,(numbers)=>numbers[pos-1]);
    // å–®é›™
    addCurrentStreak(latestFirst, (num)=> num%2===1?'å–®':'é›™', `ç¬¬${getPositionName(pos)}å`, stats, `å–®é›™-${pos}`,(numbers)=>numbers[pos-1]);
  }

  // 5 çµ„é¾è™ (1v10,2v9,3v8,4v7,5v6)
  const dragonPairs=[[1,10],[2,9],[3,8],[4,7],[5,6]];
  dragonPairs.forEach(([a,b])=>{
    addCurrentStreak(latestFirst, (values)=> values[0]>values[1]?'é¾':'è™', `${a}v${b}`, stats, `é¾è™-${a}`, (numbers)=> [numbers[a-1], numbers[b-1]]);
  });

  // å† äºå’Œå€¼ å¤§å°
  addCurrentStreak(latestFirst, (sum)=> sum>11?'å¤§':'å°', 'å† äºå’Œ', stats, 'sum-bigsmall', (numbers)=> numbers[0]+numbers[1]);
  // å† äºå’Œå€¼ å–®é›™
  addCurrentStreak(latestFirst, (sum)=> sum%2===1?'å–®':'é›™', 'å† äºå’Œ', stats, 'sum-oddeven', (numbers)=> numbers[0]+numbers[1]);

  // åªä¿ç•™é€£çºŒ >=2 çš„é …ç›®ï¼Œä¸¦ä¾ count DESC æ’åº
  return stats.filter(s=>s.count>=2).sort((a,b)=>b.count-a.count).slice(0,20);
}

// helper to accumulate streak
function addCurrentStreak(results, getValue, labelPrefix, allStats, categoryType, extractFn){
  let currentVal = null; 
  let count = 0;
  
  for(const rec of results){
    if (!rec || !rec.result || !Array.isArray(rec.result)) continue;
    
    const valRaw = extractFn(rec.result);
    const val = typeof getValue === 'function' ? getValue(valRaw) : valRaw;
    
    if(currentVal === null){
      currentVal = val; 
      count = 1; 
      continue;
    }
    
    if(val === currentVal){
      count++;
    } else {
      break;
    }
  }
  
  if(count >= 1){  // æ”¹ç‚º>=1ï¼Œå› ç‚ºå³ä½¿åªæœ‰1æœŸä¹Ÿè¦é¡¯ç¤º
    // æ ¹æ“šcategoryTypeæ±ºå®šåˆ†é¡
    let category;
    if (categoryType.startsWith('å¤§å°')) {
      category = 'å¤§å°';
    } else if (categoryType.startsWith('å–®é›™')) {
      category = 'å–®é›™';
    } else if (categoryType.startsWith('é¾è™')) {
      category = 'é¾è™';
    } else if (categoryType.startsWith('sum-bigsmall')) {
      category = 'å† äºå’Œå¤§å°';
    } else if (categoryType.startsWith('sum-oddeven')) {
      category = 'å† äºå’Œå–®é›™';
    } else {
      category = 'å…¶ä»–';
    }
    
    allStats.push({
      name: `${labelPrefix} ${currentVal}`,
      count,
      value: currentVal,
      category,
      type: labelPrefix
    });
  }
}

function getPositionName(position) {
  const names = ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹', 'å'];
  return names[position - 1] || position.toString();
}

// ğŸ´ è·¯ç èµ°å‹¢æ•¸æ“š
app.get('/api/road-bead', async (req, res) => {
    const { position = 1, type = 'number', limit = 60 } = req.query;
    
    try {
        // è¨ˆç®—ä»Šæ—¥æœŸè™Ÿç¯„åœ (ä½¿ç”¨èˆ‡éŠæˆ²é‚è¼¯ç›¸åŒçš„æœŸè™Ÿæ ¼å¼)
        const today = new Date();
        const todayStr = `${today.getFullYear()}${(today.getMonth()+1).toString().padStart(2,'0')}${today.getDate().toString().padStart(2,'0')}`;
        const todayPeriodStart = parseInt(`${todayStr}001`); // ä»Šæ—¥ç¬¬ä¸€æœŸï¼Œæ ¼å¼ï¼šYYYYMMDD001
        
        console.log(`ğŸ” è·¯ç API: ç²å–ä»Šæ—¥æœŸè™Ÿæ ¼å¼ ${todayStr}xxx çš„æœ€è¿‘ ${limit} æœŸé–‹çè¨˜éŒ„`);
        
        // ç²å–ä»Šæ—¥çš„æœ€è¿‘é–‹çè¨˜éŒ„ï¼ŒæŒ‰æœŸè™Ÿé™åºæ’åˆ—
        // ä½¿ç”¨å­—ç¬¦ä¸²åŒ¹é…ä¾†ç¢ºä¿åªç²å–ä»Šæ—¥æ ¼å¼çš„æœŸè™Ÿ
        const drawHistory = await db.any(`
            SELECT period, result, created_at
            FROM result_history 
            WHERE result IS NOT NULL 
            AND period::text LIKE $1
            ORDER BY period DESC 
            LIMIT $2
        `, [`${todayStr}%`, parseInt(limit)]);
        
        if (!drawHistory || drawHistory.length === 0) {
            return res.json({
                success: true,
                data: {
                    position: parseInt(position),
                    type,
                    tableData: [],
                    todayStats: [],
                    summary: {}
                }
            });
        }
        
        // åè½‰é †åºï¼Œå¾èˆŠåˆ°æ–°
        const orderedHistory = drawHistory.reverse();
        
        console.log(`âœ… è·¯ç API: æˆåŠŸç²å– ${drawHistory.length} æœŸé–‹çè¨˜éŒ„ï¼Œæœ€æ–°æœŸè™Ÿ: ${drawHistory.length > 0 ? drawHistory[drawHistory.length - 1].period : 'ç„¡'}`);
        
        // ä½¿ç”¨ä»Šæ—¥æœŸè™Ÿèµ·å§‹å€¼ä½œç‚ºä»Šæ—¥åˆ¤æ–·åŸºæº–
        const todayPeriod = parseInt(`${todayStr}001`);
        
        // è™•ç†è·¯ç æ•¸æ“š
        const roadBeadData = processRoadBeadData(orderedHistory, parseInt(position), type);
        
        // è¨ˆç®—ä»Šæ—¥çµ±è¨ˆï¼ˆåªçµ±è¨ˆè™Ÿç¢¼å‡ºç¾æ¬¡æ•¸ï¼‰
        const todayStats = calculateTodayStats(orderedHistory, parseInt(position), todayPeriod);
        
        res.json({
            success: true,
            data: {
                position: parseInt(position),
                type,
                tableData: roadBeadData.tableData,
                todayStats,
                summary: roadBeadData.summary
            }
        });
        
    } catch (error) {
        console.error('ç²å–è·¯ç èµ°å‹¢å¤±æ•—:', error);
        res.status(500).json({
            success: false,
            message: 'ç²å–è·¯ç èµ°å‹¢å¤±æ•—'
        });
    }
});

// è™•ç†è·¯ç æ•¸æ“š
function processRoadBeadData(history, position, type) {
    const tableData = [];
    const currentRow = [];
    
    // çµ±è¨ˆæ•¸æ“š
    const stats = {
        totalPeriods: history.length,
        sizeStats: { big: { count: 0, percentage: 0 }, small: { count: 0, percentage: 0 } },
        parityStats: { odd: { count: 0, percentage: 0 }, even: { count: 0, percentage: 0 } },
        numberFrequency: {},
        dragonTigerStats: { dragon: { count: 0, percentage: 0 }, tiger: { count: 0, percentage: 0 } },
        sumStats: { min: 999, max: 0, frequency: {} }
    };
    
    // è·¯ç è¡¨æ ¼é…ç½®
    const COLS = 6; // æ¯è¡Œ6åˆ—
    const ROWS = Math.ceil(history.length / COLS);
    
    // åˆå§‹åŒ–è¡¨æ ¼
    for (let i = 0; i < ROWS; i++) {
        tableData.push(new Array(COLS).fill(null));
    }
    
    // å¡«å……æ•¸æ“š
    history.forEach((draw, index) => {
        const row = Math.floor(index / COLS);
        const col = index % COLS;
        const result = typeof draw.result === 'string' ? JSON.parse(draw.result) : draw.result;
        
        // ç²å–æŒ‡å®šä½ç½®çš„æ•¸å­—
        const number = result[position - 1];
        
        // å‰µå»ºå–®å…ƒæ ¼æ•¸æ“š
        const cellData = {
            period: draw.period,
            number,
            position,
            isBig: number > 5,
            isOdd: number % 2 === 1,
            dragonTiger: null
        };
        
        // è¨ˆç®—å† äºå’Œï¼ˆå¦‚æœæ˜¯ç¬¬1æˆ–ç¬¬2åï¼‰
        if (position <= 2) {
            const sum = result[0] + result[1];
            cellData.sum = sum;
            cellData.sumBig = sum >= 12;
            cellData.sumOdd = sum % 2 === 1;
            
            // æ›´æ–°å’Œå€¼çµ±è¨ˆ
            stats.sumStats.min = Math.min(stats.sumStats.min, sum);
            stats.sumStats.max = Math.max(stats.sumStats.max, sum);
            stats.sumStats.frequency[sum] = (stats.sumStats.frequency[sum] || 0) + 1;
        }
        
        // è¨ˆç®—é¾è™ï¼ˆç¬¬1-5åå°æ‡‰ç¬¬10-6åï¼‰
        if (position <= 5) {
            const oppositePosition = 11 - position;
            const oppositeNumber = result[oppositePosition - 1];
            cellData.dragonTiger = number > oppositeNumber ? 'dragon' : 'tiger';
            
            // æ›´æ–°é¾è™çµ±è¨ˆ
            if (cellData.dragonTiger === 'dragon') {
                stats.dragonTigerStats.dragon.count++;
            } else {
                stats.dragonTigerStats.tiger.count++;
            }
        }
        
        // æ›´æ–°çµ±è¨ˆ
        stats.numberFrequency[number] = (stats.numberFrequency[number] || 0) + 1;
        if (cellData.isBig) {
            stats.sizeStats.big.count++;
        } else {
            stats.sizeStats.small.count++;
        }
        if (cellData.isOdd) {
            stats.parityStats.odd.count++;
        } else {
            stats.parityStats.even.count++;
        }
        
        // æ·»åŠ åˆ°è¡¨æ ¼
        tableData[row][col] = cellData;
    });
    
    // è¨ˆç®—ç™¾åˆ†æ¯”
    if (stats.totalPeriods > 0) {
        stats.sizeStats.big.percentage = ((stats.sizeStats.big.count / stats.totalPeriods) * 100).toFixed(1);
        stats.sizeStats.small.percentage = ((stats.sizeStats.small.count / stats.totalPeriods) * 100).toFixed(1);
        stats.parityStats.odd.percentage = ((stats.parityStats.odd.count / stats.totalPeriods) * 100).toFixed(1);
        stats.parityStats.even.percentage = ((stats.parityStats.even.count / stats.totalPeriods) * 100).toFixed(1);
        
        if (position <= 5) {
            const dragonTigerTotal = stats.dragonTigerStats.dragon.count + stats.dragonTigerStats.tiger.count;
            if (dragonTigerTotal > 0) {
                stats.dragonTigerStats.dragon.percentage = ((stats.dragonTigerStats.dragon.count / dragonTigerTotal) * 100).toFixed(1);
                stats.dragonTigerStats.tiger.percentage = ((stats.dragonTigerStats.tiger.count / dragonTigerTotal) * 100).toFixed(1);
            }
        }
    }
    
    return {
        tableData,
        summary: stats
    };
}

// è¨ˆç®—ä»Šæ—¥çµ±è¨ˆï¼ˆè™Ÿç¢¼å‡ºç¾æ¬¡æ•¸ï¼‰
function calculateTodayStats(history, position, todayPeriod) {
    const todayNumbers = {};
    let todayTotal = 0;
    
    // çµ±è¨ˆä»Šæ—¥æ¯å€‹è™Ÿç¢¼å‡ºç¾çš„æ¬¡æ•¸
    history.forEach(draw => {
        // åªçµ±è¨ˆä»Šæ—¥çš„é–‹ç
        if (parseInt(draw.period) >= todayPeriod) {
            const result = typeof draw.result === 'string' ? JSON.parse(draw.result) : draw.result;
            const number = result[position - 1];
            todayNumbers[number] = (todayNumbers[number] || 0) + 1;
            todayTotal++;
        }
    });
    
    // ç”Ÿæˆ1-10è™Ÿçš„çµ±è¨ˆæ•¸çµ„
    const stats = [];
    for (let i = 1; i <= 10; i++) {
        const count = todayNumbers[i] || 0;
        stats.push({
            number: i,
            count,
            percentage: todayTotal > 0 ? ((count / todayTotal) * 100).toFixed(1) : '0.0'
        });
    }
    
    return stats;
}

// è‡ªå‹•åµæ¸¬åˆ†æï¼šè¨ˆç®—å…¨é«”ç©å®¶èˆ‡å¹³å°çš„è¼¸è´æ¯”ä¾‹
async function performAutoDetectAnalysis(period, betStats) {
  try {
    console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] é–‹å§‹åˆ†ææœŸæ•¸ ${period} çš„å…¨é«”ç©å®¶è¼¸è´æ¯”ä¾‹...`);
    
    // 1. ç²å–è©²æœŸæ‰€æœ‰ä¸‹æ³¨è³‡æ–™
    const allBets = await db.any(`
      SELECT 
        b.username, b.bet_type, b.bet_value, b.position, b.amount,
        m.agent_id, a.username as agent_username
      FROM bet_history b
      LEFT JOIN members m ON b.username = m.username
      LEFT JOIN agents a ON m.agent_id = a.id
      WHERE b.period = $1 AND b.settled = false
    `, [period]);
    
    if (allBets.length === 0) {
      return {
        shouldApplyControl: false,
        reason: 'è©²æœŸç„¡ä»»ä½•ä¸‹æ³¨ï¼Œç¶­æŒæ­£å¸¸æ©Ÿç‡',
        playerWinProbability: 0,
        platformAdvantage: 0
      };
    }
    
    const totalBetAmount = allBets.reduce((sum, bet) => sum + parseFloat(bet.amount), 0);
    console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] è©²æœŸç¸½ä¸‹æ³¨é‡‘é¡: ${totalBetAmount}`);
    
    // 2. è¨ˆç®—è¿‘æœŸå¹³å°ç›ˆè™§ç‹€æ³ï¼ˆæœ€è¿‘5æœŸï¼‰
    const recentProfitLoss = await calculateRecentPlatformProfitLoss(5);
    console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] è¿‘æœŸå¹³å°ç›ˆè™§: ${recentProfitLoss}`);
    
    // 3. æ¨¡æ“¬æ‰€æœ‰å¯èƒ½çš„é–‹ççµæœï¼Œè¨ˆç®—ç©å®¶èˆ‡å¹³å°çš„è¼¸è´æ¯”ä¾‹
    const simulationResults = simulateAllPossibleOutcomes(allBets);
    console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] æ¨¡æ“¬åˆ†æå®Œæˆ:`, {
      averagePlayerWinRate: simulationResults.averagePlayerWinRate,
      averagePlatformProfit: simulationResults.averagePlatformProfit,
      highRiskOutcomes: simulationResults.highRiskOutcomes.length
    });
    
    // 4. åˆ†æé—œéµæŒ‡æ¨™
    const playerWinProbability = simulationResults.averagePlayerWinRate;
    const platformAdvantage = simulationResults.averagePlatformProfit;
    
    // 5. æ±ºç­–é‚è¼¯ï¼šè®“å¹³å°å°è´ï¼Œç©å®¶å°è¼¸
    let shouldApplyControl = false;
    let reason = '';
    
    // å¹³å°è™§æé¢¨éšªéé«˜æ™‚è§¸ç™¼æ§åˆ¶
    if (platformAdvantage < -totalBetAmount * 0.1) {
      shouldApplyControl = true;
      reason = `å¹³å°é¢è‡¨è™§æé¢¨éšª (é æœŸè™§æ: ${platformAdvantage.toFixed(2)})ï¼Œè§¸ç™¼ä¿è­·æ©Ÿåˆ¶`;
    }
    // ç©å®¶å‹ç‡éé«˜æ™‚è§¸ç™¼æ§åˆ¶  
    else if (playerWinProbability > 0.6) {
      shouldApplyControl = true;
      reason = `ç©å®¶å‹ç‡éé«˜ (${(playerWinProbability * 100).toFixed(1)}%)ï¼Œå¹³è¡¡è¼¸è´æ¯”ä¾‹`;
    }
    // è¿‘æœŸå¹³å°è™§æéå¤šæ™‚åŠ å¼·æ§åˆ¶
    else if (recentProfitLoss < -totalBetAmount * 2) {
      shouldApplyControl = true;
      reason = `è¿‘æœŸå¹³å°è™§æéå¤š (${recentProfitLoss.toFixed(2)})ï¼Œé©åº¦èª¿æ•´`;
    }
    // æª¢æ¸¬ç•°å¸¸å¤§é¡ä¸‹æ³¨æ¨¡å¼
    else if (simulationResults.highRiskOutcomes.length > 10) {
      shouldApplyControl = true;
      reason = `æª¢æ¸¬åˆ° ${simulationResults.highRiskOutcomes.length} å€‹é«˜é¢¨éšªä¸‹æ³¨çµ„åˆï¼Œå•Ÿå‹•é¢¨æ§`;
    }
    // æ­£å¸¸æƒ…æ³ä¸‹ç¶­æŒå°‘é‡å¹³å°å„ªå‹¢ï¼ˆç§»é™¤é‡‘é¡é–€æª»ï¼Œä¸€å¾‹æª¢æŸ¥ï¼‰
    else if (platformAdvantage < totalBetAmount * 0.05) {
      shouldApplyControl = true;
      reason = `ç¶­æŒå¥åº·çš„å¹³å°æ”¶ç›Šç‡ï¼Œç¢ºä¿é•·æœŸé‹ç‡Ÿç©©å®š (é æœŸæ”¶ç›Š: ${platformAdvantage.toFixed(2)}, ç›®æ¨™: ${(totalBetAmount * 0.05).toFixed(2)})`;
    } else {
      reason = `å„é …æŒ‡æ¨™æ­£å¸¸ï¼Œç¶­æŒæ­£å¸¸æ©Ÿç‡é–‹ç`;
    }
    
    console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] æ±ºç­–çµæœ: ${shouldApplyControl ? 'è§¸ç™¼æ§åˆ¶' : 'ç¶­æŒæ­£å¸¸'} - ${reason}`);
    
    return {
      shouldApplyControl,
      reason,
      playerWinProbability,
      platformAdvantage,
      totalBetAmount,
      recentProfitLoss,
      allBets,
      simulationResults
    };
    
  } catch (error) {
    console.error('ğŸ¤– [è‡ªå‹•åµæ¸¬] åˆ†æéç¨‹å‡ºéŒ¯:', error);
    return {
      shouldApplyControl: false,
      reason: 'åˆ†æéç¨‹å‡ºéŒ¯ï¼Œä½¿ç”¨æ­£å¸¸æ©Ÿç‡',
      playerWinProbability: 0,
      platformAdvantage: 0
    };
  }
}

// æ¨¡æ“¬æ‰€æœ‰å¯èƒ½çš„é–‹ççµæœ
function simulateAllPossibleOutcomes(allBets) {
  const outcomes = [];
  
  // æŠ½æ¨£æ¨¡æ“¬ï¼ˆå®Œæ•´æ¨¡æ“¬é–‹éŠ·å¤ªå¤§ï¼‰
  const sampleSize = 1000;
  
  for (let i = 0; i < sampleSize; i++) {
    // ç”Ÿæˆéš¨æ©Ÿé–‹ççµæœ
    const result = generateRaceResult();
    
    // è¨ˆç®—è©²çµæœä¸‹çš„ç¸½è¼¸è´
    let totalPlayerWin = 0;
    let totalPlayerBet = 0;
    
    allBets.forEach(bet => {
      const betAmount = parseFloat(bet.amount);
      totalPlayerBet += betAmount;
      
      const winAmount = calculateWinAmountForBet(bet, result);
      if (winAmount > 0) {
        totalPlayerWin += winAmount;
      }
    });
    
    const platformProfit = totalPlayerBet - totalPlayerWin;
    const playerWinRate = totalPlayerBet > 0 ? totalPlayerWin / totalPlayerBet : 0;
    
    outcomes.push({
      result,
      playerWinRate,
      platformProfit,
      totalPlayerWin,
      totalPlayerBet
    });
  }
  
  // çµ±è¨ˆåˆ†æ
  const averagePlayerWinRate = outcomes.reduce((sum, o) => sum + o.playerWinRate, 0) / outcomes.length;
  const averagePlatformProfit = outcomes.reduce((sum, o) => sum + o.platformProfit, 0) / outcomes.length;
  
  // æ‰¾å‡ºé«˜é¢¨éšªçµæœï¼ˆå¹³å°è™§æè¶…éä¸€å®šé–¾å€¼ï¼‰
  const highRiskOutcomes = outcomes.filter(o => o.platformProfit < -o.totalPlayerBet * 0.2);
  
  return {
    averagePlayerWinRate,
    averagePlatformProfit,
    highRiskOutcomes,
    allOutcomes: outcomes
  };
}

// è¨ˆç®—è¿‘æœŸå¹³å°ç›ˆè™§ï¼ˆå°ˆç”¨æ–¼è‡ªå‹•åµæ¸¬ï¼‰
async function calculateRecentPlatformProfitLoss(periods = 5) {
  try {
    // ç²å–æœ€è¿‘NæœŸçš„å·²çµç®—æ³¨å–®
    const recentBets = await db.any(`
      SELECT amount, win, win_amount
      FROM bet_history 
      WHERE settled = true 
      ORDER BY period DESC, id DESC
      LIMIT $1
    `, [periods * 100]); // å‡è¨­æ¯æœŸæœ€å¤š100ç­†ä¸‹æ³¨
    
    let platformProfit = 0;
    
    recentBets.forEach(bet => {
      const betAmount = parseFloat(bet.amount);
      if (bet.win) {
        // ç©å®¶è´éŒ¢ï¼Œå¹³å°è™§æ
        platformProfit -= parseFloat(bet.win_amount) - betAmount;
      } else {
        // ç©å®¶è¼¸éŒ¢ï¼Œå¹³å°ç²åˆ©
        platformProfit += betAmount;
      }
    });
    
    return platformProfit;
  } catch (error) {
    console.error('è¨ˆç®—è¿‘æœŸå¹³å°ç›ˆè™§éŒ¯èª¤:', error);
    return 0;
  }
}

// è¨ˆç®—è‡ªå‹•åµæ¸¬æ§åˆ¶æ¬Šé‡
function calculateAutoDetectWeights(autoDetectResult, betStats) {
  const weights = {
    positions: Array.from({ length: 10 }, () => Array(10).fill(1)),
    sumValue: Array(17).fill(1)
  };
  
  console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] é–‹å§‹è¨ˆç®—æ§åˆ¶æ¬Šé‡...`);
  
  // æ ¹æ“šåˆ†æçµæœèª¿æ•´æ¬Šé‡ç­–ç•¥
  const { allBets, platformAdvantage, playerWinProbability, totalBetAmount } = autoDetectResult;
  
  // æ§åˆ¶å¼·åº¦ï¼šæ ¹æ“šé¢¨éšªç¨‹åº¦æ±ºå®š
  let controlIntensity = 0.3; // åŸºç¤æ§åˆ¶å¼·åº¦
  
  if (platformAdvantage < -totalBetAmount * 0.2) {
    controlIntensity = 0.8; // é«˜é¢¨éšªæ™‚å¼·æ§åˆ¶
  } else if (platformAdvantage < -totalBetAmount * 0.1) {
    controlIntensity = 0.6; // ä¸­é¢¨éšªæ™‚ä¸­ç­‰æ§åˆ¶
  } else if (playerWinProbability > 0.7) {
    controlIntensity = 0.5; // ç©å®¶å‹ç‡éé«˜æ™‚é©åº¦æ§åˆ¶
  }
  
  console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] æ§åˆ¶å¼·åº¦: ${controlIntensity}`);
  
  // åˆ†æç©å®¶ä¸‹æ³¨åˆ†ä½ˆï¼Œå°ç†±é–€é¸é …é€²è¡Œåå‘èª¿æ•´
  const betDistribution = analyzeBetDistribution(allBets);
  
  // èª¿æ•´è™Ÿç¢¼æ¬Šé‡
  betDistribution.numberBets.forEach(bet => {
    const position = parseInt(bet.position) - 1;
    const value = parseInt(bet.bet_value) - 1;
    
    if (position >= 0 && position < 10 && value >= 0 && value < 10) {
      // å°ä¸‹æ³¨é‡‘é¡å¤§çš„é¸é …é™ä½æ¬Šé‡ï¼ˆè®“å¹³å°å°è´ï¼‰
      const betRatio = bet.totalAmount / totalBetAmount;
      if (betRatio > 0.1) { // è¶…é10%çš„ä¸‹æ³¨é›†ä¸­åº¦
        weights.positions[position][value] *= (1 - controlIntensity * betRatio);
        console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] é™ä½ä½ç½®${position+1}è™Ÿç¢¼${value+1}æ¬Šé‡ï¼Œä¸‹æ³¨æ¯”ä¾‹: ${(betRatio*100).toFixed(1)}%`);
      }
    }
  });
  
  // èª¿æ•´å’Œå€¼æ¬Šé‡
  betDistribution.sumValueBets.forEach(bet => {
    const sumIndex = parseInt(bet.bet_value) - 3;
    if (sumIndex >= 0 && sumIndex < 17) {
      const betRatio = bet.totalAmount / totalBetAmount;
      if (betRatio > 0.15) { // è¶…é15%çš„ä¸‹æ³¨é›†ä¸­åº¦
        weights.sumValue[sumIndex] *= (1 - controlIntensity * betRatio);
        console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] é™ä½å’Œå€¼${bet.bet_value}æ¬Šé‡ï¼Œä¸‹æ³¨æ¯”ä¾‹: ${(betRatio*100).toFixed(1)}%`);
      }
    }
  });
  
  console.log(`ğŸ¤– [è‡ªå‹•åµæ¸¬] æ¬Šé‡è¨ˆç®—å®Œæˆ`);
  return weights;
}

// åˆ†æä¸‹æ³¨åˆ†ä½ˆ
function analyzeBetDistribution(allBets) {
  const numberBets = {};
  const sumValueBets = {};
  
  allBets.forEach(bet => {
    const amount = parseFloat(bet.amount);
    
    if (bet.bet_type === 'number') {
      const key = `${bet.position}-${bet.bet_value}`;
      if (!numberBets[key]) {
        numberBets[key] = { position: bet.position, bet_value: bet.bet_value, totalAmount: 0, count: 0 };
      }
      numberBets[key].totalAmount += amount;
      numberBets[key].count += 1;
    } else if (bet.bet_type === 'sumValue') {
      const key = bet.bet_value;
      if (!sumValueBets[key]) {
        sumValueBets[key] = { bet_value: bet.bet_value, totalAmount: 0, count: 0 };
      }
      sumValueBets[key].totalAmount += amount;
      sumValueBets[key].count += 1;
    }
  });
  
  return {
    numberBets: Object.values(numberBets),
    sumValueBets: Object.values(sumValueBets)
  };
}

// è¨ˆç®—å–®ç­†ä¸‹æ³¨çš„è´éŒ¢é‡‘é¡ï¼ˆç”¨æ–¼æ¨¡æ“¬ï¼‰
function calculateWinAmountForBet(bet, winResult) {
  const amount = parseFloat(bet.amount);
  
  if (bet.bet_type === 'number') {
    const position = parseInt(bet.position);
    const betValue = parseInt(bet.bet_value);
    
    if (position >= 1 && position <= 10 && winResult[position - 1] === betValue) {
      return amount * 9; // å›ºå®šè³ ç‡9å€
    }
  } else if (bet.bet_type === 'sumValue') {
    const betSumValue = parseInt(bet.bet_value);
    const actualSumValue = winResult[0] + winResult[1];
    
    if (betSumValue === actualSumValue) {
      // æ ¹æ“šå’Œå€¼è¨ˆç®—è³ ç‡
      const odds = getSumValueOdds(betSumValue);
      return amount * odds;
    }
  } else if (bet.bet_type === 'dragonTiger') {
    const actualResult = winResult[0] > winResult[1] ? 'dragon' : 
                        winResult[0] < winResult[1] ? 'tiger' : 'tie';
    
    if (bet.bet_value === actualResult) {
      if (actualResult === 'tie') {
        return amount * 8; // å’Œå±€è³ ç‡
      } else {
        return amount * 1.88; // é¾è™è³ ç‡
      }
    }
  }
  
  return 0; // æœªä¸­ç
}

// ç²å–å’Œå€¼è³ ç‡
function getSumValueOdds(sumValue) {
  const oddsTable = {
    3: 180, 4: 60, 5: 30, 6: 18, 7: 12, 8: 8, 9: 6, 10: 6,
    11: 6, 12: 8, 13: 12, 14: 18, 15: 30, 16: 60, 17: 180, 18: 180, 19: 180
  };
  return oddsTable[sumValue] || 6;
}
